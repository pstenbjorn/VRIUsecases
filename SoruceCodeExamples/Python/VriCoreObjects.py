import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AssertionValue(object):
    NO='no'
    YES='yes'
    UNKNOWN='unknown'
    OTHER='other'


class BallotReceiptMethod(object):
    EMAIL='email'
    EMAILORONLINE='email-or-online'
    FAX='fax'
    MAIL='mail'
    ONLINE='online'


class ContactMethodType(object):
    EMAIL='email'
    PHONE='phone'
    OTHER='other'


class IdentifierType(object):
    FIPS='fips'
    LOCALLEVEL='local-level'
    NATIONALLEVEL='national-level'
    OCDID='ocd-id'
    STATELEVEL='state-level'
    OTHER='other'


class PhoneCapability(object):
    FAX='fax'
    MMS='mms'
    SMS='sms'
    VOICE='voice'


class ReportingUnitType(object):
    BALLOTBATCH='ballot-batch'
    BALLOTSTYLEAREA='ballot-style-area'
    BOROUGH='borough'
    CITY='city'
    CITYCOUNCIL='city-council'
    COMBINEDPRECINCT='combined-precinct'
    CONGRESSIONAL='congressional'
    COUNTY='county'
    COUNTYCOUNCIL='county-council'
    DROPBOX='drop-box'
    JUDICIAL='judicial'
    MUNICIPALITY='municipality'
    POLLINGPLACE='polling-place'
    PRECINCT='precinct'
    SCHOOL='school'
    SPECIAL='special'
    SPLITPRECINCT='split-precinct'
    STATE='state'
    STATEHOUSE='state-house'
    STATESENATE='state-senate'
    TOWN='town'
    TOWNSHIP='township'
    UTILITY='utility'
    VILLAGE='village'
    VOTECENTER='vote-center'
    WARD='ward'
    WATER='water'
    OTHER='other'


class RequestError(object):
    IDENTITYLOOKUPFAILED='identity-lookup-failed'
    INCOMPLETE='incomplete'
    INCOMPLETEADDRESS='incomplete-address'
    INCOMPLETEBIRTHDATE='incomplete-birth-date'
    INCOMPLETENAME='incomplete-name'
    INCOMPLETESIGNATURE='incomplete-signature'
    INELIGIBLE='ineligible'
    INVALIDFORM='invalid-form'
    OTHER='other'


class RequestForm(object):
    FPCA='fpca'
    NVRA='nvra'
    OTHER='other'


class RequestMethod(object):
    ARMEDFORCESRECRUITMENTOFFICE='armed-forces-recruitment-office'
    MOTORVEHICLEOFFICE='motor-vehicle-office'
    OTHERAGENCYDESIGNATEDBYSTATE='other-agency-designated-by-state'
    PUBLICASSISTANCEOFFICE='public-assistance-office'
    REGISTRATIONDRIVEFROMADVOCACYGROUPORPOLITICALPARTY='registration-drive-from-advocacy-group-or-political-party'
    STATEFUNDEDAGENCYSERVINGPERSONSWITHDISABILITIES='state-funded-agency-serving-persons-with-disabilities'
    VOTERVIAELECTIONREGISTRARSOFFICE='voter-via-election-registrars-office'
    VOTERVIAEMAIL='voter-via-email'
    VOTERVIAFAX='voter-via-fax'
    VOTERVIAINTERNET='voter-via-internet'
    VOTERVIAMAIL='voter-via-mail'
    UNKNOWN='unknown'
    OTHER='other'


class RequestProxyType(object):
    ARMEDFORCESRECRUITMENTOFFICE='armed-forces-recruitment-office'
    MOTORVEHICLEOFFICE='motor-vehicle-office'
    OTHERAGENCYDESIGNATEDBYSTATE='other-agency-designated-by-state'
    PUBLICASSISTANCEOFFICE='public-assistance-office'
    REGISTRATIONDRIVEFROMADVOCACYGROUPORPOLITICALPARTY='registration-drive-from-advocacy-group-or-political-party'
    STATEFUNDEDAGENCYSERVINGPERSONSWITHDISABILITIES='state-funded-agency-serving-persons-with-disabilities'
    OTHER='other'


class SignatureSource(object):
    DMV='dmv'
    LOCAL='local'
    STATE='state'
    VOTER='voter'
    OTHER='other'


class SignatureType(object):
    DYNAMIC='dynamic'
    ELECTRONIC='electronic'
    OTHER='other'


class SuccessAction(object):
    ADDRESSUPDATED='address-updated'
    NAMEUPDATED='name-updated'
    REGISTRATIONCANCELLED='registration-cancelled'
    REGISTRATIONCREATED='registration-created'
    REGISTRATIONUPDATED='registration-updated'
    STATUSUPDATED='status-updated'
    OTHER='other'


class VoterClassificationType(object):
    ACTIVATEDNATIONALGUARD='activated-national-guard'
    ACTIVEDUTY='active-duty'
    ACTIVEDUTYSPOUSEORDEPENDENT='active-duty-spouse-or-dependent'
    CITIZENABROADINTENTTORETURN='citizen-abroad-intent-to-return'
    CITIZENABROADRETURNUNCERTAIN='citizen-abroad-return-uncertain'
    CITIZENABROADNEVERRESIDED='citizen-abroad-never-resided'
    DECEASED='deceased'
    DECLAREDINCOMPETENT='declared-incompetent'
    EIGHTEENONELECTIONDAY='eighteen-on-election-day'
    FELON='felon'
    PERMANENTLYDENIED='permanently-denied'
    PROTECTEDVOTER='protected-voter'
    RESTOREDFELON='restored-felon'
    UNITEDSTATESCITIZEN='united-states-citizen'
    OTHER='other'


class VoterHelperType(object):
    ASSISTANT='assistant'
    WITNESS='witness'


class VoterIdType(object):
    DRIVERSLICENSE='drivers-license'
    LOCALVOTERREGISTRATIONID='local-voter-registration-id'
    SSN='ssn'
    SSN_4='ssn4'
    STATEID='state-id'
    STATEVOTERREGISTRATIONID='state-voter-registration-id'
    UNSPECIFIEDDOCUMENT='unspecified-document'
    UNSPECIFIEDDOCUMENTWITHNAMEANDADDRESS='unspecified-document-with-name-and-address'
    UNSPECIFIEDDOCUMENTWITHPHOTOIDENTIFICATION='unspecified-document-with-photo-identification'
    UNKNOWN='unknown'
    OTHER='other'


class VoterRequestType(object):
    BALLOTREQUEST='ballot-request'
    LOOKUP='lookup'
    REGISTRATION='registration'
    OTHER='other'


class USPSPostalDeliveryBox_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    USPS Box in the required format, and must not include a USPS
    Route. 2. In addition, all thoroughfare, landmark, and postal
    addresses must include a Place Name and a State Name. A Zip Code
    is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, USPSBox=None, CompleteSubaddress=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.USPSBox = USPSBox
        self.CompleteSubaddress = CompleteSubaddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSPostalDeliveryBox_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSPostalDeliveryBox_type.subclass:
            return USPSPostalDeliveryBox_type.subclass(*args_, **kwargs_)
        else:
            return USPSPostalDeliveryBox_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSBox(self): return self.USPSBox
    def set_USPSBox(self, USPSBox): self.USPSBox = USPSBox
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def hasContent_(self):
        if (
            self.USPSBox is not None or
            self.CompleteSubaddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='USPSPostalDeliveryBox_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSPostalDeliveryBox_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSPostalDeliveryBox_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='USPSPostalDeliveryBox_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.action), input_name='action')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='USPSPostalDeliveryBox_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSBox is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<USPSBox>%s</USPSBox>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSBox), input_name='USPSBox')), eol_))
        if self.CompleteSubaddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompleteSubaddress>%s</CompleteSubaddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompleteSubaddress), input_name='CompleteSubaddress')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSBox':
            USPSBox_ = child_.text
            USPSBox_ = self.gds_validate_string(USPSBox_, node, 'USPSBox')
            self.USPSBox = USPSBox_
        elif nodeName_ == 'CompleteSubaddress':
            CompleteSubaddress_ = child_.text
            CompleteSubaddress_ = self.gds_validate_string(CompleteSubaddress_, node, 'CompleteSubaddress')
            self.CompleteSubaddress = CompleteSubaddress_
# end class USPSPostalDeliveryBox_type


class NumberedThoroughfareAddress_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    Complete Address Number and a Complete Street Name. 2. In
    addition, all thoroughfare, landmark, and postal addresses must
    include a Place Name and a State Name. A Zip Code is recommended
    but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, CompletePlaceName=None, CompleteAddressNumber=None, CompleteStreetName=None, CompleteSubaddress=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CompletePlaceName = CompletePlaceName
        self.CompleteAddressNumber = CompleteAddressNumber
        self.CompleteStreetName = CompleteStreetName
        self.CompleteSubaddress = CompleteSubaddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberedThoroughfareAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberedThoroughfareAddress_type.subclass:
            return NumberedThoroughfareAddress_type.subclass(*args_, **kwargs_)
        else:
            return NumberedThoroughfareAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_CompleteStreetName(self): return self.CompleteStreetName
    def set_CompleteStreetName(self, CompleteStreetName): self.CompleteStreetName = CompleteStreetName
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.CompletePlaceName is not None or
            self.CompleteAddressNumber is not None or
            self.CompleteStreetName is not None or
            self.CompleteSubaddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='NumberedThoroughfareAddress_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumberedThoroughfareAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumberedThoroughfareAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NumberedThoroughfareAddress_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.action), input_name='action')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='NumberedThoroughfareAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompleteLandmarkName>%s</CompleteLandmarkName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompleteLandmarkName), input_name='CompleteLandmarkName')), eol_))
        if self.CompletePlaceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompletePlaceName>%s</CompletePlaceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompletePlaceName), input_name='CompletePlaceName')), eol_))
        if self.CompleteAddressNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompleteAddressNumber>%s</CompleteAddressNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompleteAddressNumber), input_name='CompleteAddressNumber')), eol_))
        if self.CompleteStreetName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompleteStreetName>%s</CompleteStreetName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompleteStreetName), input_name='CompleteStreetName')), eol_))
        if self.CompleteSubaddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CompleteSubaddress>%s</CompleteSubaddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CompleteSubaddress), input_name='CompleteSubaddress')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            CompleteLandmarkName_ = child_.text
            CompleteLandmarkName_ = self.gds_validate_string(CompleteLandmarkName_, node, 'CompleteLandmarkName')
            self.CompleteLandmarkName = CompleteLandmarkName_
        elif nodeName_ == 'CompletePlaceName':
            CompletePlaceName_ = child_.text
            CompletePlaceName_ = self.gds_validate_string(CompletePlaceName_, node, 'CompletePlaceName')
            self.CompletePlaceName = CompletePlaceName_
        elif nodeName_ == 'CompleteAddressNumber':
            CompleteAddressNumber_ = child_.text
            CompleteAddressNumber_ = self.gds_validate_string(CompleteAddressNumber_, node, 'CompleteAddressNumber')
            self.CompleteAddressNumber = CompleteAddressNumber_
        elif nodeName_ == 'CompleteStreetName':
            CompleteStreetName_ = child_.text
            CompleteStreetName_ = self.gds_validate_string(CompleteStreetName_, node, 'CompleteStreetName')
            self.CompleteStreetName = CompleteStreetName_
        elif nodeName_ == 'CompleteSubaddress':
            CompleteSubaddress_ = child_.text
            CompleteSubaddress_ = self.gds_validate_string(CompleteSubaddress_, node, 'CompleteSubaddress')
            self.CompleteSubaddress = CompleteSubaddress_
# end class NumberedThoroughfareAddress_type


class AdditionalInfo(GeneratedsSuper):
    """<p> Class for specifying information not addressed in this model by
    other elements and attributes, e.g. state-specific information
    that does not &ldquo;fit&rdquo; in any other element. The
    information will thus be highly specific to the generating
    application, and consuming applications must &ldquo;know&rdquo;
    the meaning of the information to make use of it. For this
    reason, use of this class is discouraged as much as is possible.
    </p> <p> &#160; </p> <p> The <a href="mdel://_18_0_2_6340208_144
    6587603679_902003_6890">StringValue</a> and <a href="mdel://_18_
    0_2_6340208_1464186843386_982801_4458">FileValue</a> attributes
    are both optional, however exactly one of them must be included.
    </p>"""
    subclass = None
    superclass = None
    def __init__(self, FileValue=None, Name=None, StringValue=None):
        self.original_tagname_ = None
        self.FileValue = FileValue
        self.Name = Name
        self.StringValue = StringValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalInfo.subclass:
            return AdditionalInfo.subclass(*args_, **kwargs_)
        else:
            return AdditionalInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FileValue(self): return self.FileValue
    def set_FileValue(self, FileValue): self.FileValue = FileValue
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_StringValue(self): return self.StringValue
    def set_StringValue(self, StringValue): self.StringValue = StringValue
    def hasContent_(self):
        if (
            self.FileValue is not None or
            self.Name is not None or
            self.StringValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AdditionalInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdditionalInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AdditionalInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdditionalInfo'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AdditionalInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FileValue is not None:
            self.FileValue.export(outfile, level, namespaceprefix_, name_='FileValue', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.StringValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StringValue>%s</StringValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StringValue), input_name='StringValue')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FileValue':
            class_obj_ = self.get_class_obj_(child_, File)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FileValue = obj_
            obj_.original_tagname_ = 'FileValue'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'StringValue':
            StringValue_ = child_.text
            StringValue_ = self.gds_validate_string(StringValue_, node, 'StringValue')
            self.StringValue = StringValue_
# end class AdditionalInfo


class BallotRequest(GeneratedsSuper):
    """An abstract class representing a request for a ballot. Classes for
    specific types of BallotRequest inherit the attributes and
    define their own."""
    subclass = None
    superclass = None
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None, extensiontype_=None):
        self.original_tagname_ = None
        if BallotReceiptPreference is None:
            self.BallotReceiptPreference = []
        else:
            self.BallotReceiptPreference = BallotReceiptPreference
        self.MailForwardingAddress = MailForwardingAddress
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BallotRequest.subclass:
            return BallotRequest.subclass(*args_, **kwargs_)
        else:
            return BallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BallotReceiptPreference(self): return self.BallotReceiptPreference
    def set_BallotReceiptPreference(self, BallotReceiptPreference): self.BallotReceiptPreference = BallotReceiptPreference
    def add_BallotReceiptPreference(self, value): self.BallotReceiptPreference.append(value)
    def insert_BallotReceiptPreference_at(self, index, value): self.BallotReceiptPreference.insert(index, value)
    def replace_BallotReceiptPreference_at(self, index, value): self.BallotReceiptPreference[index] = value
    def get_MailForwardingAddress(self): return self.MailForwardingAddress
    def set_MailForwardingAddress(self, MailForwardingAddress): self.MailForwardingAddress = MailForwardingAddress
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BallotReceiptMethod(self, value):
        # Validate type BallotReceiptMethod, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['email', 'email-or-online', 'fax', 'mail', 'online']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BallotReceiptMethod' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BallotReceiptPreference or
            self.MailForwardingAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BallotRequest'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BallotRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BallotReceiptPreference_ in self.BallotReceiptPreference:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BallotReceiptPreference>%s</BallotReceiptPreference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(BallotReceiptPreference_), input_name='BallotReceiptPreference')), eol_))
        if self.MailForwardingAddress is not None:
            self.MailForwardingAddress.export(outfile, level, namespaceprefix_, name_='MailForwardingAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BallotReceiptPreference':
            BallotReceiptPreference_ = child_.text
            BallotReceiptPreference_ = self.gds_validate_string(BallotReceiptPreference_, node, 'BallotReceiptPreference')
            self.BallotReceiptPreference.append(BallotReceiptPreference_)
            # validate type BallotReceiptMethod
            self.validate_BallotReceiptMethod(self.BallotReceiptPreference[-1])
        elif nodeName_ == 'MailForwardingAddress':
            obj_ = MailForwardingAddressType.factory()
            obj_.build(child_)
            self.MailForwardingAddress = obj_
            obj_.original_tagname_ = 'MailForwardingAddress'
# end class BallotRequest


class BallotStyle(GeneratedsSuper):
    """<p> For defining a ballot style composed of ordered content (i.e.
    Headers or Contests) and their ballot selections, and
    associating the ballot style with a political party, a reference
    to an image of the ballot, and a reference to the a precinct or
    other geopolitical unit that the ballot is unique to. <a href="m
    del://_17_0_2_4_f71035d_1426101822599_430942_2209">Election</a>
    includes BallotStyle. </p> <p> &#160; </p> <p> BallotStyle
    references <a href="mdel://_18_5_3_43701b0_1520434015209_434672_
    4990">OrderedContent</a> to include content that appears on that
    ballot style. To preserve any rotation associated with the
    ballot, it is expected that the generating application will list
    the occurrences of <a href="mdel://_17_0_3_43401a7_1394476416139
    _808596_3142">OrderedContest</a> in the order as on the ballot
    for the associated geopolitical unit. </p> <p> &#160; </p> <p>
    BallotStyle references one or more <a href="mdel://_17_0_2_4_78e
    0236_1389366233346_42391_2380">GpUnit</a> instances defined for
    the associated precincts or split precincts. If the ballot style
    is associated with multiple precincts (or other geographies),
    multiple references to the precinct <a href="mdel://_17_0_2_4_78
    e0236_1389366233346_42391_2380">GpUnit</a> instances can be
    included. </p> <p> &#160; </p> <p> When including <a href="mdel:
    //_17_0_2_4_f71035d_1430405712653_451634_2410">ExternalIdentifie
    r</a>, if the type is not listed in enumeration <a href="mdel://
    _17_0_2_4_f71035d_1425061188508_163854_2613">IdentifierType</a>,
    use other and include the type (that is not listed in the
    enumeration) in <a href="mdel://_17_0_2_4_f71035d_1430405732252_
    109247_2429">OtherType</a>. </p>"""
    subclass = None
    superclass = None
    def __init__(self, ExternalIdentifier=None, ImageUri=None, Party=None):
        self.original_tagname_ = None
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        if ImageUri is None:
            self.ImageUri = []
        else:
            self.ImageUri = ImageUri
        if Party is None:
            self.Party = []
        else:
            self.Party = Party
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BallotStyle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BallotStyle.subclass:
            return BallotStyle.subclass(*args_, **kwargs_)
        else:
            return BallotStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_ImageUri(self): return self.ImageUri
    def set_ImageUri(self, ImageUri): self.ImageUri = ImageUri
    def add_ImageUri(self, value): self.ImageUri.append(value)
    def insert_ImageUri_at(self, index, value): self.ImageUri.insert(index, value)
    def replace_ImageUri_at(self, index, value): self.ImageUri[index] = value
    def get_Party(self): return self.Party
    def set_Party(self, Party): self.Party = Party
    def add_Party(self, value): self.Party.append(value)
    def insert_Party_at(self, index, value): self.Party.insert(index, value)
    def replace_Party_at(self, index, value): self.Party[index] = value
    def hasContent_(self):
        if (
            self.ExternalIdentifier or
            self.ImageUri or
            self.Party
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BallotStyle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BallotStyle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BallotStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BallotStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BallotStyle'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BallotStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        for ImageUri_ in self.ImageUri:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ImageUri>%s</ImageUri>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ImageUri_), input_name='ImageUri')), eol_))
        for Party_ in self.Party:
            Party_.export(outfile, level, namespaceprefix_, name_='Party', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'ImageUri':
            ImageUri_ = child_.text
            ImageUri_ = self.gds_validate_string(ImageUri_, node, 'ImageUri')
            self.ImageUri.append(ImageUri_)
        elif nodeName_ == 'Party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Party.append(obj_)
            obj_.original_tagname_ = 'Party'
# end class BallotStyle


class ContactMethod(GeneratedsSuper):
    """<p> Used in request and response messages. </p> <p> &#160; </p> <p>
    <a href="mdel://_18_0_2_6340208_1458237760549_706380_5243">Elect
    ionAdministration</a> optionally includes this class to specify
    how to contact the election administration. </p> <p> &#160; </p>
    <p> <a href="mdel://_18_0_2_6340208_1446583854986_159465_5958">V
    oterRegistration</a> optionally includes this class to specify
    the method for contacting a voter regarding the voter&rsquo;s
    registration request. If the voter can be contacted in multiple
    ways, the application creating the data should order the
    occurrences of <a href="mdel://_18_0_2_6340208_1464893400979_739
    933_4444">ContactMethod</a> by priority. </p> <p> &#160; </p>
    <p> The <a href="mdel://_18_0_2_6340208_1465493970792_917703_443
    0">PhoneContactMethod</a> class uses <a href="mdel://_18_0_2_634
    0208_1464893400979_739933_4444">ContactMethod</a> as a base
    class, and should be used with when the contact method is for a
    telephone and it is necessary to describe the capabilities of
    the telephone. </p> <p> &#160; </p> <p> The <a href="mdel://_18_
    0_2_6340208_1465493985158_54379_4458">Capability</a> attribute
    is provided by the <a href="mdel://_18_0_2_6340208_1465493970792
    _917703_4430">PhoneContactMethod</a> class. </p>"""
    subclass = None
    superclass = None
    def __init__(self, OtherType=None, Type=None, Value=None, extensiontype_=None):
        self.original_tagname_ = None
        self.OtherType = OtherType
        self.Type = Type
        self.validate_ContactMethodType(self.Type)
        self.Value = Value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactMethod.subclass:
            return ContactMethod.subclass(*args_, **kwargs_)
        else:
            return ContactMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ContactMethodType(self, value):
        # Validate type ContactMethodType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['email', 'phone', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ContactMethodType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OtherType is not None or
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ContactMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ContactMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContactMethod'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ContactMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Value>%s</Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type ContactMethodType
            self.validate_ContactMethodType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ContactMethod


class Election(GeneratedsSuper):
    """Describes an election event. Only the date of the election is
    required. Other attributes may be used to describe the election
    for which a ballot is requested."""
    subclass = None
    superclass = None
    def __init__(self, EndDate=None, ExternalIdentifier=None, Name=None, StartDate=None):
        self.original_tagname_ = None
        if isinstance(EndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EndDate
        self.EndDate = initvalue_
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        self.Name = Name
        if isinstance(StartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = StartDate
        self.StartDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Election)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Election.subclass:
            return Election.subclass(*args_, **kwargs_)
        else:
            return Election(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def hasContent_(self):
        if (
            self.EndDate is not None or
            self.ExternalIdentifier or
            self.Name is not None or
            self.StartDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Election', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Election')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Election')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Election', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Election'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Election', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EndDate>%s</EndDate>%s' % (self.gds_format_date(self.EndDate, input_name='EndDate'), eol_))
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.StartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StartDate>%s</StartDate>%s' % (self.gds_format_date(self.StartDate, input_name='StartDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EndDate = dval_
        elif nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'StartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.StartDate = dval_
# end class Election


class ElectionAdministration(GeneratedsSuper):
    """<p> Used in response messages. </p> <p> &#160; <br><a href="mdel://_
    18_0_2_6340208_1458237760549_706380_5243">ElectionAdministration
    </a> optionally includes <a href="mdel://_18_0_2_6340208_1467137
    072139_851331_4587">ContactMethod</a> to specify contact
    information for the election authority. </p>"""
    subclass = None
    superclass = None
    def __init__(self, ContactMethod=None, Location=None, Name=None, Uri=None):
        self.original_tagname_ = None
        if ContactMethod is None:
            self.ContactMethod = []
        else:
            self.ContactMethod = ContactMethod
        self.Location = Location
        self.Name = Name
        if Uri is None:
            self.Uri = []
        else:
            self.Uri = Uri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectionAdministration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectionAdministration.subclass:
            return ElectionAdministration.subclass(*args_, **kwargs_)
        else:
            return ElectionAdministration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactMethod(self): return self.ContactMethod
    def set_ContactMethod(self, ContactMethod): self.ContactMethod = ContactMethod
    def add_ContactMethod(self, value): self.ContactMethod.append(value)
    def insert_ContactMethod_at(self, index, value): self.ContactMethod.insert(index, value)
    def replace_ContactMethod_at(self, index, value): self.ContactMethod[index] = value
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Uri(self): return self.Uri
    def set_Uri(self, Uri): self.Uri = Uri
    def add_Uri(self, value): self.Uri.append(value)
    def insert_Uri_at(self, index, value): self.Uri.insert(index, value)
    def replace_Uri_at(self, index, value): self.Uri[index] = value
    def hasContent_(self):
        if (
            self.ContactMethod or
            self.Location is not None or
            self.Name is not None or
            self.Uri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ElectionAdministration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectionAdministration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectionAdministration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ElectionAdministration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectionAdministration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ElectionAdministration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContactMethod_ in self.ContactMethod:
            ContactMethod_.export(outfile, level, namespaceprefix_, name_='ContactMethod', pretty_print=pretty_print)
        if self.Location is not None:
            self.Location.export(outfile, level, namespaceprefix_, name_='Location', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        for Uri_ in self.Uri:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Uri>%s</Uri>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Uri_), input_name='Uri')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactMethod':
            class_obj_ = self.get_class_obj_(child_, ContactMethod)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ContactMethod.append(obj_)
            obj_.original_tagname_ = 'ContactMethod'
        elif nodeName_ == 'Location':
            obj_ = Location.factory()
            obj_.build(child_)
            self.Location = obj_
            obj_.original_tagname_ = 'Location'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Uri':
            Uri_ = child_.text
            Uri_ = self.gds_validate_string(Uri_, node, 'Uri')
            self.Uri.append(Uri_)
# end class ElectionAdministration


class ElectionBasedBallotRequest(BallotRequest):
    """A kind of ballot request in which a ballot for a single election
    event is requested."""
    subclass = None
    superclass = BallotRequest
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None, Election=None):
        self.original_tagname_ = None
        super(ElectionBasedBallotRequest, self).__init__(BallotReceiptPreference, MailForwardingAddress, )
        self.Election = Election
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectionBasedBallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectionBasedBallotRequest.subclass:
            return ElectionBasedBallotRequest.subclass(*args_, **kwargs_)
        else:
            return ElectionBasedBallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Election(self): return self.Election
    def set_Election(self, Election): self.Election = Election
    def hasContent_(self):
        if (
            self.Election is not None or
            super(ElectionBasedBallotRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ElectionBasedBallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectionBasedBallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectionBasedBallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ElectionBasedBallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectionBasedBallotRequest'):
        super(ElectionBasedBallotRequest, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectionBasedBallotRequest')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ElectionBasedBallotRequest', fromsubclass_=False, pretty_print=True):
        super(ElectionBasedBallotRequest, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Election is not None:
            self.Election.export(outfile, level, namespaceprefix_, name_='Election', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectionBasedBallotRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Election':
            obj_ = Election.factory()
            obj_.build(child_)
            self.Election = obj_
            obj_.original_tagname_ = 'Election'
        super(ElectionBasedBallotRequest, self).buildChildren(child_, node, nodeName_, True)
# end class ElectionBasedBallotRequest


class ExternalIdentifier(GeneratedsSuper):
    """<p> Used in request and response messages. </p> <p> &#160; </p> <p>
    <a href="mdel://_18_5_2_43701b0_1510603645561_775691_5960">Elect
    ion</a>, <a href="mdel://_18_0_2_6340208_1446583854985_482559_59
    56">Party</a> and <a href="mdel://_18_0_2_6340208_1458229422042_
    966646_4539">ReportingUnit</a> optionally include this class for
    associating a jurisdiction&rsquo;s codes, i.e., identifiers,
    with political parties or geopolitical units such as counties,
    towns, precincts, etc. Multiple occurrences of <a href="mdel://_
    18_0_2_6340208_1446584770723_729230_6705">ExternalIdentifier</a>
    can be used to associate multiple codes, e.g., if there is a
    desire to associate multiple codes with an object such as state-
    specific codes as well as OCD-IDs (Open Civic Data Identifiers).
    </p>"""
    subclass = None
    superclass = None
    def __init__(self, OtherType=None, Type=None, Value=None):
        self.original_tagname_ = None
        self.OtherType = OtherType
        self.Type = Type
        self.validate_IdentifierType(self.Type)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalIdentifier.subclass:
            return ExternalIdentifier.subclass(*args_, **kwargs_)
        else:
            return ExternalIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_IdentifierType(self, value):
        # Validate type IdentifierType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fips', 'local-level', 'national-level', 'ocd-id', 'state-level', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IdentifierType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OtherType is not None or
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ExternalIdentifier', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ExternalIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExternalIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ExternalIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Value>%s</Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type IdentifierType
            self.validate_IdentifierType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ExternalIdentifier


class File(GeneratedsSuper):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> <a
    href="mdel://_18_0_2_6340208_1448398278986_542661_4430">VoterId<
    /a> optionally uses this class for <a href="mdel://_18_0_2_63402
    08_1464186405548_20750_4438">FileValue</a> to specify a filename
    for voter identification purposes such as for a utility bill. <a
    href="mdel://_18_0_2_6340208_1446587509996_176108_6861">Addition
    alInfo</a> also optionally includes <a href="mdel://_18_0_2_6340
    208_1464186843386_982801_4458">FileValue</a>. </p> <p> &#160;
    </p> <p> File extends the xsd:base64Binary type to add the
    attributes for filename and (Multi-Purpose Internet Mail
    Extensions) MIME type, e.g., application/pdf for a file of type
    PDF. </p> <p> &#160; </p> <p> The <a href="mdel://_18_0_2_634020
    8_1452879607465_248768_5229">Image</a> element uses this element
    as an supertype, thus <a href="mdel://_18_0_2_6340208_1452879607
    465_248768_5229">Image</a> can be used when the type of file is
    for an image, e.g., image/png. </p> The filename. The MIME type
    associated with the file."""
    subclass = None
    superclass = None
    def __init__(self, fileName=None, mimeType=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.fileName = _cast(None, fileName)
        self.mimeType = _cast(None, mimeType)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, File)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if File.subclass:
            return File.subclass(*args_, **kwargs_)
        else:
            return File(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileName(self): return self.fileName
    def set_fileName(self, fileName): self.fileName = fileName
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='File', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('File')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='File')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='File', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='File'):
        if self.fileName is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            outfile.write(' fileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileName), input_name='fileName')), ))
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mimeType), input_name='mimeType')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='File', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileName', node)
        if value is not None and 'fileName' not in already_processed:
            already_processed.add('fileName')
            self.fileName = value
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File


class Image(File):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> <a href="mdel
    ://_18_0_2_6340208_1452788035217_489009_4409">Signature</a>
    optionally includes this class to indicate that a file contains
    an image of a voter&rsquo;s signature. Image uses <a
    href="mdel://_18_0_2_6340208_1452879654116_509055_5255">File</a>
    as supertype, thus attributes of <a
    href="mdel://_18_0_2_6340208_1452879654116_509055_5255">File</a>
    can be included in Image. </p>"""
    subclass = None
    superclass = File
    def __init__(self, fileName=None, mimeType=None):
        self.original_tagname_ = None
        super(Image, self).__init__(fileName, mimeType, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Image)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Image, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Image', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Image', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Image'):
        super(Image, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Image', fromsubclass_=False, pretty_print=True):
        super(Image, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Image, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Image, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Image


class LatLng(GeneratedsSuper):
    """<p> Used in response messages. </p> <p> &#160; </p> <p> <a
    href="mdel://_18_0_2_6340208_1460480132036_876890_4538">Location
    </a> optionally includes this element to specify the latitude
    and longitude of a voter&rsquo;s voting location. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Latitude=None, Longitude=None, Source=None):
        self.original_tagname_ = None
        self.Latitude = Latitude
        self.Longitude = Longitude
        self.Source = Source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LatLng)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LatLng.subclass:
            return LatLng.subclass(*args_, **kwargs_)
        else:
            return LatLng(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def hasContent_(self):
        if (
            self.Latitude is not None or
            self.Longitude is not None or
            self.Source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='LatLng', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LatLng')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LatLng')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='LatLng', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LatLng'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='LatLng', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Latitude>%s</Latitude>%s' % (self.gds_format_float(self.Latitude, input_name='Latitude'), eol_))
        if self.Longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Longitude>%s</Longitude>%s' % (self.gds_format_float(self.Longitude, input_name='Longitude'), eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Source>%s</Source>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Source), input_name='Source')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Latitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Latitude')
            self.Latitude = fval_
        elif nodeName_ == 'Longitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Longitude')
            self.Longitude = fval_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
# end class LatLng


class Location(GeneratedsSuper):
    """<p> Used in response messages. </p> <p> &#160; </p> <p> <a href="mde
    l://_18_0_2_6340208_1458229422042_966646_4539">ReportingUnit</a>
    and <a href="mdel://_18_0_2_6340208_1458237760549_706380_5243">E
    lectionAdministration</a> optionally include this element to
    specify the address and directions to a voter&rsquo;s voting
    location. The <a href="mdel://_18_0_2_6340208_1458229746146_4543
    5_4773">LatLng</a> element can be included to specify the
    latitude and longitude of the voting location. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Address=None, Directions=None, LatLng=None):
        self.original_tagname_ = None
        self.Address = Address
        self.Directions = Directions
        self.LatLng = LatLng
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Directions(self): return self.Directions
    def set_Directions(self, Directions): self.Directions = Directions
    def get_LatLng(self): return self.LatLng
    def set_LatLng(self, LatLng): self.LatLng = LatLng
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Directions is not None or
            self.LatLng is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Location', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Location')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Location'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespaceprefix_, name_='Address', pretty_print=pretty_print)
        if self.Directions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Directions>%s</Directions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Directions), input_name='Directions')), eol_))
        if self.LatLng is not None:
            self.LatLng.export(outfile, level, namespaceprefix_, name_='LatLng', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Directions':
            Directions_ = child_.text
            Directions_ = self.gds_validate_string(Directions_, node, 'Directions')
            self.Directions = Directions_
        elif nodeName_ == 'LatLng':
            obj_ = LatLng.factory()
            obj_.build(child_)
            self.LatLng = obj_
            obj_.original_tagname_ = 'LatLng'
# end class Location


class Name(GeneratedsSuper):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> <a
    href="mdel://_18_5_3_43701b0_1520354792154_717315_5628">Voter</a
    > includes this class for specifying the name of a voter and,
    optionally, for specifying a previous name of the voter, using
    <a href="mdel://_18_0_2_6340208_1446583855001_628958_6011">Previ
    ousName</a> instead of Name. <a href="mdel://_18_0_2_6340208_147
    0256600538_323550_4366">ReguestHelper</a> also includes this
    class for specifying the name of a registration helper. </p> <p>
    &#160; </p> <p> Multiple occurrences of the <a href="mdel://_18_
    0_2_6340208_1453305616868_302875_4310">MiddleName</a> attribute
    can be used as needed, e.g., for names with additional middle
    names or nicknames such as &ldquo;John Andrew Winston (Jack)
    Smith&rdquo;. </p> <p> &#160; </p> <p> All elements are
    optional, however at least <a href="mdel://_18_0_2_6340208_14465
    91484368_838009_7101">FullName</a> must be included if the other
    attributes are not. </p>"""
    subclass = None
    superclass = None
    def __init__(self, FirstName=None, FullName=None, LastName=None, MiddleName=None, Prefix=None, Suffix=None, valueOf_=None):
        self.original_tagname_ = None
        self.FirstName = FirstName
        self.FullName = FullName
        self.LastName = LastName
        if MiddleName is None:
            self.MiddleName = []
        else:
            self.MiddleName = MiddleName
        self.Prefix = Prefix
        self.Suffix = Suffix
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Name.subclass:
            return Name.subclass(*args_, **kwargs_)
        else:
            return Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def get_FullName(self): return self.FullName
    def set_FullName(self, FullName): self.FullName = FullName
    def get_LastName(self): return self.LastName
    def set_LastName(self, LastName): self.LastName = LastName
    def get_MiddleName(self): return self.MiddleName
    def set_MiddleName(self, MiddleName): self.MiddleName = MiddleName
    def add_MiddleName(self, value): self.MiddleName.append(value)
    def insert_MiddleName_at(self, index, value): self.MiddleName.insert(index, value)
    def replace_MiddleName_at(self, index, value): self.MiddleName[index] = value
    def get_Prefix(self): return self.Prefix
    def set_Prefix(self, Prefix): self.Prefix = Prefix
    def get_Suffix(self): return self.Suffix
    def set_Suffix(self, Suffix): self.Suffix = Suffix
    def hasContent_(self):
        if (
            self.FirstName is not None or
            self.FullName is not None or
            self.LastName is not None or
            self.MiddleName or
            self.Prefix is not None or
            self.Suffix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Name', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Name', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Name'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Name', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FirstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FirstName>%s</FirstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FirstName), input_name='FirstName')), eol_))
        if self.FullName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FullName>%s</FullName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FullName), input_name='FullName')), eol_))
        if self.LastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LastName>%s</LastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LastName), input_name='LastName')), eol_))
        for MiddleName_ in self.MiddleName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MiddleName>%s</MiddleName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(MiddleName_), input_name='MiddleName')), eol_))
        if self.Prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Prefix>%s</Prefix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Prefix), input_name='Prefix')), eol_))
        if self.Suffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suffix>%s</Suffix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suffix), input_name='Suffix')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FirstName':
            FirstName_ = child_.text
            FirstName_ = self.gds_validate_string(FirstName_, node, 'FirstName')
            self.FirstName = FirstName_
        elif nodeName_ == 'FullName':
            FullName_ = child_.text
            FullName_ = self.gds_validate_string(FullName_, node, 'FullName')
            self.FullName = FullName_
        elif nodeName_ == 'LastName':
            LastName_ = child_.text
            LastName_ = self.gds_validate_string(LastName_, node, 'LastName')
            self.LastName = LastName_
        elif nodeName_ == 'MiddleName':
            MiddleName_ = child_.text
            MiddleName_ = self.gds_validate_string(MiddleName_, node, 'MiddleName')
            self.MiddleName.append(MiddleName_)
        elif nodeName_ == 'Prefix':
            Prefix_ = child_.text
            Prefix_ = self.gds_validate_string(Prefix_, node, 'Prefix')
            self.Prefix = Prefix_
        elif nodeName_ == 'Suffix':
            Suffix_ = child_.text
            Suffix_ = self.gds_validate_string(Suffix_, node, 'Suffix')
            self.Suffix = Suffix_
# end class Name


class Party(GeneratedsSuper):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> <a
    href="mdel://_18_5_3_43701b0_1520354792154_717315_5628">Voter</a
    > includes this element to specify a voter&rsquo;s political
    party. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, ExternalIdentifier=None, Name=None):
        self.original_tagname_ = None
        self.Abbreviation = Abbreviation
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        self.Name = Name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.Abbreviation is not None or
            self.ExternalIdentifier or
            self.Name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Party', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Party'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Party', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Abbreviation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Abbreviation>%s</Abbreviation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Abbreviation), input_name='Abbreviation')), eol_))
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Abbreviation':
            Abbreviation_ = child_.text
            Abbreviation_ = self.gds_validate_string(Abbreviation_, node, 'Abbreviation')
            self.Abbreviation = Abbreviation_
        elif nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
# end class Party


class PermanentBallotRequest(BallotRequest):
    """A kind of ballot request which serves to request ballots for
    election events that the voter is qualified on a long term
    basis. Although "permanent", the request may be subject to
    renewal or cancellation procedures."""
    subclass = None
    superclass = BallotRequest
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None):
        self.original_tagname_ = None
        super(PermanentBallotRequest, self).__init__(BallotReceiptPreference, MailForwardingAddress, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermanentBallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermanentBallotRequest.subclass:
            return PermanentBallotRequest.subclass(*args_, **kwargs_)
        else:
            return PermanentBallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PermanentBallotRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='PermanentBallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PermanentBallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PermanentBallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PermanentBallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PermanentBallotRequest'):
        super(PermanentBallotRequest, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PermanentBallotRequest')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PermanentBallotRequest', fromsubclass_=False, pretty_print=True):
        super(PermanentBallotRequest, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PermanentBallotRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PermanentBallotRequest, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PermanentBallotRequest


class PhoneContactMethod(ContactMethod):
    """<p> Used in request and response messages. </p> <p> &#160; </p> <p>
    <a href="mdel://_18_0_2_6340208_1470256600538_323550_4366">Reque
    stHelper</a>, and <a href="mdel://_18_0_2_6340208_1448401688329_
    700093_4402">RequestProxy</a> use this class to specify a
    telephone number as well as the capabilities of the telephone,
    e.g., sms, fax, etc. </p> <p> &#160; </p> <p> PhoneContactMethod
    is subtype <a href="mdel://_18_0_2_6340208_1464893400979_739933_
    4444">ContactMethod</a>. Thus, the elements that include <a href
    ="mdel://_18_0_2_6340208_1464893400979_739933_4444">ContactMetho
    d</a> could use PhoneContactMethod as applicable. </p>"""
    subclass = None
    superclass = ContactMethod
    def __init__(self, OtherType=None, Type=None, Value=None, Capability=None):
        self.original_tagname_ = None
        super(PhoneContactMethod, self).__init__(OtherType, Type, Value, )
        if Capability is None:
            self.Capability = []
        else:
            self.Capability = Capability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhoneContactMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhoneContactMethod.subclass:
            return PhoneContactMethod.subclass(*args_, **kwargs_)
        else:
            return PhoneContactMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Capability(self): return self.Capability
    def set_Capability(self, Capability): self.Capability = Capability
    def add_Capability(self, value): self.Capability.append(value)
    def insert_Capability_at(self, index, value): self.Capability.insert(index, value)
    def replace_Capability_at(self, index, value): self.Capability[index] = value
    def validate_PhoneCapability(self, value):
        # Validate type PhoneCapability, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fax', 'mms', 'sms', 'voice']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhoneCapability' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Capability or
            super(PhoneContactMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='PhoneContactMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhoneContactMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhoneContactMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PhoneContactMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhoneContactMethod'):
        super(PhoneContactMethod, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhoneContactMethod')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PhoneContactMethod', fromsubclass_=False, pretty_print=True):
        super(PhoneContactMethod, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Capability_ in self.Capability:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Capability>%s</Capability>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Capability_), input_name='Capability')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PhoneContactMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Capability':
            Capability_ = child_.text
            Capability_ = self.gds_validate_string(Capability_, node, 'Capability')
            self.Capability.append(Capability_)
            # validate type PhoneCapability
            self.validate_PhoneCapability(self.Capability[-1])
        super(PhoneContactMethod, self).buildChildren(child_, node, nodeName_, True)
# end class PhoneContactMethod


class ReportingUnit(GeneratedsSuper):
    """<p> Used in response messages. </p> <p> &#160; </p> <p> <a href="mde
    l://_18_0_2_6340208_1455906719413_171772_4514">VoterRecordsRespo
    nse</a> includes this class when a registration request is
    successful so as to provide a list of geopolitical geography
    associated with the voter&rsquo;s registration, e.g., the
    voter&rsquo;s precinct, polling place, districts, etc. The Type
    attribute uses the <a href="mdel://_18_0_2_6340208_1458229388461
    _823405_4464">ReportingUnitType</a> enumeration to specify the
    type of geopolitical geography being defined. If the reporting
    unit type is not listed in enumeration <a href="mdel://_18_0_2_6
    340208_1458229388461_823405_4464">ReportingUnitType</a>, use
    other and include the reporting unit type (that is not listed in
    the enumeration) in OtherType. </p> <p> &#160; </p> <p> The
    IsDistricted boolean is not strictly necessary, as it is
    possible to identify districts by their Type attribute. However,
    if the type of district is not listed in the <a href="mdel://_18
    _0_2_6340208_1458229388461_823405_4464">ReportingUnitType</a>
    enumeration and therefore OtherType is used, then IsDistricted
    is necessary. The IsDistricted boolean can also be used to
    signify that a ReportingUnit defined as a jurisdiction, e.g., a
    county, is also used as a district for, e.g., county-wide
    contests. </p>"""
    subclass = None
    superclass = None
    def __init__(self, ExternalIdentifier=None, IsDistricted=None, Location=None, Name=None, OtherType=None, Type=None):
        self.original_tagname_ = None
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        self.IsDistricted = IsDistricted
        self.Location = Location
        self.Name = Name
        self.OtherType = OtherType
        self.Type = Type
        self.validate_ReportingUnitType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingUnit.subclass:
            return ReportingUnit.subclass(*args_, **kwargs_)
        else:
            return ReportingUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_IsDistricted(self): return self.IsDistricted
    def set_IsDistricted(self, IsDistricted): self.IsDistricted = IsDistricted
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ReportingUnitType(self, value):
        # Validate type ReportingUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ballot-batch', 'ballot-style-area', 'borough', 'city', 'city-council', 'combined-precinct', 'congressional', 'county', 'county-council', 'drop-box', 'judicial', 'municipality', 'polling-place', 'precinct', 'school', 'special', 'split-precinct', 'state', 'state-house', 'state-senate', 'town', 'township', 'utility', 'village', 'vote-center', 'ward', 'water', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ExternalIdentifier or
            self.IsDistricted is not None or
            self.Location is not None or
            self.Name is not None or
            self.OtherType is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ReportingUnit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReportingUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReportingUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ReportingUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReportingUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ReportingUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        if self.IsDistricted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsDistricted>%s</IsDistricted>%s' % (self.gds_format_boolean(self.IsDistricted, input_name='IsDistricted'), eol_))
        if self.Location is not None:
            self.Location.export(outfile, level, namespaceprefix_, name_='Location', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'IsDistricted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsDistricted')
            self.IsDistricted = ival_
        elif nodeName_ == 'Location':
            obj_ = Location.factory()
            obj_.build(child_)
            self.Location = obj_
            obj_.original_tagname_ = 'Location'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type ReportingUnitType
            self.validate_ReportingUnitType(self.Type)
# end class ReportingUnit


class RequestHelper(GeneratedsSuper):
    """<p> <a href="mdel://_18_0_2_6340208_1446583854986_237644_5961">Voter
    RecordsRequest</a> optionally includes this element to specify
    information about a request helper, i.e., a request assistant or
    witness involved in a voter&rsquo;s request. </p> <p> &#160;
    </p> <p> RequestAssistant includes the <a
    href="mdel://_18_0_2_6340208_1446583854986_538708_5957">Name</a>
    element to specify the registration helper&rsquo;s name and
    optionally includes the <a href="mdel://_18_0_2_6340208_14527880
    35217_489009_4409">Signature</a> element if a registration
    helper&rsquo;s signature is required. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Address=None, Name=None, Phone=None, Signature=None, Type=None):
        self.original_tagname_ = None
        self.Address = Address
        self.Name = Name
        self.Phone = Phone
        self.Signature = Signature
        self.Type = Type
        self.validate_VoterHelperType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestHelper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestHelper.subclass:
            return RequestHelper.subclass(*args_, **kwargs_)
        else:
            return RequestHelper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VoterHelperType(self, value):
        # Validate type VoterHelperType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['assistant', 'witness']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterHelperType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Name is not None or
            self.Phone is not None or
            self.Signature is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestHelper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestHelper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestHelper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestHelper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestHelper'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestHelper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespaceprefix_, name_='Address', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespaceprefix_, name_='Name', pretty_print=pretty_print)
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespaceprefix_, name_='Phone', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_, name_='Signature', pretty_print=pretty_print)
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType1.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Phone':
            obj_ = PhoneContactMethod.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
        elif nodeName_ == 'Signature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type VoterHelperType
            self.validate_VoterHelperType(self.Type)
# end class RequestHelper


class RequestProxy(GeneratedsSuper):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> <a href="mdel
    ://_18_0_2_6340208_1446583854986_237644_5961">VoterRecordsReques
    t</a> optionally includes this class to specify information
    about a request proxy involved in a voter records request. </p>
    <p> &#160; </p> <p> OriginTransactionId can be used to include
    an optional identifier of the originating external transaction
    from the proxy, e.g., used for the transaction ID generated by a
    DMV application enacting a voter registration request to a
    registration portal application (on behalf of a citizen
    obtaining a driver&rsquo;s license). This sub-element is not to
    be confused with TransactionId in <a href="mdel://_18_0_2_634020
    8_1446583854986_237644_5961">VoterRecordsRequest</a>, which is
    used to include a transaction ID of the voter records request,
    e.g., the transaction ID of the registration portal&rsquo;s
    voter records request. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Address=None, Name=None, OriginTransactionId=None, OtherType=None, Phone=None, TimeStamp=None, Type=None):
        self.original_tagname_ = None
        self.Address = Address
        self.Name = Name
        self.OriginTransactionId = OriginTransactionId
        self.OtherType = OtherType
        self.Phone = Phone
        if isinstance(TimeStamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeStamp, '%Y-%m-%d').date()
        else:
            initvalue_ = TimeStamp
        self.TimeStamp = initvalue_
        self.Type = Type
        self.validate_RequestProxyType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestProxy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestProxy.subclass:
            return RequestProxy.subclass(*args_, **kwargs_)
        else:
            return RequestProxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OriginTransactionId(self): return self.OriginTransactionId
    def set_OriginTransactionId(self, OriginTransactionId): self.OriginTransactionId = OriginTransactionId
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_TimeStamp(self): return self.TimeStamp
    def set_TimeStamp(self, TimeStamp): self.TimeStamp = TimeStamp
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_RequestProxyType(self, value):
        # Validate type RequestProxyType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['armed-forces-recruitment-office', 'motor-vehicle-office', 'other-agency-designated-by-state', 'public-assistance-office', 'registration-drive-from-advocacy-group-or-political-party', 'state-funded-agency-serving-persons-with-disabilities', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestProxyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Name is not None or
            self.OriginTransactionId is not None or
            self.OtherType is not None or
            self.Phone is not None or
            self.TimeStamp is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestProxy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestProxy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestProxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestProxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestProxy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestProxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespaceprefix_, name_='Address', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.OriginTransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OriginTransactionId>%s</OriginTransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginTransactionId), input_name='OriginTransactionId')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespaceprefix_, name_='Phone', pretty_print=pretty_print)
        if self.TimeStamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TimeStamp>%s</TimeStamp>%s' % (self.gds_format_date(self.TimeStamp, input_name='TimeStamp'), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType2.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'OriginTransactionId':
            OriginTransactionId_ = child_.text
            OriginTransactionId_ = self.gds_validate_string(OriginTransactionId_, node, 'OriginTransactionId')
            self.OriginTransactionId = OriginTransactionId_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Phone':
            obj_ = PhoneContactMethod.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
        elif nodeName_ == 'TimeStamp':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.TimeStamp = dval_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type RequestProxyType
            self.validate_RequestProxyType(self.Type)
# end class RequestProxy


class Signature(GeneratedsSuper):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> <a
    href="mdel://_18_5_3_43701b0_1520354792154_717315_5628">Voter</a
    > includes this class for specifying information about a
    voter&rsquo;s signature on a registration request. If there is a
    need to include previous signature that uses a different name,
    e.g., a maiden name, <a href="mdel://_18_5_3_43701b0_15203547921
    54_717315_5628">Voter</a> uses PreviousSignature instead of
    Signature. </p> <p> &#160; </p> <p> Source is used to specify
    the source of the voter&rsquo;s signature, for example, on file
    at a department of motor vehicles. FileValue is used to include
    an image of the voter&rsquo;s signature. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Date=None, FileValue=None, OtherSource=None, OtherType=None, Source=None, Type=None):
        self.original_tagname_ = None
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.FileValue = FileValue
        self.OtherSource = OtherSource
        self.OtherType = OtherType
        self.Source = Source
        self.validate_SignatureSource(self.Source)
        self.Type = Type
        self.validate_SignatureType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Signature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Signature.subclass:
            return Signature.subclass(*args_, **kwargs_)
        else:
            return Signature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_FileValue(self): return self.FileValue
    def set_FileValue(self, FileValue): self.FileValue = FileValue
    def get_OtherSource(self): return self.OtherSource
    def set_OtherSource(self, OtherSource): self.OtherSource = OtherSource
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SignatureSource(self, value):
        # Validate type SignatureSource, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dmv', 'local', 'state', 'voter', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SignatureSource' % {"value" : value.encode("utf-8")} )
    def validate_SignatureType(self, value):
        # Validate type SignatureType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dynamic', 'electronic', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SignatureType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Date is not None or
            self.FileValue is not None or
            self.OtherSource is not None or
            self.OtherType is not None or
            self.Source is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Signature', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Signature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Signature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Signature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Signature'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Signature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Date>%s</Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.FileValue is not None:
            self.FileValue.export(outfile, level, namespaceprefix_, name_='FileValue', pretty_print=pretty_print)
        if self.OtherSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherSource>%s</OtherSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherSource), input_name='OtherSource')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Source>%s</Source>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Source), input_name='Source')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'FileValue':
            obj_ = Image.factory()
            obj_.build(child_)
            self.FileValue = obj_
            obj_.original_tagname_ = 'FileValue'
        elif nodeName_ == 'OtherSource':
            OtherSource_ = child_.text
            OtherSource_ = self.gds_validate_string(OtherSource_, node, 'OtherSource')
            self.OtherSource = OtherSource_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
            # validate type SignatureSource
            self.validate_SignatureSource(self.Source)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type SignatureType
            self.validate_SignatureType(self.Type)
# end class Signature


class TemporalBallotRequest(BallotRequest):
    """A kind of ballot request in which election opportunities that the
    voter is qualified during a given time frame will be requested."""
    subclass = None
    superclass = BallotRequest
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None, EndDate=None, StartDate=None):
        self.original_tagname_ = None
        super(TemporalBallotRequest, self).__init__(BallotReceiptPreference, MailForwardingAddress, )
        if isinstance(EndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EndDate
        self.EndDate = initvalue_
        if isinstance(StartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = StartDate
        self.StartDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalBallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalBallotRequest.subclass:
            return TemporalBallotRequest.subclass(*args_, **kwargs_)
        else:
            return TemporalBallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def hasContent_(self):
        if (
            self.EndDate is not None or
            self.StartDate is not None or
            super(TemporalBallotRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='TemporalBallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemporalBallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemporalBallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TemporalBallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TemporalBallotRequest'):
        super(TemporalBallotRequest, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemporalBallotRequest')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TemporalBallotRequest', fromsubclass_=False, pretty_print=True):
        super(TemporalBallotRequest, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EndDate>%s</EndDate>%s' % (self.gds_format_date(self.EndDate, input_name='EndDate'), eol_))
        if self.StartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StartDate>%s</StartDate>%s' % (self.gds_format_date(self.StartDate, input_name='StartDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TemporalBallotRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EndDate = dval_
        elif nodeName_ == 'StartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.StartDate = dval_
        super(TemporalBallotRequest, self).buildChildren(child_, node, nodeName_, True)
# end class TemporalBallotRequest


class Voter(GeneratedsSuper):
    """Voter contains attributes specific to identifying a voter."""
    subclass = None
    superclass = None
    def __init__(self, ContactMethod=None, DateOfBirth=None, Ethnicity=None, 
                 Gender=None, MailingAddress=None, Name=None, Party=None, 
                 PreviousName=None, PreviousResidenceAddress=None, 
                 PreviousSignature=None, ResidenceAddress=None, 
                 ResidenceAddressIsMailingAddress=None, 
                 Signature=None, VoterClassification=None, VoterId=None, extensiontype_=None):
        self.original_tagname_ = None
        if ContactMethod is None:
            self.ContactMethod = []
        else:
            self.ContactMethod = ContactMethod
        if isinstance(DateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = DateOfBirth
        self.DateOfBirth = initvalue_
        self.Ethnicity = Ethnicity
        self.Gender = Gender
        self.MailingAddress = MailingAddress
        self.Name = Name
        self.Party = Party
        self.PreviousName = PreviousName
        self.PreviousResidenceAddress = PreviousResidenceAddress
        self.PreviousSignature = PreviousSignature
        self.ResidenceAddress = ResidenceAddress
        self.ResidenceAddressIsMailingAddress = ResidenceAddressIsMailingAddress
        self.Signature = Signature
        if VoterClassification is None:
            self.VoterClassification = []
        else:
            self.VoterClassification = VoterClassification
        if VoterId is None:
            self.VoterId = []
        else:
            self.VoterId = VoterId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Voter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Voter.subclass:
            return Voter.subclass(*args_, **kwargs_)
        else:
            return Voter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactMethod(self): return self.ContactMethod
    def set_ContactMethod(self, ContactMethod): self.ContactMethod = ContactMethod
    def add_ContactMethod(self, value): self.ContactMethod.append(value)
    def insert_ContactMethod_at(self, index, value): self.ContactMethod.insert(index, value)
    def replace_ContactMethod_at(self, index, value): self.ContactMethod[index] = value
    def get_DateOfBirth(self): return self.DateOfBirth
    def set_DateOfBirth(self, DateOfBirth): self.DateOfBirth = DateOfBirth
    def get_Ethnicity(self): return self.Ethnicity
    def set_Ethnicity(self, Ethnicity): self.Ethnicity = Ethnicity
    def get_Gender(self): return self.Gender
    def set_Gender(self, Gender): self.Gender = Gender
    def get_MailingAddress(self): return self.MailingAddress
    def set_MailingAddress(self, MailingAddress): self.MailingAddress = MailingAddress
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Party(self): return self.Party
    def set_Party(self, Party): self.Party = Party
    def get_PreviousName(self): return self.PreviousName
    def set_PreviousName(self, PreviousName): self.PreviousName = PreviousName
    def get_PreviousResidenceAddress(self): return self.PreviousResidenceAddress
    def set_PreviousResidenceAddress(self, PreviousResidenceAddress): self.PreviousResidenceAddress = PreviousResidenceAddress
    def get_PreviousSignature(self): return self.PreviousSignature
    def set_PreviousSignature(self, PreviousSignature): self.PreviousSignature = PreviousSignature
    def get_ResidenceAddress(self): return self.ResidenceAddress
    def set_ResidenceAddress(self, ResidenceAddress): self.ResidenceAddress = ResidenceAddress
    def get_ResidenceAddressIsMailingAddress(self): return self.ResidenceAddressIsMailingAddress
    def set_ResidenceAddressIsMailingAddress(self, ResidenceAddressIsMailingAddress): self.ResidenceAddressIsMailingAddress = ResidenceAddressIsMailingAddress
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_VoterClassification(self): return self.VoterClassification
    def set_VoterClassification(self, VoterClassification): self.VoterClassification = VoterClassification
    def add_VoterClassification(self, value): self.VoterClassification.append(value)
    def insert_VoterClassification_at(self, index, value): self.VoterClassification.insert(index, value)
    def replace_VoterClassification_at(self, index, value): self.VoterClassification[index] = value
    def get_VoterId(self): return self.VoterId
    def set_VoterId(self, VoterId): self.VoterId = VoterId
    def add_VoterId(self, value): self.VoterId.append(value)
    def insert_VoterId_at(self, index, value): self.VoterId.insert(index, value)
    def replace_VoterId_at(self, index, value): self.VoterId[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.ContactMethod or
            self.DateOfBirth is not None or
            self.Ethnicity is not None or
            self.Gender is not None or
            self.MailingAddress is not None or
            self.Name is not None or
            self.Party is not None or
            self.PreviousName is not None or
            self.PreviousResidenceAddress is not None or
            self.PreviousSignature is not None or
            self.ResidenceAddress is not None or
            self.ResidenceAddressIsMailingAddress is not None or
            self.Signature is not None or
            self.VoterClassification or
            self.VoterId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Voter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Voter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Voter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Voter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Voter'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Voter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContactMethod_ in self.ContactMethod:
            ContactMethod_.export(outfile, level, namespaceprefix_, name_='ContactMethod', pretty_print=pretty_print)
        if self.DateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DateOfBirth>%s</DateOfBirth>%s' % (self.gds_format_date(self.DateOfBirth, input_name='DateOfBirth'), eol_))
        if self.Ethnicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Ethnicity>%s</Ethnicity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Ethnicity), input_name='Ethnicity')), eol_))
        if self.Gender is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Gender>%s</Gender>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Gender), input_name='Gender')), eol_))
        if self.MailingAddress is not None:
            self.MailingAddress.export(outfile, level, namespaceprefix_, name_='MailingAddress', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespaceprefix_, name_='Name', pretty_print=pretty_print)
        if self.Party is not None:
            self.Party.export(outfile, level, namespaceprefix_, name_='Party', pretty_print=pretty_print)
        if self.PreviousName is not None:
            self.PreviousName.export(outfile, level, namespaceprefix_, name_='PreviousName', pretty_print=pretty_print)
        if self.PreviousResidenceAddress is not None:
            self.PreviousResidenceAddress.export(outfile, level, namespaceprefix_, name_='PreviousResidenceAddress', pretty_print=pretty_print)
        if self.PreviousSignature is not None:
            self.PreviousSignature.export(outfile, level, namespaceprefix_, name_='PreviousSignature', pretty_print=pretty_print)
        if self.ResidenceAddress is not None:
            self.ResidenceAddress.export(outfile, level, namespaceprefix_, name_='ResidenceAddress', pretty_print=pretty_print)
        if self.ResidenceAddressIsMailingAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ResidenceAddressIsMailingAddress>%s</ResidenceAddressIsMailingAddress>%s' % (self.gds_format_boolean(self.ResidenceAddressIsMailingAddress, input_name='ResidenceAddressIsMailingAddress'), eol_))
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_, name_='Signature', pretty_print=pretty_print)
        for VoterClassification_ in self.VoterClassification:
            VoterClassification_.export(outfile, level, namespaceprefix_, name_='VoterClassification', pretty_print=pretty_print)
        for VoterId_ in self.VoterId:
            VoterId_.export(outfile, level, namespaceprefix_, name_='VoterId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactMethod':
            class_obj_ = self.get_class_obj_(child_, ContactMethod)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ContactMethod.append(obj_)
            obj_.original_tagname_ = 'ContactMethod'
        elif nodeName_ == 'DateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateOfBirth = dval_
        elif nodeName_ == 'Ethnicity':
            Ethnicity_ = child_.text
            Ethnicity_ = self.gds_validate_string(Ethnicity_, node, 'Ethnicity')
            self.Ethnicity = Ethnicity_
        elif nodeName_ == 'Gender':
            Gender_ = child_.text
            Gender_ = self.gds_validate_string(Gender_, node, 'Gender')
            self.Gender = Gender_
        elif nodeName_ == 'MailingAddress':
            obj_ = MailingAddressType.factory()
            obj_.build(child_)
            self.MailingAddress = obj_
            obj_.original_tagname_ = 'MailingAddress'
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Party = obj_
            obj_.original_tagname_ = 'Party'
        elif nodeName_ == 'PreviousName':
            obj_ = Name.factory()
            obj_.build(child_)
            self.PreviousName = obj_
            obj_.original_tagname_ = 'PreviousName'
        elif nodeName_ == 'PreviousResidenceAddress':
            obj_ = PreviousResidenceAddressType.factory()
            obj_.build(child_)
            self.PreviousResidenceAddress = obj_
            obj_.original_tagname_ = 'PreviousResidenceAddress'
        elif nodeName_ == 'PreviousSignature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.PreviousSignature = obj_
            obj_.original_tagname_ = 'PreviousSignature'
        elif nodeName_ == 'ResidenceAddress':
            obj_ = ResidenceAddressType.factory()
            obj_.build(child_)
            self.ResidenceAddress = obj_
            obj_.original_tagname_ = 'ResidenceAddress'
        elif nodeName_ == 'ResidenceAddressIsMailingAddress':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ResidenceAddressIsMailingAddress')
            self.ResidenceAddressIsMailingAddress = ival_
        elif nodeName_ == 'Signature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'VoterClassification':
            obj_ = VoterClassification.factory()
            obj_.build(child_)
            self.VoterClassification.append(obj_)
            obj_.original_tagname_ = 'VoterClassification'
        elif nodeName_ == 'VoterId':
            obj_ = VoterId.factory()
            obj_.build(child_)
            self.VoterId.append(obj_)
            obj_.original_tagname_ = 'VoterId'
# end class Voter


class VoterClassification(GeneratedsSuper):
    """<p> <a
    href="mdel://_18_5_3_43701b0_1520354792154_717315_5628">Voter</a
    > includes this class to describe a voter&rsquo;s classification
    per criteria on the voter&rsquo;s request form, e.g., united-
    states-citizen or eighteen-on-election-day. </p> <p> &#160; </p>
    <p> VoterClassification includes assertions of the voter in
    response to the voter request form criteria. For example, an
    assertion of true may be used with a criterion of united-states-
    citizen. Assertions can be negative, such as providing an
    assertion of false for a criterion of felon, an assertion of
    unknown to indicate that the voter does not know whether they
    meet or do not meet the specific criteria on the form or an
    assertion of other, in which the assertion is specified by the
    value of OtherAssertion. </p>"""
    subclass = None
    superclass = None
    def __init__(self, Assertion=None, OtherAssertion=None, OtherType=None, Type=None):
        self.original_tagname_ = None
        self.Assertion = Assertion
        self.validate_AssertionValue(self.Assertion)
        self.OtherAssertion = OtherAssertion
        self.OtherType = OtherType
        self.Type = Type
        self.validate_VoterClassificationType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterClassification.subclass:
            return VoterClassification.subclass(*args_, **kwargs_)
        else:
            return VoterClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Assertion(self): return self.Assertion
    def set_Assertion(self, Assertion): self.Assertion = Assertion
    def get_OtherAssertion(self): return self.OtherAssertion
    def set_OtherAssertion(self, OtherAssertion): self.OtherAssertion = OtherAssertion
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AssertionValue(self, value):
        # Validate type AssertionValue, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['no', 'yes', 'unknown', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssertionValue' % {"value" : value.encode("utf-8")} )
    def validate_VoterClassificationType(self, value):
        # Validate type VoterClassificationType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['activated-national-guard', 'active-duty', 'active-duty-spouse-or-dependent', 'citizen-abroad-intent-to-return', 'citizen-abroad-return-uncertain', 'citizen-abroad-never-resided', 'deceased', 'declared-incompetent', 'eighteen-on-election-day', 'felon', 'permanently-denied', 'protected-voter', 'restored-felon', 'united-states-citizen', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterClassificationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Assertion is not None or
            self.OtherAssertion is not None or
            self.OtherType is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterClassification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterClassification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterClassification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterClassification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterClassification'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterClassification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Assertion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Assertion>%s</Assertion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Assertion), input_name='Assertion')), eol_))
        if self.OtherAssertion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherAssertion>%s</OtherAssertion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherAssertion), input_name='OtherAssertion')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Assertion':
            Assertion_ = child_.text
            Assertion_ = self.gds_validate_string(Assertion_, node, 'Assertion')
            self.Assertion = Assertion_
            # validate type AssertionValue
            self.validate_AssertionValue(self.Assertion)
        elif nodeName_ == 'OtherAssertion':
            OtherAssertion_ = child_.text
            OtherAssertion_ = self.gds_validate_string(OtherAssertion_, node, 'OtherAssertion')
            self.OtherAssertion = OtherAssertion_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type VoterClassificationType
            self.validate_VoterClassificationType(self.Type)
# end class VoterClassification


class VoterId(GeneratedsSuper):
    """<p> Used in request messages. </p> <p> &#160; </p> <p> Used to
    include information about a voter&rsquo;s identification that
    may be required in a registration request. <a href="mdel://_18_5
    _3_43701b0_1520354792154_717315_5628">Voter</a> includes
    VoterId. </p> <p> &#160; </p> <p> AttestNoSuchId is used to
    attest that the voter has no ID of a specified type, thus it
    must be included with a value of true if attesting that the
    voter has no ID for that specified type. It can be included with
    a value of false to attest that the voter does have an ID of the
    specified type, in which case either StringValue or FileValue
    must be included; however, it is assumed to be false if not
    included. The StringValue and FileValue sub-elements are both
    optional, however at least one of them must be included. </p>"""
    subclass = None
    superclass = None
    def __init__(self, AttestNoSuchId=None, DateOfIssuance=None, FileValue=None, OtherType=None, StringValue=None, Type=None):
        self.original_tagname_ = None
        self.AttestNoSuchId = AttestNoSuchId
        if isinstance(DateOfIssuance, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateOfIssuance, '%Y-%m-%d').date()
        else:
            initvalue_ = DateOfIssuance
        self.DateOfIssuance = initvalue_
        self.FileValue = FileValue
        self.OtherType = OtherType
        self.StringValue = StringValue
        self.Type = Type
        self.validate_VoterIdType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterId.subclass:
            return VoterId.subclass(*args_, **kwargs_)
        else:
            return VoterId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttestNoSuchId(self): return self.AttestNoSuchId
    def set_AttestNoSuchId(self, AttestNoSuchId): self.AttestNoSuchId = AttestNoSuchId
    def get_DateOfIssuance(self): return self.DateOfIssuance
    def set_DateOfIssuance(self, DateOfIssuance): self.DateOfIssuance = DateOfIssuance
    def get_FileValue(self): return self.FileValue
    def set_FileValue(self, FileValue): self.FileValue = FileValue
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_StringValue(self): return self.StringValue
    def set_StringValue(self, StringValue): self.StringValue = StringValue
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VoterIdType(self, value):
        # Validate type VoterIdType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['drivers-license', 'local-voter-registration-id', 'ssn', 'ssn4', 'state-id', 'state-voter-registration-id', 'unspecified-document', 'unspecified-document-with-name-and-address', 'unspecified-document-with-photo-identification', 'unknown', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AttestNoSuchId is not None or
            self.DateOfIssuance is not None or
            self.FileValue is not None or
            self.OtherType is not None or
            self.StringValue is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterId', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterId'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttestNoSuchId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AttestNoSuchId>%s</AttestNoSuchId>%s' % (self.gds_format_boolean(self.AttestNoSuchId, input_name='AttestNoSuchId'), eol_))
        if self.DateOfIssuance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DateOfIssuance>%s</DateOfIssuance>%s' % (self.gds_format_date(self.DateOfIssuance, input_name='DateOfIssuance'), eol_))
        if self.FileValue is not None:
            self.FileValue.export(outfile, level, namespaceprefix_, name_='FileValue', pretty_print=pretty_print)
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.StringValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StringValue>%s</StringValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StringValue), input_name='StringValue')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttestNoSuchId':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AttestNoSuchId')
            self.AttestNoSuchId = ival_
        elif nodeName_ == 'DateOfIssuance':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateOfIssuance = dval_
        elif nodeName_ == 'FileValue':
            class_obj_ = self.get_class_obj_(child_, File)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FileValue = obj_
            obj_.original_tagname_ = 'FileValue'
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'StringValue':
            StringValue_ = child_.text
            StringValue_ = self.gds_validate_string(StringValue_, node, 'StringValue')
            self.StringValue = StringValue_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type VoterIdType
            self.validate_VoterIdType(self.Type)
# end class VoterId


class VoterParticipation(GeneratedsSuper):
    """For indicating an election that the voter participated in.
    Participation does not imply a counted ballot."""
    subclass = None
    superclass = None
    def __init__(self, BallotStyle=None, Election=None):
        self.original_tagname_ = None
        self.BallotStyle = BallotStyle
        self.Election = Election
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterParticipation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterParticipation.subclass:
            return VoterParticipation.subclass(*args_, **kwargs_)
        else:
            return VoterParticipation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BallotStyle(self): return self.BallotStyle
    def set_BallotStyle(self, BallotStyle): self.BallotStyle = BallotStyle
    def get_Election(self): return self.Election
    def set_Election(self, Election): self.Election = Election
    def hasContent_(self):
        if (
            self.BallotStyle is not None or
            self.Election is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterParticipation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterParticipation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterParticipation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterParticipation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterParticipation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterParticipation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BallotStyle is not None:
            self.BallotStyle.export(outfile, level, namespaceprefix_, name_='BallotStyle', pretty_print=pretty_print)
        if self.Election is not None:
            self.Election.export(outfile, level, namespaceprefix_, name_='Election', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BallotStyle':
            obj_ = BallotStyle.factory()
            obj_.build(child_)
            self.BallotStyle = obj_
            obj_.original_tagname_ = 'BallotStyle'
        elif nodeName_ == 'Election':
            obj_ = Election.factory()
            obj_.build(child_)
            self.Election = obj_
            obj_.original_tagname_ = 'Election'
# end class VoterParticipation


class VoterRecord(Voter):
    """A subtype of Voter representing a voter record stored in a Voter
    Registration Database (VRDB). VoterRecord optionally contains
    additional information useful to the voter, including a
    description of the voter polling place, districts associated
    with the polling place, or other geopolitical geographies such
    as the voter precinct."""
    subclass = None
    superclass = Voter
    def __init__(self, ContactMethod=None, DateOfBirth=None, Ethnicity=None, Gender=None, MailingAddress=None, Name=None, Party=None, PreviousName=None, PreviousResidenceAddress=None, PreviousSignature=None, ResidenceAddress=None, ResidenceAddressIsMailingAddress=None, Signature=None, VoterClassification=None, VoterId=None, District=None, ElectionAdministration=None, Locality=None, PollingLocation=None, VoterParticipation=None):
        self.original_tagname_ = None
        super(VoterRecord, self).__init__(ContactMethod, DateOfBirth, Ethnicity, Gender, MailingAddress, Name, Party, PreviousName, PreviousResidenceAddress, PreviousSignature, ResidenceAddress, ResidenceAddressIsMailingAddress, Signature, VoterClassification, VoterId, )
        if District is None:
            self.District = []
        else:
            self.District = District
        self.ElectionAdministration = ElectionAdministration
        if Locality is None:
            self.Locality = []
        else:
            self.Locality = Locality
        self.PollingLocation = PollingLocation
        if VoterParticipation is None:
            self.VoterParticipation = []
        else:
            self.VoterParticipation = VoterParticipation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecord.subclass:
            return VoterRecord.subclass(*args_, **kwargs_)
        else:
            return VoterRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_District(self): return self.District
    def set_District(self, District): self.District = District
    def add_District(self, value): self.District.append(value)
    def insert_District_at(self, index, value): self.District.insert(index, value)
    def replace_District_at(self, index, value): self.District[index] = value
    def get_ElectionAdministration(self): return self.ElectionAdministration
    def set_ElectionAdministration(self, ElectionAdministration): self.ElectionAdministration = ElectionAdministration
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def add_Locality(self, value): self.Locality.append(value)
    def insert_Locality_at(self, index, value): self.Locality.insert(index, value)
    def replace_Locality_at(self, index, value): self.Locality[index] = value
    def get_PollingLocation(self): return self.PollingLocation
    def set_PollingLocation(self, PollingLocation): self.PollingLocation = PollingLocation
    def get_VoterParticipation(self): return self.VoterParticipation
    def set_VoterParticipation(self, VoterParticipation): self.VoterParticipation = VoterParticipation
    def add_VoterParticipation(self, value): self.VoterParticipation.append(value)
    def insert_VoterParticipation_at(self, index, value): self.VoterParticipation.insert(index, value)
    def replace_VoterParticipation_at(self, index, value): self.VoterParticipation[index] = value
    def hasContent_(self):
        if (
            self.District or
            self.ElectionAdministration is not None or
            self.Locality or
            self.PollingLocation is not None or
            self.VoterParticipation or
            super(VoterRecord, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecord', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecord'):
        super(VoterRecord, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecord')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecord', fromsubclass_=False, pretty_print=True):
        super(VoterRecord, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for District_ in self.District:
            District_.export(outfile, level, namespaceprefix_, name_='District', pretty_print=pretty_print)
        if self.ElectionAdministration is not None:
            self.ElectionAdministration.export(outfile, level, namespaceprefix_, name_='ElectionAdministration', pretty_print=pretty_print)
        for Locality_ in self.Locality:
            Locality_.export(outfile, level, namespaceprefix_, name_='Locality', pretty_print=pretty_print)
        if self.PollingLocation is not None:
            self.PollingLocation.export(outfile, level, namespaceprefix_, name_='PollingLocation', pretty_print=pretty_print)
        for VoterParticipation_ in self.VoterParticipation:
            VoterParticipation_.export(outfile, level, namespaceprefix_, name_='VoterParticipation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VoterRecord, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'District':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.District.append(obj_)
            obj_.original_tagname_ = 'District'
        elif nodeName_ == 'ElectionAdministration':
            obj_ = ElectionAdministration.factory()
            obj_.build(child_)
            self.ElectionAdministration = obj_
            obj_.original_tagname_ = 'ElectionAdministration'
        elif nodeName_ == 'Locality':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.Locality.append(obj_)
            obj_.original_tagname_ = 'Locality'
        elif nodeName_ == 'PollingLocation':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.PollingLocation = obj_
            obj_.original_tagname_ = 'PollingLocation'
        elif nodeName_ == 'VoterParticipation':
            obj_ = VoterParticipation.factory()
            obj_.build(child_)
            self.VoterParticipation.append(obj_)
            obj_.original_tagname_ = 'VoterParticipation'
        super(VoterRecord, self).buildChildren(child_, node, nodeName_, True)
# end class VoterRecord


class VoterRecordsRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AdditionalInfo=None, BallotRequest=None, Form=None, 
                 GeneratedDate=None, Issuer=None, OtherForm=None, OtherRequestMethod=None, 
                 OtherType=None, RequestHelper=None, RequestMethod=None, 
                 RequestProxy=None, SelectedLanguage=None, Subject=None, 
                 TransactionId=None, Type=None, VendorApplicationId=None):
        self.original_tagname_ = None
        if AdditionalInfo is None:
            self.AdditionalInfo = []
        else:
            self.AdditionalInfo = AdditionalInfo
        self.BallotRequest = BallotRequest
        self.Form = Form
        self.validate_RequestForm(self.Form)
        if isinstance(GeneratedDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(GeneratedDate, '%Y-%m-%d').date()
        else:
            initvalue_ = GeneratedDate
        self.GeneratedDate = initvalue_
        self.Issuer = Issuer
        self.OtherForm = OtherForm
        self.OtherRequestMethod = OtherRequestMethod
        self.OtherType = OtherType
        if RequestHelper is None:
            self.RequestHelper = []
        else:
            self.RequestHelper = RequestHelper
        self.RequestMethod = RequestMethod
        self.validate_RequestMethod(self.RequestMethod)
        self.RequestProxy = RequestProxy
        self.SelectedLanguage = SelectedLanguage
        self.Subject = Subject
        self.TransactionId = TransactionId
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        self.VendorApplicationId = VendorApplicationId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecordsRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecordsRequest.subclass:
            return VoterRecordsRequest.subclass(*args_, **kwargs_)
        else:
            return VoterRecordsRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdditionalInfo(self): return self.AdditionalInfo
    def set_AdditionalInfo(self, AdditionalInfo): self.AdditionalInfo = AdditionalInfo
    def add_AdditionalInfo(self, value): self.AdditionalInfo.append(value)
    def insert_AdditionalInfo_at(self, index, value): self.AdditionalInfo.insert(index, value)
    def replace_AdditionalInfo_at(self, index, value): self.AdditionalInfo[index] = value
    def get_BallotRequest(self): return self.BallotRequest
    def set_BallotRequest(self, BallotRequest): self.BallotRequest = BallotRequest
    def get_Form(self): return self.Form
    def set_Form(self, Form): self.Form = Form
    def get_GeneratedDate(self): return self.GeneratedDate
    def set_GeneratedDate(self, GeneratedDate): self.GeneratedDate = GeneratedDate
    def get_Issuer(self): return self.Issuer
    def set_Issuer(self, Issuer): self.Issuer = Issuer
    def get_OtherForm(self): return self.OtherForm
    def set_OtherForm(self, OtherForm): self.OtherForm = OtherForm
    def get_OtherRequestMethod(self): return self.OtherRequestMethod
    def set_OtherRequestMethod(self, OtherRequestMethod): self.OtherRequestMethod = OtherRequestMethod
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_RequestHelper(self): return self.RequestHelper
    def set_RequestHelper(self, RequestHelper): self.RequestHelper = RequestHelper
    def add_RequestHelper(self, value): self.RequestHelper.append(value)
    def insert_RequestHelper_at(self, index, value): self.RequestHelper.insert(index, value)
    def replace_RequestHelper_at(self, index, value): self.RequestHelper[index] = value
    def get_RequestMethod(self): return self.RequestMethod
    def set_RequestMethod(self, RequestMethod): self.RequestMethod = RequestMethod
    def get_RequestProxy(self): return self.RequestProxy
    def set_RequestProxy(self, RequestProxy): self.RequestProxy = RequestProxy
    def get_SelectedLanguage(self): return self.SelectedLanguage
    def set_SelectedLanguage(self, SelectedLanguage): self.SelectedLanguage = SelectedLanguage
    def get_Subject(self): return self.Subject
    def set_Subject(self, Subject): self.Subject = Subject
    def get_TransactionId(self): return self.TransactionId
    def set_TransactionId(self, TransactionId): self.TransactionId = TransactionId
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type_at(self, index, value): self.Type.insert(index, value)
    def replace_Type_at(self, index, value): self.Type[index] = value
    def get_VendorApplicationId(self): return self.VendorApplicationId
    def set_VendorApplicationId(self, VendorApplicationId): self.VendorApplicationId = VendorApplicationId
    def validate_RequestForm(self, value):
        # Validate type RequestForm, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fpca', 'nvra', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestForm' % {"value" : value.encode("utf-8")} )
    def validate_RequestMethod(self, value):
        # Validate type RequestMethod, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['armed-forces-recruitment-office', 'motor-vehicle-office', 'other-agency-designated-by-state', 'public-assistance-office', 'registration-drive-from-advocacy-group-or-political-party', 'state-funded-agency-serving-persons-with-disabilities', 'voter-via-election-registrars-office', 'voter-via-email', 'voter-via-fax', 'voter-via-internet', 'voter-via-mail', 'unknown', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestMethod' % {"value" : value.encode("utf-8")} )
    def validate_VoterRequestType(self, value):
        # Validate type VoterRequestType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ballot-request', 'lookup', 'registration', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterRequestType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AdditionalInfo or
            self.BallotRequest is not None or
            self.Form is not None or
            self.GeneratedDate is not None or
            self.Issuer is not None or
            self.OtherForm is not None or
            self.OtherRequestMethod is not None or
            self.OtherType is not None or
            self.RequestHelper or
            self.RequestMethod is not None or
            self.RequestProxy is not None or
            self.SelectedLanguage is not None or
            self.Subject is not None or
            self.TransactionId is not None or
            self.Type or
            self.VendorApplicationId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecordsRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecordsRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecordsRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecordsRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecordsRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecordsRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AdditionalInfo_ in self.AdditionalInfo:
            AdditionalInfo_.export(outfile, level, namespaceprefix_, name_='AdditionalInfo', pretty_print=pretty_print)
        if self.BallotRequest is not None:
            self.BallotRequest.export(outfile, level, namespaceprefix_, name_='BallotRequest', pretty_print=pretty_print)
        if self.Form is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Form>%s</Form>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Form), input_name='Form')), eol_))
        if self.GeneratedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GeneratedDate>%s</GeneratedDate>%s' % (self.gds_format_date(self.GeneratedDate, input_name='GeneratedDate'), eol_))
        if self.Issuer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Issuer>%s</Issuer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Issuer), input_name='Issuer')), eol_))
        if self.OtherForm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherForm>%s</OtherForm>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherForm), input_name='OtherForm')), eol_))
        if self.OtherRequestMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherRequestMethod>%s</OtherRequestMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherRequestMethod), input_name='OtherRequestMethod')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        for RequestHelper_ in self.RequestHelper:
            RequestHelper_.export(outfile, level, namespaceprefix_, name_='RequestHelper', pretty_print=pretty_print)
        if self.RequestMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RequestMethod>%s</RequestMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RequestMethod), input_name='RequestMethod')), eol_))
        if self.RequestProxy is not None:
            self.RequestProxy.export(outfile, level, namespaceprefix_, name_='RequestProxy', pretty_print=pretty_print)
        if self.SelectedLanguage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SelectedLanguage>%s</SelectedLanguage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SelectedLanguage), input_name='SelectedLanguage')), eol_))
        if self.Subject is not None:
            self.Subject.export(outfile, level, namespaceprefix_, name_='Subject', pretty_print=pretty_print)
        if self.TransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransactionId>%s</TransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionId), input_name='TransactionId')), eol_))
        for Type_ in self.Type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Type_), input_name='Type')), eol_))
        if self.VendorApplicationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VendorApplicationId>%s</VendorApplicationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VendorApplicationId), input_name='VendorApplicationId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdditionalInfo':
            obj_ = AdditionalInfo.factory()
            obj_.build(child_)
            self.AdditionalInfo.append(obj_)
            obj_.original_tagname_ = 'AdditionalInfo'
        elif nodeName_ == 'BallotRequest':
            class_obj_ = self.get_class_obj_(child_, BallotRequest)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.BallotRequest = obj_
            obj_.original_tagname_ = 'BallotRequest'
        elif nodeName_ == 'Form':
            Form_ = child_.text
            Form_ = self.gds_validate_string(Form_, node, 'Form')
            self.Form = Form_
            # validate type RequestForm
            self.validate_RequestForm(self.Form)
        elif nodeName_ == 'GeneratedDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.GeneratedDate = dval_
        elif nodeName_ == 'Issuer':
            Issuer_ = child_.text
            Issuer_ = self.gds_validate_string(Issuer_, node, 'Issuer')
            self.Issuer = Issuer_
        elif nodeName_ == 'OtherForm':
            OtherForm_ = child_.text
            OtherForm_ = self.gds_validate_string(OtherForm_, node, 'OtherForm')
            self.OtherForm = OtherForm_
        elif nodeName_ == 'OtherRequestMethod':
            OtherRequestMethod_ = child_.text
            OtherRequestMethod_ = self.gds_validate_string(OtherRequestMethod_, node, 'OtherRequestMethod')
            self.OtherRequestMethod = OtherRequestMethod_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'RequestHelper':
            obj_ = RequestHelper.factory()
            obj_.build(child_)
            self.RequestHelper.append(obj_)
            obj_.original_tagname_ = 'RequestHelper'
        elif nodeName_ == 'RequestMethod':
            RequestMethod_ = child_.text
            RequestMethod_ = self.gds_validate_string(RequestMethod_, node, 'RequestMethod')
            self.RequestMethod = RequestMethod_
            # validate type RequestMethod
            self.validate_RequestMethod(self.RequestMethod)
        elif nodeName_ == 'RequestProxy':
            obj_ = RequestProxy.factory()
            obj_.build(child_)
            self.RequestProxy = obj_
            obj_.original_tagname_ = 'RequestProxy'
        elif nodeName_ == 'SelectedLanguage':
            SelectedLanguage_ = child_.text
            SelectedLanguage_ = self.gds_validate_string(SelectedLanguage_, node, 'SelectedLanguage')
            self.SelectedLanguage = SelectedLanguage_
        elif nodeName_ == 'Subject':
            class_obj_ = self.get_class_obj_(child_, Voter)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Subject = obj_
            obj_.original_tagname_ = 'Subject'
        elif nodeName_ == 'TransactionId':
            TransactionId_ = child_.text
            TransactionId_ = self.gds_validate_string(TransactionId_, node, 'TransactionId')
            self.TransactionId = TransactionId_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
            # validate type VoterRequestType
            self.validate_VoterRequestType(self.Type[-1])
        elif nodeName_ == 'VendorApplicationId':
            VendorApplicationId_ = child_.text
            VendorApplicationId_ = self.gds_validate_string(VendorApplicationId_, node, 'VendorApplicationId')
            self.VendorApplicationId = VendorApplicationId_
# end class VoterRecordsRequest


class VoterRecordsResponse(GeneratedsSuper):
    """The root element for response messages. For defining items
    pertaining to the status of a response to a voter records
    request. <VoterRecordsResponse> is an abstract element with
    three xsi:types that get used according to the type of response:
    <VoterRecordsResponse xsi:type="RegistrationAcknowledgement">,
    used to indicate an acknowledgement only. 
    <VoterRecordsResponse xsi:type="RegistrationRejection">, used to
    indicate a failure and the type of failure. 
    <VoterRecordsResponse xsi:type="RegistrationSuccess">, used to
    indication that a successful registration action occurred and
    the type of registration action, which may differ from the type
    of registration action requested. <VoterRecordsResponse>
    optionally includes the <TransactionId> sub-element associated
    with the voter records request."""
    subclass = None
    superclass = None
    def __init__(self, TransactionId=None, extensiontype_=None):
        self.original_tagname_ = None
        self.TransactionId = TransactionId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecordsResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecordsResponse.subclass:
            return VoterRecordsResponse.subclass(*args_, **kwargs_)
        else:
            return VoterRecordsResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TransactionId(self): return self.TransactionId
    def set_TransactionId(self, TransactionId): self.TransactionId = TransactionId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.TransactionId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecordsResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecordsResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecordsResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecordsResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecordsResponse'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecordsResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransactionId>%s</TransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionId), input_name='TransactionId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TransactionId':
            TransactionId_ = child_.text
            TransactionId_ = self.gds_validate_string(TransactionId_, node, 'TransactionId')
            self.TransactionId = TransactionId_
# end class VoterRecordsResponse


class MailForwardingAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MailForwardingAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MailForwardingAddressType.subclass:
            return MailForwardingAddressType.subclass(*args_, **kwargs_)
        else:
            return MailForwardingAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='MailForwardingAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MailForwardingAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MailForwardingAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MailForwardingAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MailForwardingAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MailForwardingAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class MailForwardingAddressType


class AddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class AddressType


class AddressType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType1.subclass:
            return AddressType1.subclass(*args_, **kwargs_)
        else:
            return AddressType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AddressType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AddressType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType1'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AddressType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class AddressType1


class AddressType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType2.subclass:
            return AddressType2.subclass(*args_, **kwargs_)
        else:
            return AddressType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AddressType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AddressType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType2'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AddressType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class AddressType2


class MailingAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MailingAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MailingAddressType.subclass:
            return MailingAddressType.subclass(*args_, **kwargs_)
        else:
            return MailingAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='MailingAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MailingAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MailingAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MailingAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MailingAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MailingAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class MailingAddressType


class PreviousResidenceAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviousResidenceAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviousResidenceAddressType.subclass:
            return PreviousResidenceAddressType.subclass(*args_, **kwargs_)
        else:
            return PreviousResidenceAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='PreviousResidenceAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreviousResidenceAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviousResidenceAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PreviousResidenceAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreviousResidenceAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PreviousResidenceAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class PreviousResidenceAddressType


class ResidenceAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumberedThoroughfareAddress_type=None, USPSPostalDeliveryBox_type=None):
        self.original_tagname_ = None
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResidenceAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResidenceAddressType.subclass:
            return ResidenceAddressType.subclass(*args_, **kwargs_)
        else:
            return ResidenceAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress_type is not None or
            self.USPSPostalDeliveryBox_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ResidenceAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResidenceAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResidenceAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ResidenceAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResidenceAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ResidenceAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
# end class ResidenceAddressType


class VoterRecords(VoterRecordsResponse):
    """Used in responses. For indicating a successful response to a lookup
    request. A lookup for a single voter may result in multiple
    VoterRecords being returned. This can occur if the voter has
    duplicate records in the VRDB, or if the criteria specified in
    the lookup request was broad."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None, VoterRecord=None):
        self.original_tagname_ = None
        super(VoterRecords, self).__init__(TransactionId, )
        if VoterRecord is None:
            self.VoterRecord = []
        else:
            self.VoterRecord = VoterRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecords)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecords.subclass:
            return VoterRecords.subclass(*args_, **kwargs_)
        else:
            return VoterRecords(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VoterRecord(self): return self.VoterRecord
    def set_VoterRecord(self, VoterRecord): self.VoterRecord = VoterRecord
    def add_VoterRecord(self, value): self.VoterRecord.append(value)
    def insert_VoterRecord_at(self, index, value): self.VoterRecord.insert(index, value)
    def replace_VoterRecord_at(self, index, value): self.VoterRecord[index] = value
    def hasContent_(self):
        if (
            self.VoterRecord or
            super(VoterRecords, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecords', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecords')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecords')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecords', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecords'):
        super(VoterRecords, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecords')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecords', fromsubclass_=False, pretty_print=True):
        super(VoterRecords, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VoterRecord_ in self.VoterRecord:
            VoterRecord_.export(outfile, level, namespaceprefix_, name_='VoterRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VoterRecords, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VoterRecord':
            obj_ = VoterRecord.factory()
            obj_.build(child_)
            self.VoterRecord.append(obj_)
            obj_.original_tagname_ = 'VoterRecord'
        super(VoterRecords, self).buildChildren(child_, node, nodeName_, True)
# end class VoterRecords


class RequestSuccess(VoterRecordsResponse):
    """Used in responses. For indicating a successful response to a
    request. The Action attribute is used to indicate the action
    that occurred, which may differ from what was requested. For
    example, a request for a new voter registration may succeed, but
    if the voter was already registered, the response may indicate a
    registration update as opposed to a registration create. The
    response also includes, optionally, other information useful to
    the voter, including a description of the voter polling place,
    districts (i.e., contests) associated with the polling place, or
    other geopolitical geographies such as the voter precinct."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None, Action=None, District=None, EffectiveDate=None, ElectionAdministration=None, Locality=None, PollingPlace=None):
        self.original_tagname_ = None
        super(RequestSuccess, self).__init__(TransactionId, )
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        if District is None:
            self.District = []
        else:
            self.District = District
        if isinstance(EffectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EffectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EffectiveDate
        self.EffectiveDate = initvalue_
        self.ElectionAdministration = ElectionAdministration
        if Locality is None:
            self.Locality = []
        else:
            self.Locality = Locality
        self.PollingPlace = PollingPlace
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestSuccess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestSuccess.subclass:
            return RequestSuccess.subclass(*args_, **kwargs_)
        else:
            return RequestSuccess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action_at(self, index, value): self.Action.insert(index, value)
    def replace_Action_at(self, index, value): self.Action[index] = value
    def get_District(self): return self.District
    def set_District(self, District): self.District = District
    def add_District(self, value): self.District.append(value)
    def insert_District_at(self, index, value): self.District.insert(index, value)
    def replace_District_at(self, index, value): self.District[index] = value
    def get_EffectiveDate(self): return self.EffectiveDate
    def set_EffectiveDate(self, EffectiveDate): self.EffectiveDate = EffectiveDate
    def get_ElectionAdministration(self): return self.ElectionAdministration
    def set_ElectionAdministration(self, ElectionAdministration): self.ElectionAdministration = ElectionAdministration
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def add_Locality(self, value): self.Locality.append(value)
    def insert_Locality_at(self, index, value): self.Locality.insert(index, value)
    def replace_Locality_at(self, index, value): self.Locality[index] = value
    def get_PollingPlace(self): return self.PollingPlace
    def set_PollingPlace(self, PollingPlace): self.PollingPlace = PollingPlace
    def validate_SuccessAction(self, value):
        # Validate type SuccessAction, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['address-updated', 'name-updated', 'registration-cancelled', 'registration-created', 'registration-updated', 'status-updated', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SuccessAction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Action or
            self.District or
            self.EffectiveDate is not None or
            self.ElectionAdministration is not None or
            self.Locality or
            self.PollingPlace is not None or
            super(RequestSuccess, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestSuccess', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestSuccess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestSuccess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestSuccess', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestSuccess'):
        super(RequestSuccess, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestSuccess')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestSuccess', fromsubclass_=False, pretty_print=True):
        super(RequestSuccess, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_ in self.Action:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Action>%s</Action>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Action_), input_name='Action')), eol_))
        for District_ in self.District:
            District_.export(outfile, level, namespaceprefix_, name_='District', pretty_print=pretty_print)
        if self.EffectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EffectiveDate>%s</EffectiveDate>%s' % (self.gds_format_date(self.EffectiveDate, input_name='EffectiveDate'), eol_))
        if self.ElectionAdministration is not None:
            self.ElectionAdministration.export(outfile, level, namespaceprefix_, name_='ElectionAdministration', pretty_print=pretty_print)
        for Locality_ in self.Locality:
            Locality_.export(outfile, level, namespaceprefix_, name_='Locality', pretty_print=pretty_print)
        if self.PollingPlace is not None:
            self.PollingPlace.export(outfile, level, namespaceprefix_, name_='PollingPlace', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestSuccess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            Action_ = child_.text
            Action_ = self.gds_validate_string(Action_, node, 'Action')
            self.Action.append(Action_)
            # validate type SuccessAction
            self.validate_SuccessAction(self.Action[-1])
        elif nodeName_ == 'District':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.District.append(obj_)
            obj_.original_tagname_ = 'District'
        elif nodeName_ == 'EffectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EffectiveDate = dval_
        elif nodeName_ == 'ElectionAdministration':
            obj_ = ElectionAdministration.factory()
            obj_.build(child_)
            self.ElectionAdministration = obj_
            obj_.original_tagname_ = 'ElectionAdministration'
        elif nodeName_ == 'Locality':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.Locality.append(obj_)
            obj_.original_tagname_ = 'Locality'
        elif nodeName_ == 'PollingPlace':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.PollingPlace = obj_
            obj_.original_tagname_ = 'PollingPlace'
        super(RequestSuccess, self).buildChildren(child_, node, nodeName_, True)
# end class RequestSuccess


class RequestRejection(VoterRecordsResponse):
    """Used in responses. For indicating that the request failed. The Error
    attribute is used to indicate the type of error that occurred.
    The AdditionalDetails attribute can be used to provide more
    information as to the rejection."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None, AdditionalDetails=None, Error=None, OtherError=None):
        self.original_tagname_ = None
        super(RequestRejection, self).__init__(TransactionId, )
        if AdditionalDetails is None:
            self.AdditionalDetails = []
        else:
            self.AdditionalDetails = AdditionalDetails
        if Error is None:
            self.Error = []
        else:
            self.Error = Error
        if OtherError is None:
            self.OtherError = []
        else:
            self.OtherError = OtherError
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestRejection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestRejection.subclass:
            return RequestRejection.subclass(*args_, **kwargs_)
        else:
            return RequestRejection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdditionalDetails(self): return self.AdditionalDetails
    def set_AdditionalDetails(self, AdditionalDetails): self.AdditionalDetails = AdditionalDetails
    def add_AdditionalDetails(self, value): self.AdditionalDetails.append(value)
    def insert_AdditionalDetails_at(self, index, value): self.AdditionalDetails.insert(index, value)
    def replace_AdditionalDetails_at(self, index, value): self.AdditionalDetails[index] = value
    def get_Error(self): return self.Error
    def set_Error(self, Error): self.Error = Error
    def add_Error(self, value): self.Error.append(value)
    def insert_Error_at(self, index, value): self.Error.insert(index, value)
    def replace_Error_at(self, index, value): self.Error[index] = value
    def get_OtherError(self): return self.OtherError
    def set_OtherError(self, OtherError): self.OtherError = OtherError
    def add_OtherError(self, value): self.OtherError.append(value)
    def insert_OtherError_at(self, index, value): self.OtherError.insert(index, value)
    def replace_OtherError_at(self, index, value): self.OtherError[index] = value
    def validate_RequestError(self, value):
        # Validate type RequestError, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['identity-lookup-failed', 'incomplete', 'incomplete-address', 'incomplete-birth-date', 'incomplete-name', 'incomplete-signature', 'ineligible', 'invalid-form', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestError' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AdditionalDetails or
            self.Error or
            self.OtherError or
            super(RequestRejection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestRejection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestRejection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestRejection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestRejection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestRejection'):
        super(RequestRejection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestRejection')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestRejection', fromsubclass_=False, pretty_print=True):
        super(RequestRejection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AdditionalDetails_ in self.AdditionalDetails:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AdditionalDetails>%s</AdditionalDetails>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AdditionalDetails_), input_name='AdditionalDetails')), eol_))
        for Error_ in self.Error:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Error>%s</Error>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Error_), input_name='Error')), eol_))
        for OtherError_ in self.OtherError:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherError>%s</OtherError>%s' % (self.gds_encode(self.gds_format_string(quote_xml(OtherError_), input_name='OtherError')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestRejection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdditionalDetails':
            AdditionalDetails_ = child_.text
            AdditionalDetails_ = self.gds_validate_string(AdditionalDetails_, node, 'AdditionalDetails')
            self.AdditionalDetails.append(AdditionalDetails_)
        elif nodeName_ == 'Error':
            Error_ = child_.text
            Error_ = self.gds_validate_string(Error_, node, 'Error')
            self.Error.append(Error_)
            # validate type RequestError
            self.validate_RequestError(self.Error[-1])
        elif nodeName_ == 'OtherError':
            OtherError_ = child_.text
            OtherError_ = self.gds_validate_string(OtherError_, node, 'OtherError')
            self.OtherError.append(OtherError_)
        super(RequestRejection, self).buildChildren(child_, node, nodeName_, True)
# end class RequestRejection


class RequestAcknowledgement(VoterRecordsResponse):
    """<p> <a
    href="mdel://_18_5_3_43701b0_1520354792154_717315_5628">Voter</a
    > optionally includes this element to specify information about
    a request helper, i.e., a request assistant or witness involved
    in a voter&rsquo;s request. </p> <p> &#160; </p> <p>
    RequestAssistant includes the <a
    href="mdel://_18_0_2_6340208_1446583854986_538708_5957">Name</a>
    element to specify the registration helper&rsquo;s name and
    optionally includes the <a href="mdel://_18_0_2_6340208_14527880
    35217_489009_4409">Signature</a> element if a registration
    helper&rsquo;s signature is required. </p>"""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None):
        self.original_tagname_ = None
        super(RequestAcknowledgement, self).__init__(TransactionId, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestAcknowledgement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestAcknowledgement.subclass:
            return RequestAcknowledgement.subclass(*args_, **kwargs_)
        else:
            return RequestAcknowledgement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RequestAcknowledgement, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestAcknowledgement', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestAcknowledgement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestAcknowledgement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestAcknowledgement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestAcknowledgement'):
        super(RequestAcknowledgement, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestAcknowledgement')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestAcknowledgement', fromsubclass_=False, pretty_print=True):
        super(RequestAcknowledgement, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestAcknowledgement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RequestAcknowledgement, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RequestAcknowledgement


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from vricore import *\n\n')
        sys.stdout.write('import vricore as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdditionalInfo",
    "AddressType",
    "AddressType1",
    "AddressType2",
    "BallotRequest",
    "BallotStyle",
    "ContactMethod",
    "Election",
    "ElectionAdministration",
    "ElectionBasedBallotRequest",
    "ExternalIdentifier",
    "File",
    "Image",
    "LatLng",
    "Location",
    "MailForwardingAddressType",
    "MailingAddressType",
    "Name",
    "NumberedThoroughfareAddress_type",
    "Party",
    "PermanentBallotRequest",
    "PhoneContactMethod",
    "PreviousResidenceAddressType",
    "ReportingUnit",
    "RequestAcknowledgement",
    "RequestHelper",
    "RequestProxy",
    "RequestRejection",
    "RequestSuccess",
    "ResidenceAddressType",
    "Signature",
    "TemporalBallotRequest",
    "USPSPostalDeliveryBox_type",
    "Voter",
    "VoterClassification",
    "VoterId",
    "VoterParticipation",
    "VoterRecord",
    "VoterRecords",
    "VoterRecordsRequest",
    "VoterRecordsResponse"
]

