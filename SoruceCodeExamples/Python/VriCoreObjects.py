#!/usr/bin/env python
# -*- coding: utf-8 -*-

#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Action_type(object):
    ADD='ADD'
    DELETE='DELETE'


class AddressClassification_type(object):
    NUMBERED_THOROUGHFARE_ADDRESS='NumberedThoroughfareAddress'
    INTERSECTION_ADDRESS='IntersectionAddress'
    TWO_NUMBER_ADDRESS_RANGE='TwoNumberAddressRange'
    FOUR_NUMBER_ADDRESS_RANGE='FourNumberAddressRange'
    UNNUMBERED_THOROUGHFARE_ADDRESS='UnnumberedThoroughfareAddress'
    LANDMARK_ADDRESS='LandmarkAddress'
    COMMUNITY_ADDRESS='CommunityAddress'
    USPS_POSTAL_DELIVERY_BOX='USPSPostalDeliveryBox'
    USPS_POSTAL_DELIVERY_ROUTE='USPSPostal DeliveryRoute'
    USPS_GENERAL_DELIVERY_OFFICE='USPSGeneral DeliveryOffice'
    GENERAL_ADDRESS_CLASS='GeneralAddressClass'


class AddressLifecycleStatus_type(object):
    POTENTIAL='Potential'
    PROPOSED='Proposed'
    ACTIVE='Active'
    RETIRED='Retired'


class AddressLifecycle_type(object):
    PROPOSED='PROPOSED'
    ACTIVE='ACTIVE'
    RETIRED='RETIRED'
    TEMPORARY='TEMPORARY'


class AddressNumberBounds_type(object):
    LOW='Low'
    HIGH='High'
    UNKNOWN='Unknown'


class AddressNumberParity_type(object):
    EVEN='Even'
    ODD='Odd'


class AddressNumberSide_type(object):
    LEFT='Left'
    RIGHT='Right'
    UNKNOWN='Unknown'


class AddressOfficialStatus_type(object):
    OFFICIAL='Official'
    ALTERNATE_NAME='Alternate Name'
    ALTERNATE_RENAMED='Alternate Renamed'
    ALTERNATE_AUTHORITY_NAME='Alternate Authority Name'
    ALTERNATE_COLLOQUIAL_NAME='Alternate Colloquial Name'
    UNOFFICAL_ALTERNATE_NAME='Unoffical Alternate Name'
    UNOFFICIAL_AGENCYS_NAME='Unofficial Agencys Name'
    POSTED_ADDRESS='Posted Address'
    VERIFIED_INVALID='Verified Invalid'


class AddressRangeDirectionality_type(object):
    WITH='With'
    AGAINST='Against'
    WITH_AGAINST='With-Against'
    AGAINST_WITH='Against-With'
    NULL='Null'
    NA='NA'
    UNKNOWN='Unknown'


class AddressRangeParity_type(object):
    EVEN='even'
    ODD='odd'
    BOTH='both'
    NONE='none'
    UNKNOWN='unknown'


class AddressRangeSide_type(object):
    RIGHT='right'
    LEFT='left'
    BOTH='both'
    NONE='none'
    UNKNOWN='unknown'


class AddressRangeSpan_type(object):
    PARTIAL_SEGMENT='Partial Segment'
    SINGLE_SEGMENT='Single Segment'
    MULTI_SEGMENT='Multi Segment'
    ENTIRE_STREET='Entire Street'
    UNKNOWN='Unknown'


class AddressRangeType_type(object):
    ACTUAL='Actual'
    POTENTIAL='Potential'
    UNKNOWN='Unknown'


class AddressReferenceSystemType_type(object):
    AXIAL='Axial'
    GRID='Grid'
    RADIAL='Radial'
    LINEAR_NON_AXIAL='Linear Non-Axial'
    DISTANCE='Distance'
    AREA_BASED='Area Based'


class AddressSideOfStreet_type(object):
    RIGHT='right'
    LEFT='left'
    BOTH='both'
    NONE='none'
    UNKNOWN='unknown'


class AssertionValue(object):
    NO='no'
    YES='yes'
    UNKNOWN='unknown'
    OTHER='other'


class AttachedElement_type(object):
    ATTACHED='Attached'
    NOT_ATTACHED='Not Attached'
    UNKNOWN='Unknown'


class BallotReceiptMethod(object):
    EMAIL='email'
    EMAILORONLINE='email-or-online'
    FAX='fax'
    MAIL='mail'
    ONLINE='online'


class ContactMethodType(object):
    EMAIL='email'
    PHONE='phone'
    OTHER='other'


class DeliveryAddressType_type(object):
    SUB_ADDRESS_INCLUDED='SubAddress Included'
    SUB_ADDRES_EXCLUDED='SubAddres Excluded'
    UNSTATED='Unstated'


class IdentifierType(object):
    FIPS='fips'
    LOCALLEVEL='local-level'
    NATIONALLEVEL='national-level'
    OCDID='ocd-id'
    STATELEVEL='state-level'
    OTHER='other'


class MailableAddress_type(object):
    YES='Yes'
    NO='No'
    UNKNOWN='Unknown'


class OfficialStatus_type(object):
    OFFICIAL='Official'
    ALTERNATEOR_ALIAS='Alternate or Alias'
    OFFICIAL_ALTERNATEOR_ALIAS='Official Alternate or Alias'
    OFFICIAL_RENAMING_ACTIONOFTHE_ADDRESS_AUTHORITY='Official Renaming Action of the Address Authority'
    ALTERNATES_ESTABLISHEDBYAN_ADDRESS_AUTHORITY='Alternates Established by an Address Authority'
    UNOFFICIAL_ALTERNATEOR_ALIAS='Unofficial Alternate or Alias'
    ALTERNATE_NAMES_ESTABLISHEDBY_COLLOQUIAL_USEINA_COMMUNITY='Alternate Names Established by Colloquial Use in a Community'
    UNOFFICIAL_ALTERNATE_NAMES_FREQUENTLY_ENCOUNTERED='Unofficial Alternate Names Frequently Encountered'
    UNOFFICIAL_ALTERNATE_NAMES_IN_USEBYAN_AGENCYOR_ENTITY='Unofficial Alternate Names In Use by an Agency or Entity'
    POSTEDOR_VANITY_ADDRESS='Posted or Vanity Address'
    VERIFIED_INVALID='Verified Invalid'


class PhoneCapability(object):
    FAX='fax'
    MMS='mms'
    SMS='sms'
    VOICE='voice'


class PlaceNameType_type(object):
    USPS_COMMUNITY='USPSCommunity'
    MUNICIPAL_JURISDICTION='MunicipalJurisdiction'
    COUNTY='County'


class ReportingUnitType(object):
    BALLOTBATCH='ballot-batch'
    BALLOTSTYLEAREA='ballot-style-area'
    BOROUGH='borough'
    CITY='city'
    CITYCOUNCIL='city-council'
    COMBINEDPRECINCT='combined-precinct'
    CONGRESSIONAL='congressional'
    COUNTY='county'
    COUNTYCOUNCIL='county-council'
    DROPBOX='drop-box'
    JUDICIAL='judicial'
    MUNICIPALITY='municipality'
    POLLINGPLACE='polling-place'
    PRECINCT='precinct'
    SCHOOL='school'
    SPECIAL='special'
    SPLITPRECINCT='split-precinct'
    STATE='state'
    STATEHOUSE='state-house'
    STATESENATE='state-senate'
    TOWN='town'
    TOWNSHIP='township'
    UTILITY='utility'
    VILLAGE='village'
    VOTECENTER='vote-center'
    WARD='ward'
    WATER='water'
    OTHER='other'


class RequestError(object):
    IDENTITYLOOKUPFAILED='identity-lookup-failed'
    INCOMPLETE='incomplete'
    INELIGIBLE='ineligible'
    INVALIDFORM='invalid-form'
    OTHER='other'


class RequestForm(object):
    FPCA='fpca'
    NVRA='nvra'
    OTHER='other'


class RequestMethod(object):
    ARMEDFORCESRECRUITMENTOFFICE='armed-forces-recruitment-office'
    MOTORVEHICLEOFFICE='motor-vehicle-office'
    OTHERAGENCYDESIGNATEDBYSTATE='other-agency-designated-by-state'
    PUBLICASSISTANCEOFFICE='public-assistance-office'
    REGISTRATIONDRIVEFROMADVOCACYGROUPORPOLITICALPARTY='registration-drive-from-advocacy-group-or-political-party'
    STATEFUNDEDAGENCYSERVINGPERSONSWITHDISABILITIES='state-funded-agency-serving-persons-with-disabilities'
    VOTERVIAELECTIONREGISTRARSOFFICE='voter-via-election-registrars-office'
    VOTERVIAEMAIL='voter-via-email'
    VOTERVIAFAX='voter-via-fax'
    VOTERVIAINTERNET='voter-via-internet'
    VOTERVIAMAIL='voter-via-mail'
    UNKNOWN='unknown'
    OTHER='other'


class RequestProxyType(object):
    ARMEDFORCESRECRUITMENTOFFICE='armed-forces-recruitment-office'
    MOTORVEHICLEOFFICE='motor-vehicle-office'
    OTHERAGENCYDESIGNATEDBYSTATE='other-agency-designated-by-state'
    PUBLICASSISTANCEOFFICE='public-assistance-office'
    REGISTRATIONDRIVEFROMADVOCACYGROUPORPOLITICALPARTY='registration-drive-from-advocacy-group-or-political-party'
    STATEFUNDEDAGENCYSERVINGPERSONSWITHDISABILITIES='state-funded-agency-serving-persons-with-disabilities'
    OTHER='other'


class SignatureSource(object):
    DMV='dmv'
    LOCAL='local'
    STATE='state'
    VOTER='voter'
    OTHER='other'


class SignatureType(object):
    DYNAMIC='dynamic'
    ELECTRONIC='electronic'
    OTHER='other'


class SubaddressComponentOrder_type(object):
    _1='1'
    _2='2'
    _3='3'


class SuccessAction(object):
    ADDRESSUPDATED='address-updated'
    NAMEUPDATED='name-updated'
    REGISTRATIONCANCELLED='registration-cancelled'
    REGISTRATIONCREATED='registration-created'
    REGISTRATIONUPDATED='registration-updated'
    STATUSUPDATED='status-updated'
    OTHER='other'


class VoterClassificationType(object):
    ACTIVATEDNATIONALGUARD='activated-national-guard'
    ACTIVEDUTY='active-duty'
    ACTIVEDUTYSPOUSEORDEPENDENT='active-duty-spouse-or-dependent'
    CITIZENABROADINTENTTORETURN='citizen-abroad-intent-to-return'
    CITIZENABROADRETURNUNCERTAIN='citizen-abroad-return-uncertain'
    CITIZENABROADNEVERRESIDED='citizen-abroad-never-resided'
    DECEASED='deceased'
    DECLAREDINCOMPETENT='declared-incompetent'
    EIGHTEENONELECTIONDAY='eighteen-on-election-day'
    FELON='felon'
    PERMANENTLYDENIED='permanently-denied'
    PROTECTEDVOTER='protected-voter'
    RESTOREDFELON='restored-felon'
    UNITEDSTATESCITIZEN='united-states-citizen'
    OTHER='other'


class VoterHelperType(object):
    ASSISTANT='assistant'
    WITNESS='witness'


class VoterIdType(object):
    DRIVERSLICENSE='drivers-license'
    LOCALVOTERREGISTRATIONID='local-voter-registration-id'
    SSN='ssn'
    SSN_4='ssn4'
    STATEID='state-id'
    STATEVOTERREGISTRATIONID='state-voter-registration-id'
    UNSPECIFIEDDOCUMENT='unspecified-document'
    UNSPECIFIEDDOCUMENTWITHNAMEANDADDRESS='unspecified-document-with-name-and-address'
    UNSPECIFIEDDOCUMENTWITHPHOTOIDENTIFICATION='unspecified-document-with-photo-identification'
    UNKNOWN='unknown'
    OTHER='other'


class VoterRequestType(object):
    BALLOTREQUEST='ballot-request'
    LOOKUP='lookup'
    REGISTRATION='registration'
    OTHER='other'


class VoterStatus(object):
    ACTIVE='active'
    INACTIVE='inactive'
    OTHER='other'


class version_type(object):
    _0_4='0.4'


class AdditionalInfo(GeneratedsSuper):
    """Class for specifying information not addressed in this model by
    other attributes, e.g. state-specific information that does not
    "fit" in any other attribute. The information will thus be
    highly specific to the generating application, and consuming
    applications must "know" the meaning of the information to make
    use of it. For this reason, use of this class is discouraged as
    much as is possible. The StringValue and FileValue attributes
    are both optional, however exactly one of them must be included."""
    subclass = None
    superclass = None
    def __init__(self, FileValue=None, Name=None, StringValue=None):
        self.original_tagname_ = None
        self.FileValue = FileValue
        self.Name = Name
        self.StringValue = StringValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdditionalInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdditionalInfo.subclass:
            return AdditionalInfo.subclass(*args_, **kwargs_)
        else:
            return AdditionalInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FileValue(self): return self.FileValue
    def set_FileValue(self, FileValue): self.FileValue = FileValue
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_StringValue(self): return self.StringValue
    def set_StringValue(self, StringValue): self.StringValue = StringValue
    def hasContent_(self):
        if (
            self.FileValue is not None or
            self.Name is not None or
            self.StringValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AdditionalInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdditionalInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdditionalInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AdditionalInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdditionalInfo'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AdditionalInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FileValue is not None:
            self.FileValue.export(outfile, level, namespaceprefix_, name_='FileValue', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.StringValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StringValue>%s</StringValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StringValue), input_name='StringValue')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FileValue':
            class_obj_ = self.get_class_obj_(child_, File)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FileValue = obj_
            obj_.original_tagname_ = 'FileValue'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'StringValue':
            StringValue_ = child_.text
            StringValue_ = self.gds_validate_string(StringValue_, node, 'StringValue')
            self.StringValue = StringValue_
# end class AdditionalInfo


class BallotRequest(GeneratedsSuper):
    """An abstract class representing a request for a ballot. Classes for
    specific types of BallotRequest inherit the attributes and
    define their own."""
    subclass = None
    superclass = None
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None, extensiontype_=None):
        self.original_tagname_ = None
        if BallotReceiptPreference is None:
            self.BallotReceiptPreference = []
        else:
            self.BallotReceiptPreference = BallotReceiptPreference
        self.MailForwardingAddress = MailForwardingAddress
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BallotRequest.subclass:
            return BallotRequest.subclass(*args_, **kwargs_)
        else:
            return BallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BallotReceiptPreference(self): return self.BallotReceiptPreference
    def set_BallotReceiptPreference(self, BallotReceiptPreference): self.BallotReceiptPreference = BallotReceiptPreference
    def add_BallotReceiptPreference(self, value): self.BallotReceiptPreference.append(value)
    def insert_BallotReceiptPreference_at(self, index, value): self.BallotReceiptPreference.insert(index, value)
    def replace_BallotReceiptPreference_at(self, index, value): self.BallotReceiptPreference[index] = value
    def get_MailForwardingAddress(self): return self.MailForwardingAddress
    def set_MailForwardingAddress(self, MailForwardingAddress): self.MailForwardingAddress = MailForwardingAddress
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_BallotReceiptMethod(self, value):
        # Validate type BallotReceiptMethod, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['email', 'email-or-online', 'fax', 'mail', 'online']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on BallotReceiptMethod' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.BallotReceiptPreference or
            self.MailForwardingAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BallotRequest'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BallotRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BallotReceiptPreference_ in self.BallotReceiptPreference:
            showIndent(outfile, level, pretty_print)
            outfile.write('<BallotReceiptPreference>%s</BallotReceiptPreference>%s' % (self.gds_encode(self.gds_format_string(quote_xml(BallotReceiptPreference_), input_name='BallotReceiptPreference')), eol_))
        if self.MailForwardingAddress is not None:
            self.MailForwardingAddress.export(outfile, level, namespaceprefix_, name_='MailForwardingAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BallotReceiptPreference':
            BallotReceiptPreference_ = child_.text
            BallotReceiptPreference_ = self.gds_validate_string(BallotReceiptPreference_, node, 'BallotReceiptPreference')
            self.BallotReceiptPreference.append(BallotReceiptPreference_)
            # validate type BallotReceiptMethod
            self.validate_BallotReceiptMethod(self.BallotReceiptPreference[-1])
        elif nodeName_ == 'MailForwardingAddress':
            obj_ = MailForwardingAddressType.factory()
            obj_.build(child_)
            self.MailForwardingAddress = obj_
            obj_.original_tagname_ = 'MailForwardingAddress'
# end class BallotRequest


class BallotStyle(GeneratedsSuper):
    """For referencing a ballot style defined elsewhere, such as in an
    Election Management System (EMS)."""
    subclass = None
    superclass = None
    def __init__(self, ExternalIdentifier=None, ImageUri=None, Party=None):
        self.original_tagname_ = None
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        if ImageUri is None:
            self.ImageUri = []
        else:
            self.ImageUri = ImageUri
        if Party is None:
            self.Party = []
        else:
            self.Party = Party
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BallotStyle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BallotStyle.subclass:
            return BallotStyle.subclass(*args_, **kwargs_)
        else:
            return BallotStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_ImageUri(self): return self.ImageUri
    def set_ImageUri(self, ImageUri): self.ImageUri = ImageUri
    def add_ImageUri(self, value): self.ImageUri.append(value)
    def insert_ImageUri_at(self, index, value): self.ImageUri.insert(index, value)
    def replace_ImageUri_at(self, index, value): self.ImageUri[index] = value
    def get_Party(self): return self.Party
    def set_Party(self, Party): self.Party = Party
    def add_Party(self, value): self.Party.append(value)
    def insert_Party_at(self, index, value): self.Party.insert(index, value)
    def replace_Party_at(self, index, value): self.Party[index] = value
    def hasContent_(self):
        if (
            self.ExternalIdentifier or
            self.ImageUri or
            self.Party
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BallotStyle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BallotStyle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BallotStyle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BallotStyle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BallotStyle'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BallotStyle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        for ImageUri_ in self.ImageUri:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ImageUri>%s</ImageUri>%s' % (self.gds_encode(self.gds_format_string(quote_xml(ImageUri_), input_name='ImageUri')), eol_))
        for Party_ in self.Party:
            Party_.export(outfile, level, namespaceprefix_, name_='Party', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'ImageUri':
            ImageUri_ = child_.text
            ImageUri_ = self.gds_validate_string(ImageUri_, node, 'ImageUri')
            self.ImageUri.append(ImageUri_)
        elif nodeName_ == 'Party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Party.append(obj_)
            obj_.original_tagname_ = 'Party'
# end class BallotStyle


class ContactMethod(GeneratedsSuper):
    """Used in request and response messages. ElectionAdministration
    optionally includes this class to specify how to contact the
    election administration. Voter optionally includes this class to
    specify the method for contacting a voter regarding the voter's
    request. If the voter can be contacted in multiple ways, the
    application creating the data should order the occurrences of
    ContactMethod by priority. The PhoneContactMethod class uses
    ContactMethod as a base class, and should be used with when the
    contact method is for a telephone and it is necessary to
    describe the capabilities of the telephone. The Capability
    attribute is provided by the PhoneContactMethod class."""
    subclass = None
    superclass = None
    def __init__(self, OtherType=None, Type=None, Value=None, extensiontype_=None):
        self.original_tagname_ = None
        self.OtherType = OtherType
        self.Type = Type
        self.validate_ContactMethodType(self.Type)
        self.Value = Value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContactMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContactMethod.subclass:
            return ContactMethod.subclass(*args_, **kwargs_)
        else:
            return ContactMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ContactMethodType(self, value):
        # Validate type ContactMethodType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['email', 'phone', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ContactMethodType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OtherType is not None or
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ContactMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ContactMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ContactMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ContactMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ContactMethod'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ContactMethod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Value>%s</Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type ContactMethodType
            self.validate_ContactMethodType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ContactMethod


class Election(GeneratedsSuper):
    """Used in request and response messages. Describes an election event.
    Only the date of the election is required. Other attributes may
    be used to describe the election for which a ballot is requested
    or a voter participated."""
    subclass = None
    superclass = None
    def __init__(self, EndDate=None, ExternalIdentifier=None, Name=None, StartDate=None):
        self.original_tagname_ = None
        if isinstance(EndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EndDate
        self.EndDate = initvalue_
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        self.Name = Name
        if isinstance(StartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = StartDate
        self.StartDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Election)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Election.subclass:
            return Election.subclass(*args_, **kwargs_)
        else:
            return Election(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def hasContent_(self):
        if (
            self.EndDate is not None or
            self.ExternalIdentifier or
            self.Name is not None or
            self.StartDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Election', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Election')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Election')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Election', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Election'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Election', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EndDate>%s</EndDate>%s' % (self.gds_format_date(self.EndDate, input_name='EndDate'), eol_))
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.StartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StartDate>%s</StartDate>%s' % (self.gds_format_date(self.StartDate, input_name='StartDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EndDate = dval_
        elif nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'StartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.StartDate = dval_
# end class Election


class ElectionAdministration(GeneratedsSuper):
    """Used in response messages. ElectionAdministration optionally
    includes ContactMethod to specify contact information for the
    election authority."""
    subclass = None
    superclass = None
    def __init__(self, ContactMethod=None, Location=None, Name=None, Uri=None):
        self.original_tagname_ = None
        if ContactMethod is None:
            self.ContactMethod = []
        else:
            self.ContactMethod = ContactMethod
        self.Location = Location
        self.Name = Name
        if Uri is None:
            self.Uri = []
        else:
            self.Uri = Uri
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectionAdministration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectionAdministration.subclass:
            return ElectionAdministration.subclass(*args_, **kwargs_)
        else:
            return ElectionAdministration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactMethod(self): return self.ContactMethod
    def set_ContactMethod(self, ContactMethod): self.ContactMethod = ContactMethod
    def add_ContactMethod(self, value): self.ContactMethod.append(value)
    def insert_ContactMethod_at(self, index, value): self.ContactMethod.insert(index, value)
    def replace_ContactMethod_at(self, index, value): self.ContactMethod[index] = value
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Uri(self): return self.Uri
    def set_Uri(self, Uri): self.Uri = Uri
    def add_Uri(self, value): self.Uri.append(value)
    def insert_Uri_at(self, index, value): self.Uri.insert(index, value)
    def replace_Uri_at(self, index, value): self.Uri[index] = value
    def hasContent_(self):
        if (
            self.ContactMethod or
            self.Location is not None or
            self.Name is not None or
            self.Uri
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ElectionAdministration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectionAdministration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectionAdministration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ElectionAdministration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectionAdministration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ElectionAdministration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContactMethod_ in self.ContactMethod:
            ContactMethod_.export(outfile, level, namespaceprefix_, name_='ContactMethod', pretty_print=pretty_print)
        if self.Location is not None:
            self.Location.export(outfile, level, namespaceprefix_, name_='Location', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        for Uri_ in self.Uri:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Uri>%s</Uri>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Uri_), input_name='Uri')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactMethod':
            class_obj_ = self.get_class_obj_(child_, ContactMethod)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ContactMethod.append(obj_)
            obj_.original_tagname_ = 'ContactMethod'
        elif nodeName_ == 'Location':
            obj_ = Location.factory()
            obj_.build(child_)
            self.Location = obj_
            obj_.original_tagname_ = 'Location'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Uri':
            Uri_ = child_.text
            Uri_ = self.gds_validate_string(Uri_, node, 'Uri')
            self.Uri.append(Uri_)
# end class ElectionAdministration


class ElectionBasedBallotRequest(BallotRequest):
    """Used in request messages. Implementation of BallotRequest in which a
    ballot for a single election event is requested."""
    subclass = None
    superclass = BallotRequest
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None, Election=None):
        self.original_tagname_ = None
        super(ElectionBasedBallotRequest, self).__init__(BallotReceiptPreference, MailForwardingAddress, )
        self.Election = Election
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectionBasedBallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectionBasedBallotRequest.subclass:
            return ElectionBasedBallotRequest.subclass(*args_, **kwargs_)
        else:
            return ElectionBasedBallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Election(self): return self.Election
    def set_Election(self, Election): self.Election = Election
    def hasContent_(self):
        if (
            self.Election is not None or
            super(ElectionBasedBallotRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ElectionBasedBallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectionBasedBallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectionBasedBallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ElectionBasedBallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ElectionBasedBallotRequest'):
        super(ElectionBasedBallotRequest, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectionBasedBallotRequest')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ElectionBasedBallotRequest', fromsubclass_=False, pretty_print=True):
        super(ElectionBasedBallotRequest, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Election is not None:
            self.Election.export(outfile, level, namespaceprefix_, name_='Election', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectionBasedBallotRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Election':
            obj_ = Election.factory()
            obj_.build(child_)
            self.Election = obj_
            obj_.original_tagname_ = 'Election'
        super(ElectionBasedBallotRequest, self).buildChildren(child_, node, nodeName_, True)
# end class ElectionBasedBallotRequest


class Error(GeneratedsSuper):
    """Used in response messages. RequestRejection includes this class to
    describe the errors that caused the rejection."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, OtherError=None, Ref=None):
        self.original_tagname_ = None
        self.Name = Name
        self.validate_RequestError(self.Name)
        self.OtherError = OtherError
        self.Ref = Ref
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Error)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Error.subclass:
            return Error.subclass(*args_, **kwargs_)
        else:
            return Error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherError(self): return self.OtherError
    def set_OtherError(self, OtherError): self.OtherError = OtherError
    def get_Ref(self): return self.Ref
    def set_Ref(self, Ref): self.Ref = Ref
    def validate_RequestError(self, value):
        # Validate type RequestError, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['identity-lookup-failed', 'incomplete', 'ineligible', 'invalid-form', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestError' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Name is not None or
            self.OtherError is not None or
            self.Ref is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Error', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Error')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Error')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Error', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Error'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Error', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.OtherError is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherError>%s</OtherError>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherError), input_name='OtherError')), eol_))
        if self.Ref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Ref>%s</Ref>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Ref), input_name='Ref')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
            # validate type RequestError
            self.validate_RequestError(self.Name)
        elif nodeName_ == 'OtherError':
            OtherError_ = child_.text
            OtherError_ = self.gds_validate_string(OtherError_, node, 'OtherError')
            self.OtherError = OtherError_
        elif nodeName_ == 'Ref':
            Ref_ = child_.text
            Ref_ = self.gds_validate_string(Ref_, node, 'Ref')
            self.Ref = Ref_
# end class Error


class ExternalIdentifier(GeneratedsSuper):
    """Used in request and response messages. BallotStyle, Election, Party
    and ReportingUnit optionally include this class for associating
    a jurisdiction's codes, i.e., identifiers, with political
    parties or geopolitical units such as counties, towns,
    precincts, etc. Multiple occurrences of ExternalIdentifier can
    be used to associate multiple codes, e.g., if there is a desire
    to associate multiple codes with an object such as state-
    specific codes as well as OCD-IDs (Open Civic Data Identifiers)."""
    subclass = None
    superclass = None
    def __init__(self, OtherType=None, Type=None, Value=None):
        self.original_tagname_ = None
        self.OtherType = OtherType
        self.Type = Type
        self.validate_IdentifierType(self.Type)
        self.Value = Value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalIdentifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalIdentifier.subclass:
            return ExternalIdentifier.subclass(*args_, **kwargs_)
        else:
            return ExternalIdentifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def validate_IdentifierType(self, value):
        # Validate type IdentifierType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fips', 'local-level', 'national-level', 'ocd-id', 'state-level', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on IdentifierType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.OtherType is not None or
            self.Type is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ExternalIdentifier', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalIdentifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalIdentifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ExternalIdentifier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExternalIdentifier'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ExternalIdentifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Value>%s</Value>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Value), input_name='Value')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type IdentifierType
            self.validate_IdentifierType(self.Type)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class ExternalIdentifier


class File(GeneratedsSuper):
    """Used in request messages. VoterId optionally uses this class for
    FileValue to specify a filename for voter identification
    purposes such as for a utility bill. AdditionalInfo also
    optionally includes FileValue. File extends the xsd:base64Binary
    type to add the attributes for filename and (Multi-Purpose
    Internet Mail Extensions) MIME type, e.g., application/pdf for a
    file of type PDF. The Image element uses this class as an
    supertype, thus Image can be used when the type of file is for
    an image, e.g., image/png.The filename.The MIME type associated
    with the file."""
    subclass = None
    superclass = None
    def __init__(self, FileName=None, MimeType=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.FileName = _cast(None, FileName)
        self.MimeType = _cast(None, MimeType)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, File)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if File.subclass:
            return File.subclass(*args_, **kwargs_)
        else:
            return File(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FileName(self): return self.FileName
    def set_FileName(self, FileName): self.FileName = FileName
    def get_MimeType(self): return self.MimeType
    def set_MimeType(self, MimeType): self.MimeType = MimeType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='File', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('File')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='File')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='File', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='File'):
        if self.FileName is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            outfile.write(' FileName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.FileName), input_name='FileName')), ))
        if self.MimeType is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            outfile.write(' MimeType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.MimeType), input_name='MimeType')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='File', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FileName', node)
        if value is not None and 'FileName' not in already_processed:
            already_processed.add('FileName')
            self.FileName = value
        value = find_attr_value_('MimeType', node)
        if value is not None and 'MimeType' not in already_processed:
            already_processed.add('MimeType')
            self.MimeType = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File


class Image(File):
    """Used in request messages. Signature optionally includes this class
    to indicate that a file contains an image of a voter's
    signature. Image uses File as supertype, thus attributes of File
    can be included in Image."""
    subclass = None
    superclass = File
    def __init__(self, FileName=None, MimeType=None):
        self.original_tagname_ = None
        super(Image, self).__init__(FileName, MimeType, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Image)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Image, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Image', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Image', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Image'):
        super(Image, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Image')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Image', fromsubclass_=False, pretty_print=True):
        super(Image, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Image, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Image, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Image


class LatLng(GeneratedsSuper):
    """Used in response messages. Location optionally includes this element
    to specify the latitude and longitude of a voter's voting
    location."""
    subclass = None
    superclass = None
    def __init__(self, Latitude=None, Longitude=None, Source=None):
        self.original_tagname_ = None
        self.Latitude = Latitude
        self.Longitude = Longitude
        self.Source = Source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LatLng)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LatLng.subclass:
            return LatLng.subclass(*args_, **kwargs_)
        else:
            return LatLng(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def hasContent_(self):
        if (
            self.Latitude is not None or
            self.Longitude is not None or
            self.Source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='LatLng', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LatLng')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LatLng')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='LatLng', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LatLng'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='LatLng', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Latitude>%s</Latitude>%s' % (self.gds_format_float(self.Latitude, input_name='Latitude'), eol_))
        if self.Longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Longitude>%s</Longitude>%s' % (self.gds_format_float(self.Longitude, input_name='Longitude'), eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Source>%s</Source>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Source), input_name='Source')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Latitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Latitude')
            self.Latitude = fval_
        elif nodeName_ == 'Longitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Longitude')
            self.Longitude = fval_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
# end class LatLng


class Location(GeneratedsSuper):
    """Used in response messages. ReportingUnit and ElectionAdministration
    optionally include this element to specify the address and
    directions to a voter's voting location. The LatLng element can
    be included to specify the latitude and longitude of the voting
    location."""
    subclass = None
    superclass = None
    def __init__(self, Address=None, Directions=None, LatLng=None):
        self.original_tagname_ = None
        self.Address = Address
        self.Directions = Directions
        self.LatLng = LatLng
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Location)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Location.subclass:
            return Location.subclass(*args_, **kwargs_)
        else:
            return Location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Directions(self): return self.Directions
    def set_Directions(self, Directions): self.Directions = Directions
    def get_LatLng(self): return self.LatLng
    def set_LatLng(self, LatLng): self.LatLng = LatLng
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Directions is not None or
            self.LatLng is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Location', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Location')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Location')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Location', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Location'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Location', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespaceprefix_, name_='Address', pretty_print=pretty_print)
        if self.Directions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Directions>%s</Directions>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Directions), input_name='Directions')), eol_))
        if self.LatLng is not None:
            self.LatLng.export(outfile, level, namespaceprefix_, name_='LatLng', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Directions':
            Directions_ = child_.text
            Directions_ = self.gds_validate_string(Directions_, node, 'Directions')
            self.Directions = Directions_
        elif nodeName_ == 'LatLng':
            obj_ = LatLng.factory()
            obj_.build(child_)
            self.LatLng = obj_
            obj_.original_tagname_ = 'LatLng'
# end class Location


class Name(GeneratedsSuper):
    """Used in request messages. Voter includes this class for specifying
    the name of a voter and, optionally, for specifying a previous
    name of the voter, using PreviousName instead of Name.
    RequestHelper also includes this class for specifying the name
    of a registration helper. Multiple occurrences of the MiddleName
    attribute can be used as needed, e.g., for names with additional
    middle names or nicknames such as "John Andrew Winston (Jack)
    Smith". All elements are optional, however at least FullName
    must be included if the other attributes are not."""
    subclass = None
    superclass = None
    def __init__(self, FirstName=None, FullName=None, LastName=None, MiddleName=None, Prefix=None, Suffix=None, valueOf_=None):
        self.original_tagname_ = None
        self.FirstName = FirstName
        self.FullName = FullName
        self.LastName = LastName
        if MiddleName is None:
            self.MiddleName = []
        else:
            self.MiddleName = MiddleName
        self.Prefix = Prefix
        self.Suffix = Suffix
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Name.subclass:
            return Name.subclass(*args_, **kwargs_)
        else:
            return Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def get_FullName(self): return self.FullName
    def set_FullName(self, FullName): self.FullName = FullName
    def get_LastName(self): return self.LastName
    def set_LastName(self, LastName): self.LastName = LastName
    def get_MiddleName(self): return self.MiddleName
    def set_MiddleName(self, MiddleName): self.MiddleName = MiddleName
    def add_MiddleName(self, value): self.MiddleName.append(value)
    def insert_MiddleName_at(self, index, value): self.MiddleName.insert(index, value)
    def replace_MiddleName_at(self, index, value): self.MiddleName[index] = value
    def get_Prefix(self): return self.Prefix
    def set_Prefix(self, Prefix): self.Prefix = Prefix
    def get_Suffix(self): return self.Suffix
    def set_Suffix(self, Suffix): self.Suffix = Suffix
    def hasContent_(self):
        if (
            self.FirstName is not None or
            self.FullName is not None or
            self.LastName is not None or
            self.MiddleName or
            self.Prefix is not None or
            self.Suffix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Name', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Name', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Name'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Name', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FirstName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FirstName>%s</FirstName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FirstName), input_name='FirstName')), eol_))
        if self.FullName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<FullName>%s</FullName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.FullName), input_name='FullName')), eol_))
        if self.LastName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<LastName>%s</LastName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LastName), input_name='LastName')), eol_))
        for MiddleName_ in self.MiddleName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<MiddleName>%s</MiddleName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(MiddleName_), input_name='MiddleName')), eol_))
        if self.Prefix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Prefix>%s</Prefix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Prefix), input_name='Prefix')), eol_))
        if self.Suffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Suffix>%s</Suffix>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Suffix), input_name='Suffix')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FirstName':
            FirstName_ = child_.text
            FirstName_ = self.gds_validate_string(FirstName_, node, 'FirstName')
            self.FirstName = FirstName_
        elif nodeName_ == 'FullName':
            FullName_ = child_.text
            FullName_ = self.gds_validate_string(FullName_, node, 'FullName')
            self.FullName = FullName_
        elif nodeName_ == 'LastName':
            LastName_ = child_.text
            LastName_ = self.gds_validate_string(LastName_, node, 'LastName')
            self.LastName = LastName_
        elif nodeName_ == 'MiddleName':
            MiddleName_ = child_.text
            MiddleName_ = self.gds_validate_string(MiddleName_, node, 'MiddleName')
            self.MiddleName.append(MiddleName_)
        elif nodeName_ == 'Prefix':
            Prefix_ = child_.text
            Prefix_ = self.gds_validate_string(Prefix_, node, 'Prefix')
            self.Prefix = Prefix_
        elif nodeName_ == 'Suffix':
            Suffix_ = child_.text
            Suffix_ = self.gds_validate_string(Suffix_, node, 'Suffix')
            self.Suffix = Suffix_
# end class Name


class Party(GeneratedsSuper):
    """Used in request messages. BallotStyle optionally includes this
    attribute to specify the associated political party, such as for
    closed primaries. Voter optionally includes this attribute to
    specify a voter's political party."""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, ExternalIdentifier=None, Name=None):
        self.original_tagname_ = None
        self.Abbreviation = Abbreviation
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        self.Name = Name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.Abbreviation is not None or
            self.ExternalIdentifier or
            self.Name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Party', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Party'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Party', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Abbreviation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Abbreviation>%s</Abbreviation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Abbreviation), input_name='Abbreviation')), eol_))
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Abbreviation':
            Abbreviation_ = child_.text
            Abbreviation_ = self.gds_validate_string(Abbreviation_, node, 'Abbreviation')
            self.Abbreviation = Abbreviation_
        elif nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
# end class Party


class PermanentBallotRequest(BallotRequest):
    """Used in request messages. Implementation of BallotRequest which
    serves to request ballots for election events that the voter is
    qualified on a long term basis. Although &quot;permanent&quot;,
    the request may be subject to renewal or cancellation
    procedures."""
    subclass = None
    superclass = BallotRequest
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None):
        self.original_tagname_ = None
        super(PermanentBallotRequest, self).__init__(BallotReceiptPreference, MailForwardingAddress, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PermanentBallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PermanentBallotRequest.subclass:
            return PermanentBallotRequest.subclass(*args_, **kwargs_)
        else:
            return PermanentBallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PermanentBallotRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='PermanentBallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PermanentBallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PermanentBallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PermanentBallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PermanentBallotRequest'):
        super(PermanentBallotRequest, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PermanentBallotRequest')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PermanentBallotRequest', fromsubclass_=False, pretty_print=True):
        super(PermanentBallotRequest, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PermanentBallotRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PermanentBallotRequest, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PermanentBallotRequest


class PhoneContactMethod(ContactMethod):
    """Used in request and response messages. RequestHelper, and
    RequestProxy use this class to specify a telephone number as
    well as the capabilities of the telephone, e.g., sms, fax, etc.
    PhoneContactMethod is subtype of ContactMethod. Thus, the
    elements that include ContactMethod could use PhoneContactMethod
    as applicable."""
    subclass = None
    superclass = ContactMethod
    def __init__(self, OtherType=None, Type=None, Value=None, Capability=None):
        self.original_tagname_ = None
        super(PhoneContactMethod, self).__init__(OtherType, Type, Value, )
        if Capability is None:
            self.Capability = []
        else:
            self.Capability = Capability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhoneContactMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhoneContactMethod.subclass:
            return PhoneContactMethod.subclass(*args_, **kwargs_)
        else:
            return PhoneContactMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Capability(self): return self.Capability
    def set_Capability(self, Capability): self.Capability = Capability
    def add_Capability(self, value): self.Capability.append(value)
    def insert_Capability_at(self, index, value): self.Capability.insert(index, value)
    def replace_Capability_at(self, index, value): self.Capability[index] = value
    def validate_PhoneCapability(self, value):
        # Validate type PhoneCapability, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fax', 'mms', 'sms', 'voice']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PhoneCapability' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Capability or
            super(PhoneContactMethod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='PhoneContactMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhoneContactMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhoneContactMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PhoneContactMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhoneContactMethod'):
        super(PhoneContactMethod, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhoneContactMethod')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PhoneContactMethod', fromsubclass_=False, pretty_print=True):
        super(PhoneContactMethod, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Capability_ in self.Capability:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Capability>%s</Capability>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Capability_), input_name='Capability')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PhoneContactMethod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Capability':
            Capability_ = child_.text
            Capability_ = self.gds_validate_string(Capability_, node, 'Capability')
            self.Capability.append(Capability_)
            # validate type PhoneCapability
            self.validate_PhoneCapability(self.Capability[-1])
        super(PhoneContactMethod, self).buildChildren(child_, node, nodeName_, True)
# end class PhoneContactMethod


class ReportingUnit(GeneratedsSuper):
    """Used in response messages. RequestSuccess and VoterRecord include
    this class so as to provide a list of geopolitical geography
    associated with the voter's registration, e.g., the voter's
    precinct, polling place, districts, etc. The Type attribute uses
    the ReportingUnitType enumeration to specify the type of
    geopolitical geography being defined. If the reporting unit type
    is not listed in enumeration ReportingUnitType, use other and
    include the reporting unit type (that is not listed in the
    enumeration) in OtherType. The IsDistricted boolean is not
    strictly necessary, as it is possible to identify districts by
    their Type attribute. However, if the type of district is not
    listed in the ReportingUnitType enumeration and therefore
    OtherType is used, then IsDistricted is necessary. The
    IsDistricted boolean can also be used to signify that a
    ReportingUnit defined as a jurisdiction, e.g., a county, is also
    used as a district for, e.g., county-wide contests."""
    subclass = None
    superclass = None
    def __init__(self, ExternalIdentifier=None, IsDistricted=None, Location=None, Name=None, OtherType=None, Type=None):
        self.original_tagname_ = None
        if ExternalIdentifier is None:
            self.ExternalIdentifier = []
        else:
            self.ExternalIdentifier = ExternalIdentifier
        self.IsDistricted = IsDistricted
        self.Location = Location
        self.Name = Name
        self.OtherType = OtherType
        self.Type = Type
        self.validate_ReportingUnitType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportingUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportingUnit.subclass:
            return ReportingUnit.subclass(*args_, **kwargs_)
        else:
            return ReportingUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIdentifier(self): return self.ExternalIdentifier
    def set_ExternalIdentifier(self, ExternalIdentifier): self.ExternalIdentifier = ExternalIdentifier
    def add_ExternalIdentifier(self, value): self.ExternalIdentifier.append(value)
    def insert_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier.insert(index, value)
    def replace_ExternalIdentifier_at(self, index, value): self.ExternalIdentifier[index] = value
    def get_IsDistricted(self): return self.IsDistricted
    def set_IsDistricted(self, IsDistricted): self.IsDistricted = IsDistricted
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ReportingUnitType(self, value):
        # Validate type ReportingUnitType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ballot-batch', 'ballot-style-area', 'borough', 'city', 'city-council', 'combined-precinct', 'congressional', 'county', 'county-council', 'drop-box', 'judicial', 'municipality', 'polling-place', 'precinct', 'school', 'special', 'split-precinct', 'state', 'state-house', 'state-senate', 'town', 'township', 'utility', 'village', 'vote-center', 'ward', 'water', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ReportingUnitType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ExternalIdentifier or
            self.IsDistricted is not None or
            self.Location is not None or
            self.Name is not None or
            self.OtherType is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ReportingUnit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReportingUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReportingUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ReportingUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReportingUnit'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ReportingUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExternalIdentifier_ in self.ExternalIdentifier:
            ExternalIdentifier_.export(outfile, level, namespaceprefix_, name_='ExternalIdentifier', pretty_print=pretty_print)
        if self.IsDistricted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<IsDistricted>%s</IsDistricted>%s' % (self.gds_format_boolean(self.IsDistricted, input_name='IsDistricted'), eol_))
        if self.Location is not None:
            self.Location.export(outfile, level, namespaceprefix_, name_='Location', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIdentifier':
            obj_ = ExternalIdentifier.factory()
            obj_.build(child_)
            self.ExternalIdentifier.append(obj_)
            obj_.original_tagname_ = 'ExternalIdentifier'
        elif nodeName_ == 'IsDistricted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsDistricted')
            self.IsDistricted = ival_
        elif nodeName_ == 'Location':
            obj_ = Location.factory()
            obj_.build(child_)
            self.Location = obj_
            obj_.original_tagname_ = 'Location'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type ReportingUnitType
            self.validate_ReportingUnitType(self.Type)
# end class ReportingUnit


class RequestHelper(GeneratedsSuper):
    """VoterRecordsRequest optionally includes this element to specify
    information about a request helper, i.e., a request assistant or
    witness involved in a voter's request. RequestHelper includes
    the Name element to specify the registration helper's name and
    optionally includes the Signature element if a registration
    helper's signature is required."""
    subclass = None
    superclass = None
    def __init__(self, Address=None, Name=None, Phone=None, Signature=None, Type=None):
        self.original_tagname_ = None
        self.Address = Address
        self.Name = Name
        self.Phone = Phone
        self.Signature = Signature
        self.Type = Type
        self.validate_VoterHelperType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestHelper)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestHelper.subclass:
            return RequestHelper.subclass(*args_, **kwargs_)
        else:
            return RequestHelper(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VoterHelperType(self, value):
        # Validate type VoterHelperType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['assistant', 'witness']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterHelperType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Name is not None or
            self.Phone is not None or
            self.Signature is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestHelper', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestHelper')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestHelper')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestHelper', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestHelper'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestHelper', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespaceprefix_, name_='Address', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespaceprefix_, name_='Name', pretty_print=pretty_print)
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespaceprefix_, name_='Phone', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_, name_='Signature', pretty_print=pretty_print)
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType1.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Phone':
            obj_ = PhoneContactMethod.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
        elif nodeName_ == 'Signature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type VoterHelperType
            self.validate_VoterHelperType(self.Type)
# end class RequestHelper


class RequestProxy(GeneratedsSuper):
    """Used in request messages. VoterRecordsRequest optionally includes
    this class to specify information about a request proxy involved
    in a voter records request. OriginTransactionId can be used to
    include an optional identifier of the originating external
    transaction from the proxy, e.g., used for the transaction ID
    generated by a DMV application enacting a voter registration
    request to a registration portal application (on behalf of a
    citizen obtaining a driver's license). This sub-element is not
    to be confused with TransactionId in VoterRecordsRequest, which
    is used to include a transaction ID of the voter records
    request, e.g., the transaction ID of the registration portal's
    voter records request."""
    subclass = None
    superclass = None
    def __init__(self, Address=None, Name=None, OriginTransactionId=None, OtherType=None, Phone=None, TimeStamp=None, Type=None):
        self.original_tagname_ = None
        self.Address = Address
        self.Name = Name
        self.OriginTransactionId = OriginTransactionId
        self.OtherType = OtherType
        self.Phone = Phone
        if isinstance(TimeStamp, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(TimeStamp, '%Y-%m-%d').date()
        else:
            initvalue_ = TimeStamp
        self.TimeStamp = initvalue_
        self.Type = Type
        self.validate_RequestProxyType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestProxy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestProxy.subclass:
            return RequestProxy.subclass(*args_, **kwargs_)
        else:
            return RequestProxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OriginTransactionId(self): return self.OriginTransactionId
    def set_OriginTransactionId(self, OriginTransactionId): self.OriginTransactionId = OriginTransactionId
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Phone(self): return self.Phone
    def set_Phone(self, Phone): self.Phone = Phone
    def get_TimeStamp(self): return self.TimeStamp
    def set_TimeStamp(self, TimeStamp): self.TimeStamp = TimeStamp
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_RequestProxyType(self, value):
        # Validate type RequestProxyType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['armed-forces-recruitment-office', 'motor-vehicle-office', 'other-agency-designated-by-state', 'public-assistance-office', 'registration-drive-from-advocacy-group-or-political-party', 'state-funded-agency-serving-persons-with-disabilities', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestProxyType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Name is not None or
            self.OriginTransactionId is not None or
            self.OtherType is not None or
            self.Phone is not None or
            self.TimeStamp is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestProxy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestProxy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestProxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestProxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestProxy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestProxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespaceprefix_, name_='Address', pretty_print=pretty_print)
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Name>%s</Name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Name), input_name='Name')), eol_))
        if self.OriginTransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OriginTransactionId>%s</OriginTransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OriginTransactionId), input_name='OriginTransactionId')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Phone is not None:
            self.Phone.export(outfile, level, namespaceprefix_, name_='Phone', pretty_print=pretty_print)
        if self.TimeStamp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TimeStamp>%s</TimeStamp>%s' % (self.gds_format_date(self.TimeStamp, input_name='TimeStamp'), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType2.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'OriginTransactionId':
            OriginTransactionId_ = child_.text
            OriginTransactionId_ = self.gds_validate_string(OriginTransactionId_, node, 'OriginTransactionId')
            self.OriginTransactionId = OriginTransactionId_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Phone':
            obj_ = PhoneContactMethod.factory()
            obj_.build(child_)
            self.Phone = obj_
            obj_.original_tagname_ = 'Phone'
        elif nodeName_ == 'TimeStamp':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.TimeStamp = dval_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type RequestProxyType
            self.validate_RequestProxyType(self.Type)
# end class RequestProxy


class Signature(GeneratedsSuper):
    """Used in request messages. Voter optionally includes this class for
    specifying information about a voter's signature on a
    registration request. If there is a need to include previous
    signature that uses a different name, e.g., a maiden name, Voter
    uses PreviousSignature instead of Signature. RequestHelper
    optionally includes this class for specifying information about
    the helper's signature. Source is used to specify the source of
    the voter's signature, for example, on file at a department of
    motor vehicles. FileValue is used to include an image of the
    voter's signature."""
    subclass = None
    superclass = None
    def __init__(self, Date=None, FileValue=None, OtherSource=None, OtherType=None, Source=None, Type=None):
        self.original_tagname_ = None
        if isinstance(Date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.FileValue = FileValue
        self.OtherSource = OtherSource
        self.OtherType = OtherType
        self.Source = Source
        self.validate_SignatureSource(self.Source)
        self.Type = Type
        self.validate_SignatureType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Signature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Signature.subclass:
            return Signature.subclass(*args_, **kwargs_)
        else:
            return Signature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_FileValue(self): return self.FileValue
    def set_FileValue(self, FileValue): self.FileValue = FileValue
    def get_OtherSource(self): return self.OtherSource
    def set_OtherSource(self, OtherSource): self.OtherSource = OtherSource
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SignatureSource(self, value):
        # Validate type SignatureSource, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dmv', 'local', 'state', 'voter', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SignatureSource' % {"value" : value.encode("utf-8")} )
    def validate_SignatureType(self, value):
        # Validate type SignatureType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['dynamic', 'electronic', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SignatureType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Date is not None or
            self.FileValue is not None or
            self.OtherSource is not None or
            self.OtherType is not None or
            self.Source is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Signature', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Signature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Signature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Signature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Signature'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Signature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Date>%s</Date>%s' % (self.gds_format_date(self.Date, input_name='Date'), eol_))
        if self.FileValue is not None:
            self.FileValue.export(outfile, level, namespaceprefix_, name_='FileValue', pretty_print=pretty_print)
        if self.OtherSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherSource>%s</OtherSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherSource), input_name='OtherSource')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Source>%s</Source>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Source), input_name='Source')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'FileValue':
            obj_ = Image.factory()
            obj_.build(child_)
            self.FileValue = obj_
            obj_.original_tagname_ = 'FileValue'
        elif nodeName_ == 'OtherSource':
            OtherSource_ = child_.text
            OtherSource_ = self.gds_validate_string(OtherSource_, node, 'OtherSource')
            self.OtherSource = OtherSource_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
            # validate type SignatureSource
            self.validate_SignatureSource(self.Source)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type SignatureType
            self.validate_SignatureType(self.Type)
# end class Signature


class TemporalBallotRequest(BallotRequest):
    """Implementation of BallotRequest in which election opportunities that
    the voter is qualified during a given time frame will be
    requested."""
    subclass = None
    superclass = BallotRequest
    def __init__(self, BallotReceiptPreference=None, MailForwardingAddress=None, EndDate=None, StartDate=None):
        self.original_tagname_ = None
        super(TemporalBallotRequest, self).__init__(BallotReceiptPreference, MailForwardingAddress, )
        if isinstance(EndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EndDate
        self.EndDate = initvalue_
        if isinstance(StartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(StartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = StartDate
        self.StartDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemporalBallotRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemporalBallotRequest.subclass:
            return TemporalBallotRequest.subclass(*args_, **kwargs_)
        else:
            return TemporalBallotRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def hasContent_(self):
        if (
            self.EndDate is not None or
            self.StartDate is not None or
            super(TemporalBallotRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='TemporalBallotRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemporalBallotRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemporalBallotRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TemporalBallotRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TemporalBallotRequest'):
        super(TemporalBallotRequest, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemporalBallotRequest')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TemporalBallotRequest', fromsubclass_=False, pretty_print=True):
        super(TemporalBallotRequest, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EndDate>%s</EndDate>%s' % (self.gds_format_date(self.EndDate, input_name='EndDate'), eol_))
        if self.StartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StartDate>%s</StartDate>%s' % (self.gds_format_date(self.StartDate, input_name='StartDate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TemporalBallotRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EndDate = dval_
        elif nodeName_ == 'StartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.StartDate = dval_
        super(TemporalBallotRequest, self).buildChildren(child_, node, nodeName_, True)
# end class TemporalBallotRequest


class Voter(GeneratedsSuper):
    """Voter contains attributes specific to identifying a voter."""
    subclass = None
    superclass = None
    def __init__(self, ContactMethod=None, DateOfBirth=None, Ethnicity=None, Gender=None, MailingAddress=None, Name=None, Party=None, PreviousName=None, PreviousResidenceAddress=None, PreviousSignature=None, ResidenceAddress=None, ResidenceAddressIsMailingAddress=None, Signature=None, VoterClassification=None, VoterId=None):
        self.original_tagname_ = None
        if ContactMethod is None:
            self.ContactMethod = []
        else:
            self.ContactMethod = ContactMethod
        if isinstance(DateOfBirth, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateOfBirth, '%Y-%m-%d').date()
        else:
            initvalue_ = DateOfBirth
        self.DateOfBirth = initvalue_
        self.Ethnicity = Ethnicity
        self.Gender = Gender
        self.MailingAddress = MailingAddress
        self.Name = Name
        self.Party = Party
        self.PreviousName = PreviousName
        self.PreviousResidenceAddress = PreviousResidenceAddress
        self.PreviousSignature = PreviousSignature
        self.ResidenceAddress = ResidenceAddress
        self.ResidenceAddressIsMailingAddress = ResidenceAddressIsMailingAddress
        self.Signature = Signature
        if VoterClassification is None:
            self.VoterClassification = []
        else:
            self.VoterClassification = VoterClassification
        if VoterId is None:
            self.VoterId = []
        else:
            self.VoterId = VoterId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Voter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Voter.subclass:
            return Voter.subclass(*args_, **kwargs_)
        else:
            return Voter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactMethod(self): return self.ContactMethod
    def set_ContactMethod(self, ContactMethod): self.ContactMethod = ContactMethod
    def add_ContactMethod(self, value): self.ContactMethod.append(value)
    def insert_ContactMethod_at(self, index, value): self.ContactMethod.insert(index, value)
    def replace_ContactMethod_at(self, index, value): self.ContactMethod[index] = value
    def get_DateOfBirth(self): return self.DateOfBirth
    def set_DateOfBirth(self, DateOfBirth): self.DateOfBirth = DateOfBirth
    def get_Ethnicity(self): return self.Ethnicity
    def set_Ethnicity(self, Ethnicity): self.Ethnicity = Ethnicity
    def get_Gender(self): return self.Gender
    def set_Gender(self, Gender): self.Gender = Gender
    def get_MailingAddress(self): return self.MailingAddress
    def set_MailingAddress(self, MailingAddress): self.MailingAddress = MailingAddress
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Party(self): return self.Party
    def set_Party(self, Party): self.Party = Party
    def get_PreviousName(self): return self.PreviousName
    def set_PreviousName(self, PreviousName): self.PreviousName = PreviousName
    def get_PreviousResidenceAddress(self): return self.PreviousResidenceAddress
    def set_PreviousResidenceAddress(self, PreviousResidenceAddress): self.PreviousResidenceAddress = PreviousResidenceAddress
    def get_PreviousSignature(self): return self.PreviousSignature
    def set_PreviousSignature(self, PreviousSignature): self.PreviousSignature = PreviousSignature
    def get_ResidenceAddress(self): return self.ResidenceAddress
    def set_ResidenceAddress(self, ResidenceAddress): self.ResidenceAddress = ResidenceAddress
    def get_ResidenceAddressIsMailingAddress(self): return self.ResidenceAddressIsMailingAddress
    def set_ResidenceAddressIsMailingAddress(self, ResidenceAddressIsMailingAddress): self.ResidenceAddressIsMailingAddress = ResidenceAddressIsMailingAddress
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_VoterClassification(self): return self.VoterClassification
    def set_VoterClassification(self, VoterClassification): self.VoterClassification = VoterClassification
    def add_VoterClassification(self, value): self.VoterClassification.append(value)
    def insert_VoterClassification_at(self, index, value): self.VoterClassification.insert(index, value)
    def replace_VoterClassification_at(self, index, value): self.VoterClassification[index] = value
    def get_VoterId(self): return self.VoterId
    def set_VoterId(self, VoterId): self.VoterId = VoterId
    def add_VoterId(self, value): self.VoterId.append(value)
    def insert_VoterId_at(self, index, value): self.VoterId.insert(index, value)
    def replace_VoterId_at(self, index, value): self.VoterId[index] = value
    def hasContent_(self):
        if (
            self.ContactMethod or
            self.DateOfBirth is not None or
            self.Ethnicity is not None or
            self.Gender is not None or
            self.MailingAddress is not None or
            self.Name is not None or
            self.Party is not None or
            self.PreviousName is not None or
            self.PreviousResidenceAddress is not None or
            self.PreviousSignature is not None or
            self.ResidenceAddress is not None or
            self.ResidenceAddressIsMailingAddress is not None or
            self.Signature is not None or
            self.VoterClassification or
            self.VoterId
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Voter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Voter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Voter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Voter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Voter'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Voter', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContactMethod_ in self.ContactMethod:
            ContactMethod_.export(outfile, level, namespaceprefix_, name_='ContactMethod', pretty_print=pretty_print)
        if self.DateOfBirth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DateOfBirth>%s</DateOfBirth>%s' % (self.gds_format_date(self.DateOfBirth, input_name='DateOfBirth'), eol_))
        if self.Ethnicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Ethnicity>%s</Ethnicity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Ethnicity), input_name='Ethnicity')), eol_))
        if self.Gender is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Gender>%s</Gender>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Gender), input_name='Gender')), eol_))
        if self.MailingAddress is not None:
            self.MailingAddress.export(outfile, level, namespaceprefix_, name_='MailingAddress', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespaceprefix_, name_='Name', pretty_print=pretty_print)
        if self.Party is not None:
            self.Party.export(outfile, level, namespaceprefix_, name_='Party', pretty_print=pretty_print)
        if self.PreviousName is not None:
            self.PreviousName.export(outfile, level, namespaceprefix_, name_='PreviousName', pretty_print=pretty_print)
        if self.PreviousResidenceAddress is not None:
            self.PreviousResidenceAddress.export(outfile, level, namespaceprefix_, name_='PreviousResidenceAddress', pretty_print=pretty_print)
        if self.PreviousSignature is not None:
            self.PreviousSignature.export(outfile, level, namespaceprefix_, name_='PreviousSignature', pretty_print=pretty_print)
        if self.ResidenceAddress is not None:
            self.ResidenceAddress.export(outfile, level, namespaceprefix_, name_='ResidenceAddress', pretty_print=pretty_print)
        if self.ResidenceAddressIsMailingAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ResidenceAddressIsMailingAddress>%s</ResidenceAddressIsMailingAddress>%s' % (self.gds_format_boolean(self.ResidenceAddressIsMailingAddress, input_name='ResidenceAddressIsMailingAddress'), eol_))
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_, name_='Signature', pretty_print=pretty_print)
        for VoterClassification_ in self.VoterClassification:
            VoterClassification_.export(outfile, level, namespaceprefix_, name_='VoterClassification', pretty_print=pretty_print)
        for VoterId_ in self.VoterId:
            VoterId_.export(outfile, level, namespaceprefix_, name_='VoterId', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactMethod':
            class_obj_ = self.get_class_obj_(child_, ContactMethod)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ContactMethod.append(obj_)
            obj_.original_tagname_ = 'ContactMethod'
        elif nodeName_ == 'DateOfBirth':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateOfBirth = dval_
        elif nodeName_ == 'Ethnicity':
            Ethnicity_ = child_.text
            Ethnicity_ = self.gds_validate_string(Ethnicity_, node, 'Ethnicity')
            self.Ethnicity = Ethnicity_
        elif nodeName_ == 'Gender':
            Gender_ = child_.text
            Gender_ = self.gds_validate_string(Gender_, node, 'Gender')
            self.Gender = Gender_
        elif nodeName_ == 'MailingAddress':
            obj_ = MailingAddressType.factory()
            obj_.build(child_)
            self.MailingAddress = obj_
            obj_.original_tagname_ = 'MailingAddress'
        elif nodeName_ == 'Name':
            obj_ = Name.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Party':
            obj_ = Party.factory()
            obj_.build(child_)
            self.Party = obj_
            obj_.original_tagname_ = 'Party'
        elif nodeName_ == 'PreviousName':
            obj_ = Name.factory()
            obj_.build(child_)
            self.PreviousName = obj_
            obj_.original_tagname_ = 'PreviousName'
        elif nodeName_ == 'PreviousResidenceAddress':
            obj_ = PreviousResidenceAddressType.factory()
            obj_.build(child_)
            self.PreviousResidenceAddress = obj_
            obj_.original_tagname_ = 'PreviousResidenceAddress'
        elif nodeName_ == 'PreviousSignature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.PreviousSignature = obj_
            obj_.original_tagname_ = 'PreviousSignature'
        elif nodeName_ == 'ResidenceAddress':
            obj_ = ResidenceAddressType.factory()
            obj_.build(child_)
            self.ResidenceAddress = obj_
            obj_.original_tagname_ = 'ResidenceAddress'
        elif nodeName_ == 'ResidenceAddressIsMailingAddress':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ResidenceAddressIsMailingAddress')
            self.ResidenceAddressIsMailingAddress = ival_
        elif nodeName_ == 'Signature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
        elif nodeName_ == 'VoterClassification':
            obj_ = VoterClassification.factory()
            obj_.build(child_)
            self.VoterClassification.append(obj_)
            obj_.original_tagname_ = 'VoterClassification'
        elif nodeName_ == 'VoterId':
            obj_ = VoterId.factory()
            obj_.build(child_)
            self.VoterId.append(obj_)
            obj_.original_tagname_ = 'VoterId'
# end class Voter


class VoterClassification(GeneratedsSuper):
    """Voter optionally includes this class to describe a voter's
    classification per criteria on the voter's request form, e.g.,
    united-states-citizen or eighteen-on-election-day.
    VoterClassification includes assertions of the voter in response
    to the voter request form criteria. For example, an assertion of
    true may be used with a criterion of united-states-citizen.
    Assertions can be negative, such as providing an assertion of
    false for a criterion of felon, an assertion of unknown to
    indicate that the voter does not know whether they meet or do
    not meet the specific criteria on the form or an assertion of
    other, in which the assertion is specified by the value of
    OtherAssertion."""
    subclass = None
    superclass = None
    def __init__(self, Assertion=None, OtherAssertion=None, OtherType=None, Type=None):
        self.original_tagname_ = None
        self.Assertion = Assertion
        self.validate_AssertionValue(self.Assertion)
        self.OtherAssertion = OtherAssertion
        self.OtherType = OtherType
        self.Type = Type
        self.validate_VoterClassificationType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterClassification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterClassification.subclass:
            return VoterClassification.subclass(*args_, **kwargs_)
        else:
            return VoterClassification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Assertion(self): return self.Assertion
    def set_Assertion(self, Assertion): self.Assertion = Assertion
    def get_OtherAssertion(self): return self.OtherAssertion
    def set_OtherAssertion(self, OtherAssertion): self.OtherAssertion = OtherAssertion
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AssertionValue(self, value):
        # Validate type AssertionValue, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['no', 'yes', 'unknown', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AssertionValue' % {"value" : value.encode("utf-8")} )
    def validate_VoterClassificationType(self, value):
        # Validate type VoterClassificationType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['activated-national-guard', 'active-duty', 'active-duty-spouse-or-dependent', 'citizen-abroad-intent-to-return', 'citizen-abroad-return-uncertain', 'citizen-abroad-never-resided', 'deceased', 'declared-incompetent', 'eighteen-on-election-day', 'felon', 'permanently-denied', 'protected-voter', 'restored-felon', 'united-states-citizen', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterClassificationType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Assertion is not None or
            self.OtherAssertion is not None or
            self.OtherType is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterClassification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterClassification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterClassification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterClassification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterClassification'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterClassification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Assertion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Assertion>%s</Assertion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Assertion), input_name='Assertion')), eol_))
        if self.OtherAssertion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherAssertion>%s</OtherAssertion>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherAssertion), input_name='OtherAssertion')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Assertion':
            Assertion_ = child_.text
            Assertion_ = self.gds_validate_string(Assertion_, node, 'Assertion')
            self.Assertion = Assertion_
            # validate type AssertionValue
            self.validate_AssertionValue(self.Assertion)
        elif nodeName_ == 'OtherAssertion':
            OtherAssertion_ = child_.text
            OtherAssertion_ = self.gds_validate_string(OtherAssertion_, node, 'OtherAssertion')
            self.OtherAssertion = OtherAssertion_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type VoterClassificationType
            self.validate_VoterClassificationType(self.Type)
# end class VoterClassification


class VoterId(GeneratedsSuper):
    """Used in request and response messages. Used to include information
    about a voter's identification that may be required in a
    registration request. Voter includes VoterId. AttestNoSuchId is
    used to attest that the voter has no ID of a specified type,
    thus it must be included with a value of true if attesting that
    the voter has no ID for that specified type. It can be included
    with a value of false to attest that the voter does have an ID
    of the specified type, in which case either StringValue or
    FileValue must be included; however, it is assumed to be false
    if not included. The StringValue and FileValue sub-elements are
    both optional, however at least one of them must be included."""
    subclass = None
    superclass = None
    def __init__(self, AttestNoSuchId=None, DateOfIssuance=None, FileValue=None, OtherType=None, StringValue=None, Type=None):
        self.original_tagname_ = None
        self.AttestNoSuchId = AttestNoSuchId
        if isinstance(DateOfIssuance, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(DateOfIssuance, '%Y-%m-%d').date()
        else:
            initvalue_ = DateOfIssuance
        self.DateOfIssuance = initvalue_
        self.FileValue = FileValue
        self.OtherType = OtherType
        self.StringValue = StringValue
        self.Type = Type
        self.validate_VoterIdType(self.Type)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterId)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterId.subclass:
            return VoterId.subclass(*args_, **kwargs_)
        else:
            return VoterId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttestNoSuchId(self): return self.AttestNoSuchId
    def set_AttestNoSuchId(self, AttestNoSuchId): self.AttestNoSuchId = AttestNoSuchId
    def get_DateOfIssuance(self): return self.DateOfIssuance
    def set_DateOfIssuance(self, DateOfIssuance): self.DateOfIssuance = DateOfIssuance
    def get_FileValue(self): return self.FileValue
    def set_FileValue(self, FileValue): self.FileValue = FileValue
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_StringValue(self): return self.StringValue
    def set_StringValue(self, StringValue): self.StringValue = StringValue
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VoterIdType(self, value):
        # Validate type VoterIdType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['drivers-license', 'local-voter-registration-id', 'ssn', 'ssn4', 'state-id', 'state-voter-registration-id', 'unspecified-document', 'unspecified-document-with-name-and-address', 'unspecified-document-with-photo-identification', 'unknown', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterIdType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AttestNoSuchId is not None or
            self.DateOfIssuance is not None or
            self.FileValue is not None or
            self.OtherType is not None or
            self.StringValue is not None or
            self.Type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterId', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterId')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterId')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterId', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterId'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterId', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AttestNoSuchId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AttestNoSuchId>%s</AttestNoSuchId>%s' % (self.gds_format_boolean(self.AttestNoSuchId, input_name='AttestNoSuchId'), eol_))
        if self.DateOfIssuance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<DateOfIssuance>%s</DateOfIssuance>%s' % (self.gds_format_date(self.DateOfIssuance, input_name='DateOfIssuance'), eol_))
        if self.FileValue is not None:
            self.FileValue.export(outfile, level, namespaceprefix_, name_='FileValue', pretty_print=pretty_print)
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        if self.StringValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<StringValue>%s</StringValue>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StringValue), input_name='StringValue')), eol_))
        if self.Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Type), input_name='Type')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttestNoSuchId':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AttestNoSuchId')
            self.AttestNoSuchId = ival_
        elif nodeName_ == 'DateOfIssuance':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.DateOfIssuance = dval_
        elif nodeName_ == 'FileValue':
            class_obj_ = self.get_class_obj_(child_, File)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FileValue = obj_
            obj_.original_tagname_ = 'FileValue'
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'StringValue':
            StringValue_ = child_.text
            StringValue_ = self.gds_validate_string(StringValue_, node, 'StringValue')
            self.StringValue = StringValue_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
            # validate type VoterIdType
            self.validate_VoterIdType(self.Type)
# end class VoterId


class VoterParticipation(GeneratedsSuper):
    """For indicating an election that the voter participated in.
    Participation does not imply a counted ballot."""
    subclass = None
    superclass = None
    def __init__(self, BallotStyle=None, Election=None, PollingLocation=None):
        self.original_tagname_ = None
        self.BallotStyle = BallotStyle
        self.Election = Election
        self.PollingLocation = PollingLocation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterParticipation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterParticipation.subclass:
            return VoterParticipation.subclass(*args_, **kwargs_)
        else:
            return VoterParticipation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BallotStyle(self): return self.BallotStyle
    def set_BallotStyle(self, BallotStyle): self.BallotStyle = BallotStyle
    def get_Election(self): return self.Election
    def set_Election(self, Election): self.Election = Election
    def get_PollingLocation(self): return self.PollingLocation
    def set_PollingLocation(self, PollingLocation): self.PollingLocation = PollingLocation
    def hasContent_(self):
        if (
            self.BallotStyle is not None or
            self.Election is not None or
            self.PollingLocation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterParticipation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterParticipation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterParticipation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterParticipation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterParticipation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterParticipation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BallotStyle is not None:
            self.BallotStyle.export(outfile, level, namespaceprefix_, name_='BallotStyle', pretty_print=pretty_print)
        if self.Election is not None:
            self.Election.export(outfile, level, namespaceprefix_, name_='Election', pretty_print=pretty_print)
        if self.PollingLocation is not None:
            self.PollingLocation.export(outfile, level, namespaceprefix_, name_='PollingLocation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BallotStyle':
            obj_ = BallotStyle.factory()
            obj_.build(child_)
            self.BallotStyle = obj_
            obj_.original_tagname_ = 'BallotStyle'
        elif nodeName_ == 'Election':
            obj_ = Election.factory()
            obj_.build(child_)
            self.Election = obj_
            obj_.original_tagname_ = 'Election'
        elif nodeName_ == 'PollingLocation':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.PollingLocation = obj_
            obj_.original_tagname_ = 'PollingLocation'
# end class VoterParticipation


class VoterRecord(GeneratedsSuper):
    """A subtype of Voter representing a voter record stored in a Voter
    Registration Database (VRDB). VoterRecord optionally contains
    additional information useful to the voter, including a
    description of the voters polling place, districts associated
    with the voter's precinct, or other geopolitical geographies
    such as the voters precinct."""
    subclass = None
    superclass = None
    def __init__(self, District=None, ElectionAdministration=None, HavaIdRequired=None, Locality=None, OtherStatus=None, PollingLocation=None, Voter=None, VoterParticipation=None, VoterStatus=None):
        self.original_tagname_ = None
        if District is None:
            self.District = []
        else:
            self.District = District
        self.ElectionAdministration = ElectionAdministration
        self.HavaIdRequired = HavaIdRequired
        if Locality is None:
            self.Locality = []
        else:
            self.Locality = Locality
        self.OtherStatus = OtherStatus
        self.PollingLocation = PollingLocation
        self.Voter = Voter
        if VoterParticipation is None:
            self.VoterParticipation = []
        else:
            self.VoterParticipation = VoterParticipation
        self.VoterStatus = VoterStatus
        self.validate_VoterStatus(self.VoterStatus)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecord.subclass:
            return VoterRecord.subclass(*args_, **kwargs_)
        else:
            return VoterRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_District(self): return self.District
    def set_District(self, District): self.District = District
    def add_District(self, value): self.District.append(value)
    def insert_District_at(self, index, value): self.District.insert(index, value)
    def replace_District_at(self, index, value): self.District[index] = value
    def get_ElectionAdministration(self): return self.ElectionAdministration
    def set_ElectionAdministration(self, ElectionAdministration): self.ElectionAdministration = ElectionAdministration
    def get_HavaIdRequired(self): return self.HavaIdRequired
    def set_HavaIdRequired(self, HavaIdRequired): self.HavaIdRequired = HavaIdRequired
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def add_Locality(self, value): self.Locality.append(value)
    def insert_Locality_at(self, index, value): self.Locality.insert(index, value)
    def replace_Locality_at(self, index, value): self.Locality[index] = value
    def get_OtherStatus(self): return self.OtherStatus
    def set_OtherStatus(self, OtherStatus): self.OtherStatus = OtherStatus
    def get_PollingLocation(self): return self.PollingLocation
    def set_PollingLocation(self, PollingLocation): self.PollingLocation = PollingLocation
    def get_Voter(self): return self.Voter
    def set_Voter(self, Voter): self.Voter = Voter
    def get_VoterParticipation(self): return self.VoterParticipation
    def set_VoterParticipation(self, VoterParticipation): self.VoterParticipation = VoterParticipation
    def add_VoterParticipation(self, value): self.VoterParticipation.append(value)
    def insert_VoterParticipation_at(self, index, value): self.VoterParticipation.insert(index, value)
    def replace_VoterParticipation_at(self, index, value): self.VoterParticipation[index] = value
    def get_VoterStatus(self): return self.VoterStatus
    def set_VoterStatus(self, VoterStatus): self.VoterStatus = VoterStatus
    def validate_VoterStatus(self, value):
        # Validate type VoterStatus, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['active', 'inactive', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterStatus' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.District or
            self.ElectionAdministration is not None or
            self.HavaIdRequired is not None or
            self.Locality or
            self.OtherStatus is not None or
            self.PollingLocation is not None or
            self.Voter is not None or
            self.VoterParticipation or
            self.VoterStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecord', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecord'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for District_ in self.District:
            District_.export(outfile, level, namespaceprefix_, name_='District', pretty_print=pretty_print)
        if self.ElectionAdministration is not None:
            self.ElectionAdministration.export(outfile, level, namespaceprefix_, name_='ElectionAdministration', pretty_print=pretty_print)
        if self.HavaIdRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<HavaIdRequired>%s</HavaIdRequired>%s' % (self.gds_format_boolean(self.HavaIdRequired, input_name='HavaIdRequired'), eol_))
        for Locality_ in self.Locality:
            Locality_.export(outfile, level, namespaceprefix_, name_='Locality', pretty_print=pretty_print)
        if self.OtherStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherStatus>%s</OtherStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherStatus), input_name='OtherStatus')), eol_))
        if self.PollingLocation is not None:
            self.PollingLocation.export(outfile, level, namespaceprefix_, name_='PollingLocation', pretty_print=pretty_print)
        if self.Voter is not None:
            self.Voter.export(outfile, level, namespaceprefix_, name_='Voter', pretty_print=pretty_print)
        for VoterParticipation_ in self.VoterParticipation:
            VoterParticipation_.export(outfile, level, namespaceprefix_, name_='VoterParticipation', pretty_print=pretty_print)
        if self.VoterStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VoterStatus>%s</VoterStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VoterStatus), input_name='VoterStatus')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'District':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.District.append(obj_)
            obj_.original_tagname_ = 'District'
        elif nodeName_ == 'ElectionAdministration':
            obj_ = ElectionAdministration.factory()
            obj_.build(child_)
            self.ElectionAdministration = obj_
            obj_.original_tagname_ = 'ElectionAdministration'
        elif nodeName_ == 'HavaIdRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HavaIdRequired')
            self.HavaIdRequired = ival_
        elif nodeName_ == 'Locality':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.Locality.append(obj_)
            obj_.original_tagname_ = 'Locality'
        elif nodeName_ == 'OtherStatus':
            OtherStatus_ = child_.text
            OtherStatus_ = self.gds_validate_string(OtherStatus_, node, 'OtherStatus')
            self.OtherStatus = OtherStatus_
        elif nodeName_ == 'PollingLocation':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.PollingLocation = obj_
            obj_.original_tagname_ = 'PollingLocation'
        elif nodeName_ == 'Voter':
            obj_ = Voter.factory()
            obj_.build(child_)
            self.Voter = obj_
            obj_.original_tagname_ = 'Voter'
        elif nodeName_ == 'VoterParticipation':
            obj_ = VoterParticipation.factory()
            obj_.build(child_)
            self.VoterParticipation.append(obj_)
            obj_.original_tagname_ = 'VoterParticipation'
        elif nodeName_ == 'VoterStatus':
            VoterStatus_ = child_.text
            VoterStatus_ = self.gds_validate_string(VoterStatus_, node, 'VoterStatus')
            self.VoterStatus = VoterStatus_
            # validate type VoterStatus
            self.validate_VoterStatus(self.VoterStatus)
# end class VoterRecord


class VoterRecordsRequest(GeneratedsSuper):
    """The root element for request messages. For defining items pertaining
    to the status and type of the voter records request and when it
    was generated. VoterRecordsRequest includes the Subject
    association to specify various information about the voter in
    question. It includes the BallotRequest association to handle a
    request for an ballot; this request may be part of an FPCA form
    registration or may be submitted independently."""
    subclass = None
    superclass = None
    def __init__(self, AdditionalInfo=None, BallotRequest=None, Form=None, GeneratedDate=None, Issuer=None, OtherForm=None, OtherRequestMethod=None, OtherType=None, RequestHelper=None, RequestMethod=None, RequestProxy=None, SelectedLanguage=None, Subject=None, TransactionId=None, Type=None, VendorApplicationId=None):
        self.original_tagname_ = None
        if AdditionalInfo is None:
            self.AdditionalInfo = []
        else:
            self.AdditionalInfo = AdditionalInfo
        self.BallotRequest = BallotRequest
        self.Form = Form
        self.validate_RequestForm(self.Form)
        if isinstance(GeneratedDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(GeneratedDate, '%Y-%m-%d').date()
        else:
            initvalue_ = GeneratedDate
        self.GeneratedDate = initvalue_
        self.Issuer = Issuer
        self.OtherForm = OtherForm
        self.OtherRequestMethod = OtherRequestMethod
        self.OtherType = OtherType
        if RequestHelper is None:
            self.RequestHelper = []
        else:
            self.RequestHelper = RequestHelper
        self.RequestMethod = RequestMethod
        self.validate_RequestMethod(self.RequestMethod)
        self.RequestProxy = RequestProxy
        self.SelectedLanguage = SelectedLanguage
        self.Subject = Subject
        self.TransactionId = TransactionId
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        self.VendorApplicationId = VendorApplicationId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecordsRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecordsRequest.subclass:
            return VoterRecordsRequest.subclass(*args_, **kwargs_)
        else:
            return VoterRecordsRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdditionalInfo(self): return self.AdditionalInfo
    def set_AdditionalInfo(self, AdditionalInfo): self.AdditionalInfo = AdditionalInfo
    def add_AdditionalInfo(self, value): self.AdditionalInfo.append(value)
    def insert_AdditionalInfo_at(self, index, value): self.AdditionalInfo.insert(index, value)
    def replace_AdditionalInfo_at(self, index, value): self.AdditionalInfo[index] = value
    def get_BallotRequest(self): return self.BallotRequest
    def set_BallotRequest(self, BallotRequest): self.BallotRequest = BallotRequest
    def get_Form(self): return self.Form
    def set_Form(self, Form): self.Form = Form
    def get_GeneratedDate(self): return self.GeneratedDate
    def set_GeneratedDate(self, GeneratedDate): self.GeneratedDate = GeneratedDate
    def get_Issuer(self): return self.Issuer
    def set_Issuer(self, Issuer): self.Issuer = Issuer
    def get_OtherForm(self): return self.OtherForm
    def set_OtherForm(self, OtherForm): self.OtherForm = OtherForm
    def get_OtherRequestMethod(self): return self.OtherRequestMethod
    def set_OtherRequestMethod(self, OtherRequestMethod): self.OtherRequestMethod = OtherRequestMethod
    def get_OtherType(self): return self.OtherType
    def set_OtherType(self, OtherType): self.OtherType = OtherType
    def get_RequestHelper(self): return self.RequestHelper
    def set_RequestHelper(self, RequestHelper): self.RequestHelper = RequestHelper
    def add_RequestHelper(self, value): self.RequestHelper.append(value)
    def insert_RequestHelper_at(self, index, value): self.RequestHelper.insert(index, value)
    def replace_RequestHelper_at(self, index, value): self.RequestHelper[index] = value
    def get_RequestMethod(self): return self.RequestMethod
    def set_RequestMethod(self, RequestMethod): self.RequestMethod = RequestMethod
    def get_RequestProxy(self): return self.RequestProxy
    def set_RequestProxy(self, RequestProxy): self.RequestProxy = RequestProxy
    def get_SelectedLanguage(self): return self.SelectedLanguage
    def set_SelectedLanguage(self, SelectedLanguage): self.SelectedLanguage = SelectedLanguage
    def get_Subject(self): return self.Subject
    def set_Subject(self, Subject): self.Subject = Subject
    def get_TransactionId(self): return self.TransactionId
    def set_TransactionId(self, TransactionId): self.TransactionId = TransactionId
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type_at(self, index, value): self.Type.insert(index, value)
    def replace_Type_at(self, index, value): self.Type[index] = value
    def get_VendorApplicationId(self): return self.VendorApplicationId
    def set_VendorApplicationId(self, VendorApplicationId): self.VendorApplicationId = VendorApplicationId
    def validate_RequestForm(self, value):
        # Validate type RequestForm, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['fpca', 'nvra', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestForm' % {"value" : value.encode("utf-8")} )
    def validate_RequestMethod(self, value):
        # Validate type RequestMethod, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['armed-forces-recruitment-office', 'motor-vehicle-office', 'other-agency-designated-by-state', 'public-assistance-office', 'registration-drive-from-advocacy-group-or-political-party', 'state-funded-agency-serving-persons-with-disabilities', 'voter-via-election-registrars-office', 'voter-via-email', 'voter-via-fax', 'voter-via-internet', 'voter-via-mail', 'unknown', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RequestMethod' % {"value" : value.encode("utf-8")} )
    def validate_VoterRequestType(self, value):
        # Validate type VoterRequestType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ballot-request', 'lookup', 'registration', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VoterRequestType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.AdditionalInfo or
            self.BallotRequest is not None or
            self.Form is not None or
            self.GeneratedDate is not None or
            self.Issuer is not None or
            self.OtherForm is not None or
            self.OtherRequestMethod is not None or
            self.OtherType is not None or
            self.RequestHelper or
            self.RequestMethod is not None or
            self.RequestProxy is not None or
            self.SelectedLanguage is not None or
            self.Subject is not None or
            self.TransactionId is not None or
            self.Type or
            self.VendorApplicationId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecordsRequest', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecordsRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecordsRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecordsRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecordsRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecordsRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AdditionalInfo_ in self.AdditionalInfo:
            AdditionalInfo_.export(outfile, level, namespaceprefix_, name_='AdditionalInfo', pretty_print=pretty_print)
        if self.BallotRequest is not None:
            self.BallotRequest.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.Form is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Form>%s</Form>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Form), input_name='Form')), eol_))
        if self.GeneratedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<GeneratedDate>%s</GeneratedDate>%s' % (self.gds_format_date(self.GeneratedDate, input_name='GeneratedDate'), eol_))
        if self.Issuer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Issuer>%s</Issuer>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.Issuer), input_name='Issuer')), eol_))
        if self.OtherForm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherForm>%s</OtherForm>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherForm), input_name='OtherForm')), eol_))
        if self.OtherRequestMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherRequestMethod>%s</OtherRequestMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherRequestMethod), input_name='OtherRequestMethod')), eol_))
        if self.OtherType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<OtherType>%s</OtherType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OtherType), input_name='OtherType')), eol_))
        for RequestHelper_ in self.RequestHelper:
            RequestHelper_.export(outfile, level, namespaceprefix_, name_='RequestHelper', pretty_print=pretty_print)
        if self.RequestMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<RequestMethod>%s</RequestMethod>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RequestMethod), input_name='RequestMethod')), eol_))
        if self.RequestProxy is not None:
            self.RequestProxy.export(outfile, level, namespaceprefix_, name_='RequestProxy', pretty_print=pretty_print)
        if self.SelectedLanguage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<SelectedLanguage>%s</SelectedLanguage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SelectedLanguage), input_name='SelectedLanguage')), eol_))
        if self.Subject is not None:
            self.Subject.export(outfile, level, namespaceprefix_, name_='Subject', pretty_print=pretty_print)
        if self.TransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransactionId>%s</TransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionId), input_name='TransactionId')), eol_))
        for Type_ in self.Type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Type>%s</Type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Type_), input_name='Type')), eol_))
        if self.VendorApplicationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<VendorApplicationId>%s</VendorApplicationId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.VendorApplicationId), input_name='VendorApplicationId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdditionalInfo':
            obj_ = AdditionalInfo.factory()
            obj_.build(child_)
            self.AdditionalInfo.append(obj_)
            obj_.original_tagname_ = 'AdditionalInfo'
        elif nodeName_ == 'BallotRequest':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <BallotRequest> element')
            self.BallotRequest = obj_
            obj_.original_tagname_ = 'BallotRequest'
        elif nodeName_ == 'Form':
            Form_ = child_.text
            Form_ = self.gds_validate_string(Form_, node, 'Form')
            self.Form = Form_
            # validate type RequestForm
            self.validate_RequestForm(self.Form)
        elif nodeName_ == 'GeneratedDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.GeneratedDate = dval_
        elif nodeName_ == 'Issuer':
            Issuer_ = child_.text
            Issuer_ = self.gds_validate_string(Issuer_, node, 'Issuer')
            self.Issuer = Issuer_
        elif nodeName_ == 'OtherForm':
            OtherForm_ = child_.text
            OtherForm_ = self.gds_validate_string(OtherForm_, node, 'OtherForm')
            self.OtherForm = OtherForm_
        elif nodeName_ == 'OtherRequestMethod':
            OtherRequestMethod_ = child_.text
            OtherRequestMethod_ = self.gds_validate_string(OtherRequestMethod_, node, 'OtherRequestMethod')
            self.OtherRequestMethod = OtherRequestMethod_
        elif nodeName_ == 'OtherType':
            OtherType_ = child_.text
            OtherType_ = self.gds_validate_string(OtherType_, node, 'OtherType')
            self.OtherType = OtherType_
        elif nodeName_ == 'RequestHelper':
            obj_ = RequestHelper.factory()
            obj_.build(child_)
            self.RequestHelper.append(obj_)
            obj_.original_tagname_ = 'RequestHelper'
        elif nodeName_ == 'RequestMethod':
            RequestMethod_ = child_.text
            RequestMethod_ = self.gds_validate_string(RequestMethod_, node, 'RequestMethod')
            self.RequestMethod = RequestMethod_
            # validate type RequestMethod
            self.validate_RequestMethod(self.RequestMethod)
        elif nodeName_ == 'RequestProxy':
            obj_ = RequestProxy.factory()
            obj_.build(child_)
            self.RequestProxy = obj_
            obj_.original_tagname_ = 'RequestProxy'
        elif nodeName_ == 'SelectedLanguage':
            SelectedLanguage_ = child_.text
            SelectedLanguage_ = self.gds_validate_string(SelectedLanguage_, node, 'SelectedLanguage')
            self.SelectedLanguage = SelectedLanguage_
        elif nodeName_ == 'Subject':
            obj_ = Voter.factory()
            obj_.build(child_)
            self.Subject = obj_
            obj_.original_tagname_ = 'Subject'
        elif nodeName_ == 'TransactionId':
            TransactionId_ = child_.text
            TransactionId_ = self.gds_validate_string(TransactionId_, node, 'TransactionId')
            self.TransactionId = TransactionId_
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
            # validate type VoterRequestType
            self.validate_VoterRequestType(self.Type[-1])
        elif nodeName_ == 'VendorApplicationId':
            VendorApplicationId_ = child_.text
            VendorApplicationId_ = self.gds_validate_string(VendorApplicationId_, node, 'VendorApplicationId')
            self.VendorApplicationId = VendorApplicationId_
# end class VoterRecordsRequest


class VoterRecordsResponse(GeneratedsSuper):
    """The root element for response messages. For defining items
    pertaining to the status of a response to a voter records
    request. is an abstract element with three xsi:types that get
    used according to the type of response:  , used to indicate an
    acknowledgement only.  , used to indicate a failure and the
    type of failure.  , used to indication that a successful
    registration action occurred and the type of registration
    action, which may differ from the type of registration action
    requested. optionally includes the sub-element associated with
    the voter records request."""
    subclass = None
    superclass = None
    def __init__(self, TransactionId=None, extensiontype_=None):
        self.original_tagname_ = None
        self.TransactionId = TransactionId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecordsResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecordsResponse.subclass:
            return VoterRecordsResponse.subclass(*args_, **kwargs_)
        else:
            return VoterRecordsResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TransactionId(self): return self.TransactionId
    def set_TransactionId(self, TransactionId): self.TransactionId = TransactionId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.TransactionId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecordsResponse', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecordsResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecordsResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecordsResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecordsResponse'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecordsResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TransactionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<TransactionId>%s</TransactionId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.TransactionId), input_name='TransactionId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TransactionId':
            TransactionId_ = child_.text
            TransactionId_ = self.gds_validate_string(TransactionId_, node, 'TransactionId')
            self.TransactionId = TransactionId_
# end class VoterRecordsResponse


class NumberedThoroughfareAddress_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    Complete Address Number and a Complete Street Name. 2. In
    addition, all thoroughfare, landmark, and postal addresses must
    include a Place Name and a State Name. A Zip Code is recommended
    but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, CompleteAddressNumber=None, CompleteStreetName=None, CompleteSubaddress=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CompleteAddressNumber = CompleteAddressNumber
        self.CompleteStreetName = CompleteStreetName
        self.CompleteSubaddress = CompleteSubaddress
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        if PlaceStateZip is None:
            self.PlaceStateZip = []
        else:
            self.PlaceStateZip = PlaceStateZip
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberedThoroughfareAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberedThoroughfareAddress_type.subclass:
            return NumberedThoroughfareAddress_type.subclass(*args_, **kwargs_)
        else:
            return NumberedThoroughfareAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_CompleteStreetName(self): return self.CompleteStreetName
    def set_CompleteStreetName(self, CompleteStreetName): self.CompleteStreetName = CompleteStreetName
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def add_PlaceStateZip(self, value): self.PlaceStateZip.append(value)
    def insert_PlaceStateZip_at(self, index, value): self.PlaceStateZip.insert(index, value)
    def replace_PlaceStateZip_at(self, index, value): self.PlaceStateZip[index] = value
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.CompleteAddressNumber is not None or
            self.CompleteStreetName is not None or
            self.CompleteSubaddress is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='NumberedThoroughfareAddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumberedThoroughfareAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumberedThoroughfareAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='NumberedThoroughfareAddress_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='NumberedThoroughfareAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.CompleteAddressNumber is not None:
            self.CompleteAddressNumber.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
        if self.CompleteStreetName is not None:
            self.CompleteStreetName.export(outfile, level, namespaceprefix_, name_='CompleteStreetName', pretty_print=pretty_print)
        if self.CompleteSubaddress is not None:
            self.CompleteSubaddress.export(outfile, level, namespaceprefix_, name_='CompleteSubaddress', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        for PlaceStateZip_ in self.PlaceStateZip:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(PlaceStateZip_), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber = obj_
            obj_.original_tagname_ = 'CompleteAddressNumber'
        elif nodeName_ == 'CompleteStreetName':
            obj_ = CompleteStreetName_type.factory()
            obj_.build(child_)
            self.CompleteStreetName = obj_
            obj_.original_tagname_ = 'CompleteStreetName'
        elif nodeName_ == 'CompleteSubaddress':
            obj_ = CompleteSubaddress_type.factory()
            obj_.build(child_)
            self.CompleteSubaddress = obj_
            obj_.original_tagname_ = 'CompleteSubaddress'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip.append(PlaceStateZip_)
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip[-1])
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class NumberedThoroughfareAddress_type


class IntersectionAddress_type(GeneratedsSuper):
    """Defining Characteristics: 1. An address of this class must include
    two or more Complete Street Names, each separated by a Separator
    Element. 2. In addition, all thoroughfare, landmark, and postal
    addresses must include a Place Name and a State Name. A Zip Code
    is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, CornerOf=None, SeparatorElement=None, CompleteStreetName=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CornerOf = CornerOf
        self.validate_CornerOf_type(self.CornerOf)
        if SeparatorElement is None:
            self.SeparatorElement = []
        else:
            self.SeparatorElement = SeparatorElement
        if CompleteStreetName is None:
            self.CompleteStreetName = []
        else:
            self.CompleteStreetName = CompleteStreetName
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntersectionAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntersectionAddress_type.subclass:
            return IntersectionAddress_type.subclass(*args_, **kwargs_)
        else:
            return IntersectionAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CornerOf(self): return self.CornerOf
    def set_CornerOf(self, CornerOf): self.CornerOf = CornerOf
    def get_SeparatorElement(self): return self.SeparatorElement
    def set_SeparatorElement(self, SeparatorElement): self.SeparatorElement = SeparatorElement
    def add_SeparatorElement(self, value): self.SeparatorElement.append(value)
    def insert_SeparatorElement_at(self, index, value): self.SeparatorElement.insert(index, value)
    def replace_SeparatorElement_at(self, index, value): self.SeparatorElement[index] = value
    def get_CompleteStreetName(self): return self.CompleteStreetName
    def set_CompleteStreetName(self, CompleteStreetName): self.CompleteStreetName = CompleteStreetName
    def add_CompleteStreetName(self, value): self.CompleteStreetName.append(value)
    def insert_CompleteStreetName_at(self, index, value): self.CompleteStreetName.insert(index, value)
    def replace_CompleteStreetName_at(self, index, value): self.CompleteStreetName[index] = value
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_CornerOf_type(self, value):
        # Validate type CornerOf_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_Separator_type(self, value):
        # Validate type Separator_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Separator_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Separator_type_patterns_, ))
    validate_Separator_type_patterns_ = [['^.*$']]
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.CornerOf is not None or
            self.SeparatorElement or
            self.CompleteStreetName or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='IntersectionAddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntersectionAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntersectionAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='IntersectionAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='IntersectionAddress_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='IntersectionAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.CornerOf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CornerOf>%s</addr:CornerOf>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CornerOf), input_name='CornerOf')), eol_))
        for SeparatorElement_ in self.SeparatorElement:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:SeparatorElement>%s</addr:SeparatorElement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(SeparatorElement_), input_name='SeparatorElement')), eol_))
        for CompleteStreetName_ in self.CompleteStreetName:
            CompleteStreetName_.export(outfile, level, namespaceprefix_, name_='CompleteStreetName', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'CornerOf':
            CornerOf_ = child_.text
            CornerOf_ = self.gds_validate_string(CornerOf_, node, 'CornerOf')
            self.CornerOf = CornerOf_
            # validate type CornerOf_type
            self.validate_CornerOf_type(self.CornerOf)
        elif nodeName_ == 'SeparatorElement':
            SeparatorElement_ = child_.text
            SeparatorElement_ = self.gds_validate_string(SeparatorElement_, node, 'SeparatorElement')
            self.SeparatorElement.append(SeparatorElement_)
            # validate type Separator_type
            self.validate_Separator_type(self.SeparatorElement[-1])
        elif nodeName_ == 'CompleteStreetName':
            obj_ = CompleteStreetName_type.factory()
            obj_.build(child_)
            self.CompleteStreetName.append(obj_)
            obj_.original_tagname_ = 'CompleteStreetName'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class IntersectionAddress_type


class TwoNumberAddressRange_type(GeneratedsSuper):
    """Defining Characteristics 1. Addresses of this class must include two
    Complete Address Numbers separated by a hyphen. The first
    Complete Address Number must be less than or equal to the
    second. 2. The two Complete Address Numbers must be followed by
    a Complete Street Name. 3. In addition, all thoroughfare,
    landmark, and postal addresses must include a Place Name and a
    State Name. A Zip Code is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, SeparatorElement=None, CompleteAddressNumber=None, CompleteStreetName=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.SeparatorElement = SeparatorElement
        self.validate_Separator_type(self.SeparatorElement)
        self.CompleteAddressNumber = CompleteAddressNumber
        self.CompleteStreetName = CompleteStreetName
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        if PlaceStateZip is None:
            self.PlaceStateZip = []
        else:
            self.PlaceStateZip = PlaceStateZip
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TwoNumberAddressRange_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TwoNumberAddressRange_type.subclass:
            return TwoNumberAddressRange_type.subclass(*args_, **kwargs_)
        else:
            return TwoNumberAddressRange_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_SeparatorElement(self): return self.SeparatorElement
    def set_SeparatorElement(self, SeparatorElement): self.SeparatorElement = SeparatorElement
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_CompleteStreetName(self): return self.CompleteStreetName
    def set_CompleteStreetName(self, CompleteStreetName): self.CompleteStreetName = CompleteStreetName
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def add_PlaceStateZip(self, value): self.PlaceStateZip.append(value)
    def insert_PlaceStateZip_at(self, index, value): self.PlaceStateZip.insert(index, value)
    def replace_PlaceStateZip_at(self, index, value): self.PlaceStateZip[index] = value
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_Separator_type(self, value):
        # Validate type Separator_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Separator_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Separator_type_patterns_, ))
    validate_Separator_type_patterns_ = [['^.*$']]
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.SeparatorElement is not None or
            self.CompleteAddressNumber is not None or
            self.CompleteStreetName is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='TwoNumberAddressRange_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TwoNumberAddressRange_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TwoNumberAddressRange_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='TwoNumberAddressRange_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='TwoNumberAddressRange_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.SeparatorElement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:SeparatorElement>%s</addr:SeparatorElement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SeparatorElement), input_name='SeparatorElement')), eol_))
        if self.CompleteAddressNumber is not None:
            self.CompleteAddressNumber.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
        if self.CompleteStreetName is not None:
            self.CompleteStreetName.export(outfile, level, namespaceprefix_, name_='CompleteStreetName', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        for PlaceStateZip_ in self.PlaceStateZip:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(PlaceStateZip_), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'SeparatorElement':
            SeparatorElement_ = child_.text
            SeparatorElement_ = self.gds_validate_string(SeparatorElement_, node, 'SeparatorElement')
            self.SeparatorElement = SeparatorElement_
            # validate type Separator_type
            self.validate_Separator_type(self.SeparatorElement)
        elif nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber = obj_
            obj_.original_tagname_ = 'CompleteAddressNumber'
        elif nodeName_ == 'CompleteStreetName':
            obj_ = CompleteStreetName_type.factory()
            obj_.build(child_)
            self.CompleteStreetName = obj_
            obj_.original_tagname_ = 'CompleteStreetName'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip.append(PlaceStateZip_)
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip[-1])
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class TwoNumberAddressRange_type


class FourNumberAddressRange_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include
    four Complete Address Numbers, representing respectively the
    left low, left high, right low, and right high four Complete
    Address Numbers for the block or transportation segment(s),
    followed by a Complete Street Name. 2. In addition, all
    thoroughfare, landmark, and postal addresses must include a
    Place Name and a State Name. A ZIP Code is recommended but not
    mandatory. 3. The Four Number Address Range syntax follows the
    structure established by the U.S. Census Bureau for TIGER/Line
    file street segment address ranges (see
    http://www.census.gov/geo/www/tiger/tgrshp2008/TGRSHP08.pdf
    ("All Lines Shapefile" attribute table layout))."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, CompleteAddressNumber=None, SeparatorElement=None, CompleteStreetName=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CompleteAddressNumber = CompleteAddressNumber
        self.CompleteAddressNumber = CompleteAddressNumber
        self.SeparatorElement = SeparatorElement
        self.validate_Separator_type(self.SeparatorElement)
        self.CompleteAddressNumber = CompleteAddressNumber
        self.CompleteStreetName = CompleteStreetName
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FourNumberAddressRange_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FourNumberAddressRange_type.subclass:
            return FourNumberAddressRange_type.subclass(*args_, **kwargs_)
        else:
            return FourNumberAddressRange_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_SeparatorElement(self): return self.SeparatorElement
    def set_SeparatorElement(self, SeparatorElement): self.SeparatorElement = SeparatorElement
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_CompleteStreetName(self): return self.CompleteStreetName
    def set_CompleteStreetName(self, CompleteStreetName): self.CompleteStreetName = CompleteStreetName
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_Separator_type(self, value):
        # Validate type Separator_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_Separator_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_Separator_type_patterns_, ))
    validate_Separator_type_patterns_ = [['^.*$']]
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.CompleteAddressNumber is not None or
            self.CompleteAddressNumber is not None or
            self.SeparatorElement is not None or
            self.CompleteAddressNumber is not None or
            self.CompleteStreetName is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='FourNumberAddressRange_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FourNumberAddressRange_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FourNumberAddressRange_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='FourNumberAddressRange_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='FourNumberAddressRange_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='FourNumberAddressRange_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.CompleteAddressNumber is not None:
            self.CompleteAddressNumber.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
        if self.CompleteAddressNumber is not None:
            self.CompleteAddressNumber.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
        if self.SeparatorElement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:SeparatorElement>%s</addr:SeparatorElement>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SeparatorElement), input_name='SeparatorElement')), eol_))
        if self.CompleteAddressNumber is not None:
            self.CompleteAddressNumber.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
        if self.CompleteStreetName is not None:
            self.CompleteStreetName.export(outfile, level, namespaceprefix_, name_='CompleteStreetName', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber = obj_
            obj_.original_tagname_ = 'CompleteAddressNumber'
        elif nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber = obj_
            obj_.original_tagname_ = 'CompleteAddressNumber'
        elif nodeName_ == 'SeparatorElement':
            SeparatorElement_ = child_.text
            SeparatorElement_ = self.gds_validate_string(SeparatorElement_, node, 'SeparatorElement')
            self.SeparatorElement = SeparatorElement_
            # validate type Separator_type
            self.validate_Separator_type(self.SeparatorElement)
        elif nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber = obj_
            obj_.original_tagname_ = 'CompleteAddressNumber'
        elif nodeName_ == 'CompleteStreetName':
            obj_ = CompleteStreetName_type.factory()
            obj_.build(child_)
            self.CompleteStreetName = obj_
            obj_.original_tagname_ = 'CompleteStreetName'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class FourNumberAddressRange_type


class UnnumberedThoroughfareAddress_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must contain a
    Complete Street Name with no Complete Address Number preceding
    it. 2. In addition, all thoroughfare, landmark, and postal
    addresses must include a Place Name and a State Name. A Zip Code
    is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, CompleteStreetName=None, CompleteSubaddress=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CompleteStreetName = CompleteStreetName
        self.CompleteSubaddress = CompleteSubaddress
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnnumberedThoroughfareAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnnumberedThoroughfareAddress_type.subclass:
            return UnnumberedThoroughfareAddress_type.subclass(*args_, **kwargs_)
        else:
            return UnnumberedThoroughfareAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CompleteStreetName(self): return self.CompleteStreetName
    def set_CompleteStreetName(self, CompleteStreetName): self.CompleteStreetName = CompleteStreetName
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.CompleteStreetName is not None or
            self.CompleteSubaddress is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='UnnumberedThoroughfareAddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnnumberedThoroughfareAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='UnnumberedThoroughfareAddress_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='UnnumberedThoroughfareAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.CompleteStreetName is not None:
            self.CompleteStreetName.export(outfile, level, namespaceprefix_, name_='CompleteStreetName', pretty_print=pretty_print)
        if self.CompleteSubaddress is not None:
            self.CompleteSubaddress.export(outfile, level, namespaceprefix_, name_='CompleteSubaddress', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'CompleteStreetName':
            obj_ = CompleteStreetName_type.factory()
            obj_.build(child_)
            self.CompleteStreetName = obj_
            obj_.original_tagname_ = 'CompleteStreetName'
        elif nodeName_ == 'CompleteSubaddress':
            obj_ = CompleteSubaddress_type.factory()
            obj_.build(child_)
            self.CompleteSubaddress = obj_
            obj_.original_tagname_ = 'CompleteSubaddress'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class UnnumberedThoroughfareAddress_type


class LandmarkAddress_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    Complete Landmark Name, with no Complete Address Number
    preceding it and no Complete Street Name following it. 2. In
    addition, all thoroughfare, landmark, and postal addresses must
    include a Place Name and a State Name. A Zip Code is recommended
    but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteLandmarkName=None, CompleteSubaddress=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CompleteSubaddress = CompleteSubaddress
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LandmarkAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LandmarkAddress_type.subclass:
            return LandmarkAddress_type.subclass(*args_, **kwargs_)
        else:
            return LandmarkAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteLandmarkName is not None or
            self.CompleteSubaddress is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='LandmarkAddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LandmarkAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LandmarkAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='LandmarkAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='LandmarkAddress_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='LandmarkAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.CompleteSubaddress is not None:
            self.CompleteSubaddress.export(outfile, level, namespaceprefix_, name_='CompleteSubaddress', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'CompleteSubaddress':
            obj_ = CompleteSubaddress_type.factory()
            obj_.build(child_)
            self.CompleteSubaddress = obj_
            obj_.original_tagname_ = 'CompleteSubaddress'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class LandmarkAddress_type


class CommunityAddress_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    Complete Address Number followed by a Complete Landmark Name or
    a Complete Place Name, and they must not include a Complete
    Street Name. 2. In addition, all thoroughfare, landmark, and
    postal addresses must include a Place Name and a State Name. A
    Zip Code is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, CompleteAddressNumber=None, CompleteLandmarkName=None, CompleteSubaddress=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.CompleteAddressNumber = CompleteAddressNumber
        self.CompleteLandmarkName = CompleteLandmarkName
        self.CompleteSubaddress = CompleteSubaddress
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommunityAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommunityAddress_type.subclass:
            return CommunityAddress_type.subclass(*args_, **kwargs_)
        else:
            return CommunityAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def get_CompleteLandmarkName(self): return self.CompleteLandmarkName
    def set_CompleteLandmarkName(self, CompleteLandmarkName): self.CompleteLandmarkName = CompleteLandmarkName
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.CompleteAddressNumber is not None or
            self.CompleteLandmarkName is not None or
            self.CompleteSubaddress is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='CommunityAddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommunityAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommunityAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='CommunityAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='CommunityAddress_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='CommunityAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CompleteAddressNumber is not None:
            self.CompleteAddressNumber.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
        if self.CompleteLandmarkName is not None:
            self.CompleteLandmarkName.export(outfile, level, namespaceprefix_, name_='CompleteLandmarkName', pretty_print=pretty_print)
        if self.CompleteSubaddress is not None:
            self.CompleteSubaddress.export(outfile, level, namespaceprefix_, name_='CompleteSubaddress', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber = obj_
            obj_.original_tagname_ = 'CompleteAddressNumber'
        elif nodeName_ == 'CompleteLandmarkName':
            obj_ = CompleteLandmarkName_type.factory()
            obj_.build(child_)
            self.CompleteLandmarkName = obj_
            obj_.original_tagname_ = 'CompleteLandmarkName'
        elif nodeName_ == 'CompleteSubaddress':
            obj_ = CompleteSubaddress_type.factory()
            obj_.build(child_)
            self.CompleteSubaddress = obj_
            obj_.original_tagname_ = 'CompleteSubaddress'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class CommunityAddress_type


class USPSPostalDeliveryBox_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    Usps Box in the required format, and must not include a Usps
    Route. 2. In addition, all thoroughfare, landmark, and postal
    addresses must include a Place Name and a State Name. A Zip Code
    is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, USPSBox=None, CompleteSubaddress=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.USPSBox = USPSBox
        self.CompleteSubaddress = CompleteSubaddress
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSPostalDeliveryBox_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSPostalDeliveryBox_type.subclass:
            return USPSPostalDeliveryBox_type.subclass(*args_, **kwargs_)
        else:
            return USPSPostalDeliveryBox_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSBox(self): return self.USPSBox
    def set_USPSBox(self, USPSBox): self.USPSBox = USPSBox
    def get_CompleteSubaddress(self): return self.CompleteSubaddress
    def set_CompleteSubaddress(self, CompleteSubaddress): self.CompleteSubaddress = CompleteSubaddress
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.USPSBox is not None or
            self.CompleteSubaddress is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='USPSPostalDeliveryBox_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSPostalDeliveryBox_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSPostalDeliveryBox_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='USPSPostalDeliveryBox_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='USPSPostalDeliveryBox_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSBox is not None:
            self.USPSBox.export(outfile, level, namespaceprefix_, name_='USPSBox', pretty_print=pretty_print)
        if self.CompleteSubaddress is not None:
            self.CompleteSubaddress.export(outfile, level, namespaceprefix_, name_='CompleteSubaddress', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSBox':
            obj_ = USPSBox_type.factory()
            obj_.build(child_)
            self.USPSBox = obj_
            obj_.original_tagname_ = 'USPSBox'
        elif nodeName_ == 'CompleteSubaddress':
            obj_ = CompleteSubaddress_type.factory()
            obj_.build(child_)
            self.CompleteSubaddress = obj_
            obj_.original_tagname_ = 'CompleteSubaddress'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class USPSPostalDeliveryBox_type


class USPSPostalDeliveryRoute_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    Usps Address in the specified RR or HC or overseas military
    delivery format. 2. In addition, all thoroughfare, landmark, and
    postal addresses must include a Place Name and a State Name. A
    Zip Code is recommended but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, USPSAddress=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.USPSAddress = USPSAddress
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSPostalDeliveryRoute_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSPostalDeliveryRoute_type.subclass:
            return USPSPostalDeliveryRoute_type.subclass(*args_, **kwargs_)
        else:
            return USPSPostalDeliveryRoute_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSAddress(self): return self.USPSAddress
    def set_USPSAddress(self, USPSAddress): self.USPSAddress = USPSAddress
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.USPSAddress is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='USPSPostalDeliveryRoute_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSPostalDeliveryRoute_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSPostalDeliveryRoute_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='USPSPostalDeliveryRoute_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='USPSPostalDeliveryRoute_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSAddress is not None:
            self.USPSAddress.export(outfile, level, namespaceprefix_, name_='USPSAddress', pretty_print=pretty_print)
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSAddress':
            obj_ = USPSAddress_type.factory()
            obj_.build(child_)
            self.USPSAddress = obj_
            obj_.original_tagname_ = 'USPSAddress'
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class USPSPostalDeliveryRoute_type


class USPSGeneralDeliveryOffice_type(GeneratedsSuper):
    """Defining Characteristics: 1. Addresses of this class must include a
    USPSGeneral Delivery Point in the specified format. 2. In
    addition, all thoroughfare, landmark, and postal addresses must
    include a Place Name and a State Name. A Zip Code is recommended
    but not mandatory."""
    subclass = None
    superclass = None
    def __init__(self, action=None, USPSGeneralDeliveryPoint=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.USPSGeneralDeliveryPoint = USPSGeneralDeliveryPoint
        self.validate_USPSGeneralDeliveryPoint_type(self.USPSGeneralDeliveryPoint)
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSGeneralDeliveryOffice_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSGeneralDeliveryOffice_type.subclass:
            return USPSGeneralDeliveryOffice_type.subclass(*args_, **kwargs_)
        else:
            return USPSGeneralDeliveryOffice_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSGeneralDeliveryPoint(self): return self.USPSGeneralDeliveryPoint
    def set_USPSGeneralDeliveryPoint(self, USPSGeneralDeliveryPoint): self.USPSGeneralDeliveryPoint = USPSGeneralDeliveryPoint
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_USPSGeneralDeliveryPoint_type(self, value):
        # Validate type USPSGeneralDeliveryPoint_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_USPSGeneralDeliveryPoint_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_USPSGeneralDeliveryPoint_type_patterns_, ))
    validate_USPSGeneralDeliveryPoint_type_patterns_ = [['^.*$']]
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.USPSGeneralDeliveryPoint is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='USPSGeneralDeliveryOffice_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSGeneralDeliveryOffice_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='USPSGeneralDeliveryOffice_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='USPSGeneralDeliveryOffice_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSGeneralDeliveryPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USPSGeneralDeliveryPoint>%s</addr:USPSGeneralDeliveryPoint>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSGeneralDeliveryPoint), input_name='USPSGeneralDeliveryPoint')), eol_))
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSGeneralDeliveryPoint':
            USPSGeneralDeliveryPoint_ = child_.text
            USPSGeneralDeliveryPoint_ = self.gds_validate_string(USPSGeneralDeliveryPoint_, node, 'USPSGeneralDeliveryPoint')
            self.USPSGeneralDeliveryPoint = USPSGeneralDeliveryPoint_
            # validate type USPSGeneralDeliveryPoint_type
            self.validate_USPSGeneralDeliveryPoint_type(self.USPSGeneralDeliveryPoint)
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class USPSGeneralDeliveryOffice_type


class GeneralAddressClass_type(GeneratedsSuper):
    """Defining Characteristic: In addresses of this class the Delivery
    Address must be unparsed (except that in Types 2 and 3 the
    Complete Subaddress may be separated from the rest of the
    Delivery Address) and may contain thoroughfare, landmark, or
    postal syntaxes. This class may also include addresses that do
    not conform to any of the thoroughfare, landmark, or postal
    classes, including non-U.S. addresses."""
    subclass = None
    superclass = None
    def __init__(self, action=None, GeneralAddress=None, USPSGeneralDeliveryPoint=None, CompletePlaceName=None, StateName=None, ZipCode=None, ZipPlus4=None, CountryName=None, PlaceStateZip=None, AddressId=None, AddressAuthority=None, RelatedAddressId=None, AddressXCoordinate=None, AddressYCoordinate=None, AddressLongitude=None, AddressLatitude=None, USNationalGridCoordinate=None, AddressElevation=None, AddressCoordinateReferenceSystem=None, AddressParcelIdentifierSource=None, AddressParcelIdentifier=None, AddressTransportationSystemName=None, AddressTransportationSystemAuthority=None, AddressTransportationFeatureType=None, AddressTransportationFeatureID=None, RelatedTransportationFeatureID=None, AddressRangeType=None, AddressRangeParity=None, AddressRangeDirectionality=None, AddressRangeSpan=None, AddressClassification=None, AddressFeatureType=None, AddressLifecycleStatus=None, OfficialStatus=None, AddressAnomalyStatus=None, AddressSideOfStreet=None, AddressZLevel=None, LocationDescription=None, MailableAddress=None, AddressStartDate=None, AddressEndDate=None, DataSetID=None, AddressReferenceSystemId=None, AddressReferenceSystemAuthority=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.GeneralAddress = GeneralAddress
        self.USPSGeneralDeliveryPoint = USPSGeneralDeliveryPoint
        self.validate_USPSGeneralDeliveryPoint_type(self.USPSGeneralDeliveryPoint)
        self.CompletePlaceName = CompletePlaceName
        self.StateName = StateName
        self.validate_StateName_type(self.StateName)
        self.ZipCode = ZipCode
        self.validate_ZipCode_type(self.ZipCode)
        self.ZipPlus4 = ZipPlus4
        self.validate_ZipPlus4_type(self.ZipPlus4)
        self.CountryName = CountryName
        self.validate_CountryName_type(self.CountryName)
        self.PlaceStateZip = PlaceStateZip
        self.validate_PlaceStateZip_type(self.PlaceStateZip)
        self.AddressId = AddressId
        self.validate_AddressID_type(self.AddressId)
        self.AddressAuthority = AddressAuthority
        self.validate_AddressAuthority_type(self.AddressAuthority)
        self.RelatedAddressId = RelatedAddressId
        self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        self.AddressXCoordinate = AddressXCoordinate
        self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        self.AddressYCoordinate = AddressYCoordinate
        self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        self.AddressLongitude = AddressLongitude
        self.validate_AddressLongitude_type(self.AddressLongitude)
        self.AddressLatitude = AddressLatitude
        self.validate_AddressLatitude_type(self.AddressLatitude)
        self.USNationalGridCoordinate = USNationalGridCoordinate
        self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        self.AddressElevation = AddressElevation
        self.validate_AddressElevation_type(self.AddressElevation)
        self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
        self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
        self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        self.AddressParcelIdentifier = AddressParcelIdentifier
        self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        self.AddressTransportationSystemName = AddressTransportationSystemName
        self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
        self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        self.AddressTransportationFeatureType = AddressTransportationFeatureType
        self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        self.AddressTransportationFeatureID = AddressTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
        self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        self.AddressRangeType = AddressRangeType
        self.validate_AddressRangeType_type(self.AddressRangeType)
        self.AddressRangeParity = AddressRangeParity
        self.validate_AddressRangeParity_type(self.AddressRangeParity)
        self.AddressRangeDirectionality = AddressRangeDirectionality
        self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        self.AddressRangeSpan = AddressRangeSpan
        self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        self.AddressClassification = AddressClassification
        self.validate_AddressClassification_type(self.AddressClassification)
        self.AddressFeatureType = AddressFeatureType
        self.validate_AddressFeatureType_type(self.AddressFeatureType)
        self.AddressLifecycleStatus = AddressLifecycleStatus
        self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        self.OfficialStatus = OfficialStatus
        self.validate_OfficialStatus_type(self.OfficialStatus)
        self.AddressAnomalyStatus = AddressAnomalyStatus
        self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        self.AddressSideOfStreet = AddressSideOfStreet
        self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        self.AddressZLevel = AddressZLevel
        self.validate_AddressZLevel_type(self.AddressZLevel)
        self.LocationDescription = LocationDescription
        self.validate_LocationDescription_type(self.LocationDescription)
        self.MailableAddress = MailableAddress
        self.validate_MailableAddress_type(self.MailableAddress)
        if isinstance(AddressStartDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressStartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressStartDate
        self.AddressStartDate = initvalue_
        if isinstance(AddressEndDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(AddressEndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = AddressEndDate
        self.AddressEndDate = initvalue_
        self.DataSetID = DataSetID
        self.validate_DataSetID_type(self.DataSetID)
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralAddressClass_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralAddressClass_type.subclass:
            return GeneralAddressClass_type.subclass(*args_, **kwargs_)
        else:
            return GeneralAddressClass_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeneralAddress(self): return self.GeneralAddress
    def set_GeneralAddress(self, GeneralAddress): self.GeneralAddress = GeneralAddress
    def get_USPSGeneralDeliveryPoint(self): return self.USPSGeneralDeliveryPoint
    def set_USPSGeneralDeliveryPoint(self, USPSGeneralDeliveryPoint): self.USPSGeneralDeliveryPoint = USPSGeneralDeliveryPoint
    def get_CompletePlaceName(self): return self.CompletePlaceName
    def set_CompletePlaceName(self, CompletePlaceName): self.CompletePlaceName = CompletePlaceName
    def get_StateName(self): return self.StateName
    def set_StateName(self, StateName): self.StateName = StateName
    def get_ZipCode(self): return self.ZipCode
    def set_ZipCode(self, ZipCode): self.ZipCode = ZipCode
    def get_ZipPlus4(self): return self.ZipPlus4
    def set_ZipPlus4(self, ZipPlus4): self.ZipPlus4 = ZipPlus4
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_PlaceStateZip(self): return self.PlaceStateZip
    def set_PlaceStateZip(self, PlaceStateZip): self.PlaceStateZip = PlaceStateZip
    def get_AddressId(self): return self.AddressId
    def set_AddressId(self, AddressId): self.AddressId = AddressId
    def get_AddressAuthority(self): return self.AddressAuthority
    def set_AddressAuthority(self, AddressAuthority): self.AddressAuthority = AddressAuthority
    def get_RelatedAddressId(self): return self.RelatedAddressId
    def set_RelatedAddressId(self, RelatedAddressId): self.RelatedAddressId = RelatedAddressId
    def get_AddressXCoordinate(self): return self.AddressXCoordinate
    def set_AddressXCoordinate(self, AddressXCoordinate): self.AddressXCoordinate = AddressXCoordinate
    def get_AddressYCoordinate(self): return self.AddressYCoordinate
    def set_AddressYCoordinate(self, AddressYCoordinate): self.AddressYCoordinate = AddressYCoordinate
    def get_AddressLongitude(self): return self.AddressLongitude
    def set_AddressLongitude(self, AddressLongitude): self.AddressLongitude = AddressLongitude
    def get_AddressLatitude(self): return self.AddressLatitude
    def set_AddressLatitude(self, AddressLatitude): self.AddressLatitude = AddressLatitude
    def get_USNationalGridCoordinate(self): return self.USNationalGridCoordinate
    def set_USNationalGridCoordinate(self, USNationalGridCoordinate): self.USNationalGridCoordinate = USNationalGridCoordinate
    def get_AddressElevation(self): return self.AddressElevation
    def set_AddressElevation(self, AddressElevation): self.AddressElevation = AddressElevation
    def get_AddressCoordinateReferenceSystem(self): return self.AddressCoordinateReferenceSystem
    def set_AddressCoordinateReferenceSystem(self, AddressCoordinateReferenceSystem): self.AddressCoordinateReferenceSystem = AddressCoordinateReferenceSystem
    def get_AddressParcelIdentifierSource(self): return self.AddressParcelIdentifierSource
    def set_AddressParcelIdentifierSource(self, AddressParcelIdentifierSource): self.AddressParcelIdentifierSource = AddressParcelIdentifierSource
    def get_AddressParcelIdentifier(self): return self.AddressParcelIdentifier
    def set_AddressParcelIdentifier(self, AddressParcelIdentifier): self.AddressParcelIdentifier = AddressParcelIdentifier
    def get_AddressTransportationSystemName(self): return self.AddressTransportationSystemName
    def set_AddressTransportationSystemName(self, AddressTransportationSystemName): self.AddressTransportationSystemName = AddressTransportationSystemName
    def get_AddressTransportationSystemAuthority(self): return self.AddressTransportationSystemAuthority
    def set_AddressTransportationSystemAuthority(self, AddressTransportationSystemAuthority): self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority
    def get_AddressTransportationFeatureType(self): return self.AddressTransportationFeatureType
    def set_AddressTransportationFeatureType(self, AddressTransportationFeatureType): self.AddressTransportationFeatureType = AddressTransportationFeatureType
    def get_AddressTransportationFeatureID(self): return self.AddressTransportationFeatureID
    def set_AddressTransportationFeatureID(self, AddressTransportationFeatureID): self.AddressTransportationFeatureID = AddressTransportationFeatureID
    def get_RelatedTransportationFeatureID(self): return self.RelatedTransportationFeatureID
    def set_RelatedTransportationFeatureID(self, RelatedTransportationFeatureID): self.RelatedTransportationFeatureID = RelatedTransportationFeatureID
    def get_AddressRangeType(self): return self.AddressRangeType
    def set_AddressRangeType(self, AddressRangeType): self.AddressRangeType = AddressRangeType
    def get_AddressRangeParity(self): return self.AddressRangeParity
    def set_AddressRangeParity(self, AddressRangeParity): self.AddressRangeParity = AddressRangeParity
    def get_AddressRangeDirectionality(self): return self.AddressRangeDirectionality
    def set_AddressRangeDirectionality(self, AddressRangeDirectionality): self.AddressRangeDirectionality = AddressRangeDirectionality
    def get_AddressRangeSpan(self): return self.AddressRangeSpan
    def set_AddressRangeSpan(self, AddressRangeSpan): self.AddressRangeSpan = AddressRangeSpan
    def get_AddressClassification(self): return self.AddressClassification
    def set_AddressClassification(self, AddressClassification): self.AddressClassification = AddressClassification
    def get_AddressFeatureType(self): return self.AddressFeatureType
    def set_AddressFeatureType(self, AddressFeatureType): self.AddressFeatureType = AddressFeatureType
    def get_AddressLifecycleStatus(self): return self.AddressLifecycleStatus
    def set_AddressLifecycleStatus(self, AddressLifecycleStatus): self.AddressLifecycleStatus = AddressLifecycleStatus
    def get_OfficialStatus(self): return self.OfficialStatus
    def set_OfficialStatus(self, OfficialStatus): self.OfficialStatus = OfficialStatus
    def get_AddressAnomalyStatus(self): return self.AddressAnomalyStatus
    def set_AddressAnomalyStatus(self, AddressAnomalyStatus): self.AddressAnomalyStatus = AddressAnomalyStatus
    def get_AddressSideOfStreet(self): return self.AddressSideOfStreet
    def set_AddressSideOfStreet(self, AddressSideOfStreet): self.AddressSideOfStreet = AddressSideOfStreet
    def get_AddressZLevel(self): return self.AddressZLevel
    def set_AddressZLevel(self, AddressZLevel): self.AddressZLevel = AddressZLevel
    def get_LocationDescription(self): return self.LocationDescription
    def set_LocationDescription(self, LocationDescription): self.LocationDescription = LocationDescription
    def get_MailableAddress(self): return self.MailableAddress
    def set_MailableAddress(self, MailableAddress): self.MailableAddress = MailableAddress
    def get_AddressStartDate(self): return self.AddressStartDate
    def set_AddressStartDate(self, AddressStartDate): self.AddressStartDate = AddressStartDate
    def get_AddressEndDate(self): return self.AddressEndDate
    def set_AddressEndDate(self, AddressEndDate): self.AddressEndDate = AddressEndDate
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def validate_USPSGeneralDeliveryPoint_type(self, value):
        # Validate type USPSGeneralDeliveryPoint_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_USPSGeneralDeliveryPoint_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_USPSGeneralDeliveryPoint_type_patterns_, ))
    validate_USPSGeneralDeliveryPoint_type_patterns_ = [['^.*$']]
    def validate_StateName_type(self, value):
        # Validate type StateName_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StateName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StateName_type_patterns_, ))
    validate_StateName_type_patterns_ = [['^.*$']]
    def validate_ZipCode_type(self, value):
        # Validate type ZipCode_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipCode_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipCode_type_patterns_, ))
    validate_ZipCode_type_patterns_ = [['^[0-9]{5}$']]
    def validate_ZipPlus4_type(self, value):
        # Validate type ZipPlus4_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ZipPlus4_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ZipPlus4_type_patterns_, ))
    validate_ZipPlus4_type_patterns_ = [['^[0-9]{4}$']]
    def validate_CountryName_type(self, value):
        # Validate type CountryName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_PlaceStateZip_type(self, value):
        # Validate type PlaceStateZip_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_PlaceStateZip_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_PlaceStateZip_type_patterns_, ))
    validate_PlaceStateZip_type_patterns_ = [['^.*$']]
    def validate_AddressID_type(self, value):
        # Validate type AddressID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressID_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressID_type_patterns_, ))
    validate_AddressID_type_patterns_ = [['^.*$']]
    def validate_AddressAuthority_type(self, value):
        # Validate type AddressAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressAuthority_type_patterns_, ))
    validate_AddressAuthority_type_patterns_ = [['^.*$']]
    def validate_AssociatedAddressId_type(self, value):
        # Validate type AssociatedAddressId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AssociatedAddressId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AssociatedAddressId_type_patterns_, ))
    validate_AssociatedAddressId_type_patterns_ = [['^.*$']]
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressElevation_type(self, value):
        # Validate type AddressElevation_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressParcelIdentifierSource_type(self, value):
        # Validate type AddressParcelIdentifierSource_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifierSource_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifierSource_type_patterns_, ))
    validate_AddressParcelIdentifierSource_type_patterns_ = [['^.*$']]
    def validate_AddressParcelIdentifier_type(self, value):
        # Validate type AddressParcelIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressParcelIdentifier_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressParcelIdentifier_type_patterns_, ))
    validate_AddressParcelIdentifier_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemName_type(self, value):
        # Validate type AddressTransportationSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemName_type_patterns_, ))
    validate_AddressTransportationSystemName_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationSystemAuthority_type(self, value):
        # Validate type AddressTransportationSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationSystemAuthority_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationSystemAuthority_type_patterns_, ))
    validate_AddressTransportationSystemAuthority_type_patterns_ = [['^.*$']]
    def validate_AddressTransportationFeatureType_type(self, value):
        # Validate type AddressTransportationFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressTransportationFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressTransportationFeatureType_type_patterns_, ))
    validate_AddressTransportationFeatureType_type_patterns_ = [['^.*$']]
    def validate_AddressRangeType_type(self, value):
        # Validate type AddressRangeType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Actual', 'Potential', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeParity_type(self, value):
        # Validate type AddressRangeParity_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['even', 'odd', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeParity_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeParity_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeParity_type_patterns_, ))
    validate_AddressRangeParity_type_patterns_ = [['^.*$']]
    def validate_AddressRangeDirectionality_type(self, value):
        # Validate type AddressRangeDirectionality_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['With', 'Against', 'With-Against', 'Against-With', 'Null', 'NA', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeDirectionality_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressRangeSpan_type(self, value):
        # Validate type AddressRangeSpan_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Partial Segment', 'Single Segment', 'Multi Segment', 'Entire Street', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressRangeSpan_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressRangeSpan_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressRangeSpan_type_patterns_, ))
    validate_AddressRangeSpan_type_patterns_ = [['^.+$']]
    def validate_AddressClassification_type(self, value):
        # Validate type AddressClassification_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NumberedThoroughfareAddress', 'IntersectionAddress', 'TwoNumberAddressRange', 'FourNumberAddressRange', 'UnnumberedThoroughfareAddress', 'LandmarkAddress', 'CommunityAddress', 'USPSPostalDeliveryBox', 'USPSPostal DeliveryRoute', 'USPSGeneral DeliveryOffice', 'GeneralAddressClass']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressClassification_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressFeatureType_type(self, value):
        # Validate type AddressFeatureType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressFeatureType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressFeatureType_type_patterns_, ))
    validate_AddressFeatureType_type_patterns_ = [['^.+$']]
    def validate_AddressLifecycleStatus_type(self, value):
        # Validate type AddressLifecycleStatus_type, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Potential', 'Proposed', 'Active', 'Retired']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressLifecycleStatus_type' % {"value" : value.encode("utf-8")} )
    def validate_OfficialStatus_type(self, value):
        # Validate type OfficialStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Official', 'Alternate or Alias', 'Official Alternate or Alias', 'Official Renaming Action of the Address Authority', 'Alternates Established by an Address Authority', 'Unofficial Alternate or Alias', 'Alternate Names Established by Colloquial Use in a Community', 'Unofficial Alternate Names Frequently Encountered', 'Unofficial Alternate Names In Use by an Agency or Entity', 'Posted or Vanity Address', 'Verified Invalid']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OfficialStatus_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_OfficialStatus_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_OfficialStatus_type_patterns_, ))
    validate_OfficialStatus_type_patterns_ = [['^.*$']]
    def validate_AddressAnomalyStatus_type(self, value):
        # Validate type AddressAnomalyStatus_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressSideOfStreet_type(self, value):
        # Validate type AddressSideOfStreet_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['right', 'left', 'both', 'none', 'unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressSideOfStreet_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressSideOfStreet_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressSideOfStreet_type_patterns_, ))
    validate_AddressSideOfStreet_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def validate_LocationDescription_type(self, value):
        # Validate type LocationDescription_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_MailableAddress_type(self, value):
        # Validate type MailableAddress_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Yes', 'No', 'Unknown']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MailableAddress_type' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_MailableAddress_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_MailableAddress_type_patterns_, ))
    validate_MailableAddress_type_patterns_ = [['^.*$']]
    def validate_AddressStartDate_type(self, value):
        # Validate type AddressStartDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressEndDate_type(self, value):
        # Validate type AddressEndDate_type, a restriction on xsd:date.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_DataSetID_type(self, value):
        # Validate type DataSetID_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.GeneralAddress is not None or
            self.USPSGeneralDeliveryPoint is not None or
            self.CompletePlaceName is not None or
            self.StateName is not None or
            self.ZipCode is not None or
            self.ZipPlus4 is not None or
            self.CountryName is not None or
            self.PlaceStateZip is not None or
            self.AddressId is not None or
            self.AddressAuthority is not None or
            self.RelatedAddressId is not None or
            self.AddressXCoordinate is not None or
            self.AddressYCoordinate is not None or
            self.AddressLongitude is not None or
            self.AddressLatitude is not None or
            self.USNationalGridCoordinate is not None or
            self.AddressElevation is not None or
            self.AddressCoordinateReferenceSystem is not None or
            self.AddressParcelIdentifierSource is not None or
            self.AddressParcelIdentifier is not None or
            self.AddressTransportationSystemName is not None or
            self.AddressTransportationSystemAuthority is not None or
            self.AddressTransportationFeatureType is not None or
            self.AddressTransportationFeatureID is not None or
            self.RelatedTransportationFeatureID is not None or
            self.AddressRangeType is not None or
            self.AddressRangeParity is not None or
            self.AddressRangeDirectionality is not None or
            self.AddressRangeSpan is not None or
            self.AddressClassification is not None or
            self.AddressFeatureType is not None or
            self.AddressLifecycleStatus is not None or
            self.OfficialStatus is not None or
            self.AddressAnomalyStatus is not None or
            self.AddressSideOfStreet is not None or
            self.AddressZLevel is not None or
            self.LocationDescription is not None or
            self.MailableAddress is not None or
            self.AddressStartDate is not None or
            self.AddressEndDate is not None or
            self.DataSetID is not None or
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='GeneralAddressClass_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralAddressClass_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralAddressClass_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='GeneralAddressClass_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='GeneralAddressClass_type'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='GeneralAddressClass_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GeneralAddress is not None:
            self.GeneralAddress.export(outfile, level, namespaceprefix_, name_='GeneralAddress', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USPSGeneralDeliveryPoint>%s</addr:USPSGeneralDeliveryPoint>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSGeneralDeliveryPoint), input_name='USPSGeneralDeliveryPoint')), eol_))
        if self.CompletePlaceName is not None:
            self.CompletePlaceName.export(outfile, level, namespaceprefix_, name_='CompletePlaceName', pretty_print=pretty_print)
        if self.StateName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StateName>%s</addr:StateName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StateName), input_name='StateName')), eol_))
        if self.ZipCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipCode>%s</addr:ZipCode>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipCode), input_name='ZipCode')), eol_))
        if self.ZipPlus4 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:ZipPlus4>%s</addr:ZipPlus4>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ZipPlus4), input_name='ZipPlus4')), eol_))
        if self.CountryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:CountryName>%s</addr:CountryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CountryName), input_name='CountryName')), eol_))
        if self.PlaceStateZip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:PlaceStateZip>%s</addr:PlaceStateZip>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.PlaceStateZip), input_name='PlaceStateZip')), eol_))
        if self.AddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressId>%s</addr:AddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressId), input_name='AddressId')), eol_))
        if self.AddressAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAuthority>%s</addr:AddressAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAuthority), input_name='AddressAuthority')), eol_))
        if self.RelatedAddressId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedAddressId>%s</addr:RelatedAddressId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedAddressId), input_name='RelatedAddressId')), eol_))
        if self.AddressXCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressXCoordinate>%s</addr:AddressXCoordinate>%s' % (self.gds_format_double(self.AddressXCoordinate, input_name='AddressXCoordinate'), eol_))
        if self.AddressYCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressYCoordinate>%s</addr:AddressYCoordinate>%s' % (self.gds_format_double(self.AddressYCoordinate, input_name='AddressYCoordinate'), eol_))
        if self.AddressLongitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLongitude>%s</addr:AddressLongitude>%s' % (self.gds_format_double(self.AddressLongitude, input_name='AddressLongitude'), eol_))
        if self.AddressLatitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLatitude>%s</addr:AddressLatitude>%s' % (self.gds_format_double(self.AddressLatitude, input_name='AddressLatitude'), eol_))
        if self.USNationalGridCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNationalGridCoordinate>%s</addr:USNationalGridCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNationalGridCoordinate), input_name='USNationalGridCoordinate')), eol_))
        if self.AddressElevation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressElevation>%s</addr:AddressElevation>%s' % (self.gds_format_double(self.AddressElevation, input_name='AddressElevation'), eol_))
        if self.AddressCoordinateReferenceSystem is not None:
            self.AddressCoordinateReferenceSystem.export(outfile, level, namespaceprefix_, name_='AddressCoordinateReferenceSystem', pretty_print=pretty_print)
        if self.AddressParcelIdentifierSource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifierSource>%s</addr:AddressParcelIdentifierSource>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifierSource), input_name='AddressParcelIdentifierSource')), eol_))
        if self.AddressParcelIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressParcelIdentifier>%s</addr:AddressParcelIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressParcelIdentifier), input_name='AddressParcelIdentifier')), eol_))
        if self.AddressTransportationSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemName>%s</addr:AddressTransportationSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemName), input_name='AddressTransportationSystemName')), eol_))
        if self.AddressTransportationSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationSystemAuthority>%s</addr:AddressTransportationSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationSystemAuthority), input_name='AddressTransportationSystemAuthority')), eol_))
        if self.AddressTransportationFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureType>%s</addr:AddressTransportationFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureType), input_name='AddressTransportationFeatureType')), eol_))
        if self.AddressTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressTransportationFeatureID>%s</addr:AddressTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressTransportationFeatureID), input_name='AddressTransportationFeatureID')), eol_))
        if self.RelatedTransportationFeatureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:RelatedTransportationFeatureID>%s</addr:RelatedTransportationFeatureID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.RelatedTransportationFeatureID), input_name='RelatedTransportationFeatureID')), eol_))
        if self.AddressRangeType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeType>%s</addr:AddressRangeType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeType), input_name='AddressRangeType')), eol_))
        if self.AddressRangeParity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeParity>%s</addr:AddressRangeParity>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeParity), input_name='AddressRangeParity')), eol_))
        if self.AddressRangeDirectionality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeDirectionality>%s</addr:AddressRangeDirectionality>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeDirectionality), input_name='AddressRangeDirectionality')), eol_))
        if self.AddressRangeSpan is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressRangeSpan>%s</addr:AddressRangeSpan>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressRangeSpan), input_name='AddressRangeSpan')), eol_))
        if self.AddressClassification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressClassification>%s</addr:AddressClassification>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressClassification), input_name='AddressClassification')), eol_))
        if self.AddressFeatureType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressFeatureType>%s</addr:AddressFeatureType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressFeatureType), input_name='AddressFeatureType')), eol_))
        if self.AddressLifecycleStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressLifecycleStatus>%s</addr:AddressLifecycleStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressLifecycleStatus), input_name='AddressLifecycleStatus')), eol_))
        if self.OfficialStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:OfficialStatus>%s</addr:OfficialStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.OfficialStatus), input_name='OfficialStatus')), eol_))
        if self.AddressAnomalyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressAnomalyStatus>%s</addr:AddressAnomalyStatus>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressAnomalyStatus), input_name='AddressAnomalyStatus')), eol_))
        if self.AddressSideOfStreet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressSideOfStreet>%s</addr:AddressSideOfStreet>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressSideOfStreet), input_name='AddressSideOfStreet')), eol_))
        if self.AddressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressZLevel>%s</addr:AddressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressZLevel), input_name='AddressZLevel')), eol_))
        if self.LocationDescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:LocationDescription>%s</addr:LocationDescription>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.LocationDescription), input_name='LocationDescription')), eol_))
        if self.MailableAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:MailableAddress>%s</addr:MailableAddress>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.MailableAddress), input_name='MailableAddress')), eol_))
        if self.AddressStartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressStartDate>%s</addr:AddressStartDate>%s' % (self.gds_format_date(self.AddressStartDate, input_name='AddressStartDate'), eol_))
        if self.AddressEndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressEndDate>%s</addr:AddressEndDate>%s' % (self.gds_format_date(self.AddressEndDate, input_name='AddressEndDate'), eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:DataSetID>%s</addr:DataSetID>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.DataSetID), input_name='DataSetID')), eol_))
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeneralAddress':
            obj_ = GeneralAddress_type.factory()
            obj_.build(child_)
            self.GeneralAddress = obj_
            obj_.original_tagname_ = 'GeneralAddress'
        elif nodeName_ == 'USPSGeneralDeliveryPoint':
            USPSGeneralDeliveryPoint_ = child_.text
            USPSGeneralDeliveryPoint_ = self.gds_validate_string(USPSGeneralDeliveryPoint_, node, 'USPSGeneralDeliveryPoint')
            self.USPSGeneralDeliveryPoint = USPSGeneralDeliveryPoint_
            # validate type USPSGeneralDeliveryPoint_type
            self.validate_USPSGeneralDeliveryPoint_type(self.USPSGeneralDeliveryPoint)
        elif nodeName_ == 'CompletePlaceName':
            obj_ = CompletePlaceName_type.factory()
            obj_.build(child_)
            self.CompletePlaceName = obj_
            obj_.original_tagname_ = 'CompletePlaceName'
        elif nodeName_ == 'StateName':
            StateName_ = child_.text
            if StateName_:
                StateName_ = re_.sub(String_cleanup_pat_, " ", StateName_).strip()
            else:
                StateName_ = ""
            StateName_ = self.gds_validate_string(StateName_, node, 'StateName')
            self.StateName = StateName_
            # validate type StateName_type
            self.validate_StateName_type(self.StateName)
        elif nodeName_ == 'ZipCode':
            ZipCode_ = child_.text
            ZipCode_ = self.gds_validate_string(ZipCode_, node, 'ZipCode')
            self.ZipCode = ZipCode_
            # validate type ZipCode_type
            self.validate_ZipCode_type(self.ZipCode)
        elif nodeName_ == 'ZipPlus4':
            ZipPlus4_ = child_.text
            ZipPlus4_ = self.gds_validate_string(ZipPlus4_, node, 'ZipPlus4')
            self.ZipPlus4 = ZipPlus4_
            # validate type ZipPlus4_type
            self.validate_ZipPlus4_type(self.ZipPlus4)
        elif nodeName_ == 'CountryName':
            CountryName_ = child_.text
            CountryName_ = self.gds_validate_string(CountryName_, node, 'CountryName')
            self.CountryName = CountryName_
            # validate type CountryName_type
            self.validate_CountryName_type(self.CountryName)
        elif nodeName_ == 'PlaceStateZip':
            PlaceStateZip_ = child_.text
            PlaceStateZip_ = self.gds_validate_string(PlaceStateZip_, node, 'PlaceStateZip')
            self.PlaceStateZip = PlaceStateZip_
            # validate type PlaceStateZip_type
            self.validate_PlaceStateZip_type(self.PlaceStateZip)
        elif nodeName_ == 'AddressId':
            AddressId_ = child_.text
            AddressId_ = self.gds_validate_string(AddressId_, node, 'AddressId')
            self.AddressId = AddressId_
            # validate type AddressID_type
            self.validate_AddressID_type(self.AddressId)
        elif nodeName_ == 'AddressAuthority':
            AddressAuthority_ = child_.text
            AddressAuthority_ = self.gds_validate_string(AddressAuthority_, node, 'AddressAuthority')
            self.AddressAuthority = AddressAuthority_
            # validate type AddressAuthority_type
            self.validate_AddressAuthority_type(self.AddressAuthority)
        elif nodeName_ == 'RelatedAddressId':
            RelatedAddressId_ = child_.text
            RelatedAddressId_ = self.gds_validate_string(RelatedAddressId_, node, 'RelatedAddressId')
            self.RelatedAddressId = RelatedAddressId_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedAddressId)
        elif nodeName_ == 'AddressXCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressXCoordinate')
            self.AddressXCoordinate = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.AddressXCoordinate)
        elif nodeName_ == 'AddressYCoordinate' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressYCoordinate')
            self.AddressYCoordinate = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.AddressYCoordinate)
        elif nodeName_ == 'AddressLongitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLongitude')
            self.AddressLongitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.AddressLongitude)
        elif nodeName_ == 'AddressLatitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressLatitude')
            self.AddressLatitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.AddressLatitude)
        elif nodeName_ == 'USNationalGridCoordinate':
            USNationalGridCoordinate_ = child_.text
            USNationalGridCoordinate_ = self.gds_validate_string(USNationalGridCoordinate_, node, 'USNationalGridCoordinate')
            self.USNationalGridCoordinate = USNationalGridCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNationalGridCoordinate)
        elif nodeName_ == 'AddressElevation' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'AddressElevation')
            self.AddressElevation = fval_
            # validate type AddressElevation_type
            self.validate_AddressElevation_type(self.AddressElevation)
        elif nodeName_ == 'AddressCoordinateReferenceSystem':
            obj_ = AddressCoordinateReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressCoordinateReferenceSystem = obj_
            obj_.original_tagname_ = 'AddressCoordinateReferenceSystem'
        elif nodeName_ == 'AddressParcelIdentifierSource':
            AddressParcelIdentifierSource_ = child_.text
            AddressParcelIdentifierSource_ = self.gds_validate_string(AddressParcelIdentifierSource_, node, 'AddressParcelIdentifierSource')
            self.AddressParcelIdentifierSource = AddressParcelIdentifierSource_
            # validate type AddressParcelIdentifierSource_type
            self.validate_AddressParcelIdentifierSource_type(self.AddressParcelIdentifierSource)
        elif nodeName_ == 'AddressParcelIdentifier':
            AddressParcelIdentifier_ = child_.text
            AddressParcelIdentifier_ = self.gds_validate_string(AddressParcelIdentifier_, node, 'AddressParcelIdentifier')
            self.AddressParcelIdentifier = AddressParcelIdentifier_
            # validate type AddressParcelIdentifier_type
            self.validate_AddressParcelIdentifier_type(self.AddressParcelIdentifier)
        elif nodeName_ == 'AddressTransportationSystemName':
            AddressTransportationSystemName_ = child_.text
            AddressTransportationSystemName_ = self.gds_validate_string(AddressTransportationSystemName_, node, 'AddressTransportationSystemName')
            self.AddressTransportationSystemName = AddressTransportationSystemName_
            # validate type AddressTransportationSystemName_type
            self.validate_AddressTransportationSystemName_type(self.AddressTransportationSystemName)
        elif nodeName_ == 'AddressTransportationSystemAuthority':
            AddressTransportationSystemAuthority_ = child_.text
            AddressTransportationSystemAuthority_ = self.gds_validate_string(AddressTransportationSystemAuthority_, node, 'AddressTransportationSystemAuthority')
            self.AddressTransportationSystemAuthority = AddressTransportationSystemAuthority_
            # validate type AddressTransportationSystemAuthority_type
            self.validate_AddressTransportationSystemAuthority_type(self.AddressTransportationSystemAuthority)
        elif nodeName_ == 'AddressTransportationFeatureType':
            AddressTransportationFeatureType_ = child_.text
            AddressTransportationFeatureType_ = self.gds_validate_string(AddressTransportationFeatureType_, node, 'AddressTransportationFeatureType')
            self.AddressTransportationFeatureType = AddressTransportationFeatureType_
            # validate type AddressTransportationFeatureType_type
            self.validate_AddressTransportationFeatureType_type(self.AddressTransportationFeatureType)
        elif nodeName_ == 'AddressTransportationFeatureID':
            AddressTransportationFeatureID_ = child_.text
            AddressTransportationFeatureID_ = self.gds_validate_string(AddressTransportationFeatureID_, node, 'AddressTransportationFeatureID')
            self.AddressTransportationFeatureID = AddressTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.AddressTransportationFeatureID)
        elif nodeName_ == 'RelatedTransportationFeatureID':
            RelatedTransportationFeatureID_ = child_.text
            RelatedTransportationFeatureID_ = self.gds_validate_string(RelatedTransportationFeatureID_, node, 'RelatedTransportationFeatureID')
            self.RelatedTransportationFeatureID = RelatedTransportationFeatureID_
            # validate type AssociatedAddressId_type
            self.validate_AssociatedAddressId_type(self.RelatedTransportationFeatureID)
        elif nodeName_ == 'AddressRangeType':
            AddressRangeType_ = child_.text
            AddressRangeType_ = self.gds_validate_string(AddressRangeType_, node, 'AddressRangeType')
            self.AddressRangeType = AddressRangeType_
            # validate type AddressRangeType_type
            self.validate_AddressRangeType_type(self.AddressRangeType)
        elif nodeName_ == 'AddressRangeParity':
            AddressRangeParity_ = child_.text
            AddressRangeParity_ = self.gds_validate_string(AddressRangeParity_, node, 'AddressRangeParity')
            self.AddressRangeParity = AddressRangeParity_
            # validate type AddressRangeParity_type
            self.validate_AddressRangeParity_type(self.AddressRangeParity)
        elif nodeName_ == 'AddressRangeDirectionality':
            AddressRangeDirectionality_ = child_.text
            AddressRangeDirectionality_ = self.gds_validate_string(AddressRangeDirectionality_, node, 'AddressRangeDirectionality')
            self.AddressRangeDirectionality = AddressRangeDirectionality_
            # validate type AddressRangeDirectionality_type
            self.validate_AddressRangeDirectionality_type(self.AddressRangeDirectionality)
        elif nodeName_ == 'AddressRangeSpan':
            AddressRangeSpan_ = child_.text
            AddressRangeSpan_ = self.gds_validate_string(AddressRangeSpan_, node, 'AddressRangeSpan')
            self.AddressRangeSpan = AddressRangeSpan_
            # validate type AddressRangeSpan_type
            self.validate_AddressRangeSpan_type(self.AddressRangeSpan)
        elif nodeName_ == 'AddressClassification':
            AddressClassification_ = child_.text
            AddressClassification_ = self.gds_validate_string(AddressClassification_, node, 'AddressClassification')
            self.AddressClassification = AddressClassification_
            # validate type AddressClassification_type
            self.validate_AddressClassification_type(self.AddressClassification)
        elif nodeName_ == 'AddressFeatureType':
            AddressFeatureType_ = child_.text
            AddressFeatureType_ = self.gds_validate_string(AddressFeatureType_, node, 'AddressFeatureType')
            self.AddressFeatureType = AddressFeatureType_
            # validate type AddressFeatureType_type
            self.validate_AddressFeatureType_type(self.AddressFeatureType)
        elif nodeName_ == 'AddressLifecycleStatus':
            AddressLifecycleStatus_ = child_.text
            if AddressLifecycleStatus_:
                AddressLifecycleStatus_ = re_.sub(String_cleanup_pat_, " ", AddressLifecycleStatus_).strip()
            else:
                AddressLifecycleStatus_ = ""
            AddressLifecycleStatus_ = self.gds_validate_string(AddressLifecycleStatus_, node, 'AddressLifecycleStatus')
            self.AddressLifecycleStatus = AddressLifecycleStatus_
            # validate type AddressLifecycleStatus_type
            self.validate_AddressLifecycleStatus_type(self.AddressLifecycleStatus)
        elif nodeName_ == 'OfficialStatus':
            OfficialStatus_ = child_.text
            OfficialStatus_ = self.gds_validate_string(OfficialStatus_, node, 'OfficialStatus')
            self.OfficialStatus = OfficialStatus_
            # validate type OfficialStatus_type
            self.validate_OfficialStatus_type(self.OfficialStatus)
        elif nodeName_ == 'AddressAnomalyStatus':
            AddressAnomalyStatus_ = child_.text
            AddressAnomalyStatus_ = self.gds_validate_string(AddressAnomalyStatus_, node, 'AddressAnomalyStatus')
            self.AddressAnomalyStatus = AddressAnomalyStatus_
            # validate type AddressAnomalyStatus_type
            self.validate_AddressAnomalyStatus_type(self.AddressAnomalyStatus)
        elif nodeName_ == 'AddressSideOfStreet':
            AddressSideOfStreet_ = child_.text
            AddressSideOfStreet_ = self.gds_validate_string(AddressSideOfStreet_, node, 'AddressSideOfStreet')
            self.AddressSideOfStreet = AddressSideOfStreet_
            # validate type AddressSideOfStreet_type
            self.validate_AddressSideOfStreet_type(self.AddressSideOfStreet)
        elif nodeName_ == 'AddressZLevel':
            AddressZLevel_ = child_.text
            AddressZLevel_ = self.gds_validate_string(AddressZLevel_, node, 'AddressZLevel')
            self.AddressZLevel = AddressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AddressZLevel)
        elif nodeName_ == 'LocationDescription':
            LocationDescription_ = child_.text
            LocationDescription_ = self.gds_validate_string(LocationDescription_, node, 'LocationDescription')
            self.LocationDescription = LocationDescription_
            # validate type LocationDescription_type
            self.validate_LocationDescription_type(self.LocationDescription)
        elif nodeName_ == 'MailableAddress':
            MailableAddress_ = child_.text
            MailableAddress_ = self.gds_validate_string(MailableAddress_, node, 'MailableAddress')
            self.MailableAddress = MailableAddress_
            # validate type MailableAddress_type
            self.validate_MailableAddress_type(self.MailableAddress)
        elif nodeName_ == 'AddressStartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressStartDate = dval_
            # validate type AddressStartDate_type
            self.validate_AddressStartDate_type(self.AddressStartDate)
        elif nodeName_ == 'AddressEndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.AddressEndDate = dval_
            # validate type AddressEndDate_type
            self.validate_AddressEndDate_type(self.AddressEndDate)
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
            # validate type DataSetID_type
            self.validate_DataSetID_type(self.DataSetID)
        elif nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
# end class GeneralAddressClass_type


class AddressCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, NumberedThoroughfareAddress=None, IntersectionAddress=None, TwoNumberAddressRange=None, FourNumberAddressRange=None, UnnumberedThoroughfareAddress=None, LandmarkAddress=None, CommunityAddress=None, USPSPostalDeliveryBox=None, USPSPostalDeliveryRoute=None, USPSGeneralDeliveryOffice=None, GeneralAddressClass=None, AddressReferenceSystem=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        if NumberedThoroughfareAddress is None:
            self.NumberedThoroughfareAddress = []
        else:
            self.NumberedThoroughfareAddress = NumberedThoroughfareAddress
        if IntersectionAddress is None:
            self.IntersectionAddress = []
        else:
            self.IntersectionAddress = IntersectionAddress
        if TwoNumberAddressRange is None:
            self.TwoNumberAddressRange = []
        else:
            self.TwoNumberAddressRange = TwoNumberAddressRange
        if FourNumberAddressRange is None:
            self.FourNumberAddressRange = []
        else:
            self.FourNumberAddressRange = FourNumberAddressRange
        if UnnumberedThoroughfareAddress is None:
            self.UnnumberedThoroughfareAddress = []
        else:
            self.UnnumberedThoroughfareAddress = UnnumberedThoroughfareAddress
        if LandmarkAddress is None:
            self.LandmarkAddress = []
        else:
            self.LandmarkAddress = LandmarkAddress
        if CommunityAddress is None:
            self.CommunityAddress = []
        else:
            self.CommunityAddress = CommunityAddress
        if USPSPostalDeliveryBox is None:
            self.USPSPostalDeliveryBox = []
        else:
            self.USPSPostalDeliveryBox = USPSPostalDeliveryBox
        if USPSPostalDeliveryRoute is None:
            self.USPSPostalDeliveryRoute = []
        else:
            self.USPSPostalDeliveryRoute = USPSPostalDeliveryRoute
        if USPSGeneralDeliveryOffice is None:
            self.USPSGeneralDeliveryOffice = []
        else:
            self.USPSGeneralDeliveryOffice = USPSGeneralDeliveryOffice
        if GeneralAddressClass is None:
            self.GeneralAddressClass = []
        else:
            self.GeneralAddressClass = GeneralAddressClass
        if AddressReferenceSystem is None:
            self.AddressReferenceSystem = []
        else:
            self.AddressReferenceSystem = AddressReferenceSystem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressCollection.subclass:
            return AddressCollection.subclass(*args_, **kwargs_)
        else:
            return AddressCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberedThoroughfareAddress(self): return self.NumberedThoroughfareAddress
    def set_NumberedThoroughfareAddress(self, NumberedThoroughfareAddress): self.NumberedThoroughfareAddress = NumberedThoroughfareAddress
    def add_NumberedThoroughfareAddress(self, value): self.NumberedThoroughfareAddress.append(value)
    def insert_NumberedThoroughfareAddress_at(self, index, value): self.NumberedThoroughfareAddress.insert(index, value)
    def replace_NumberedThoroughfareAddress_at(self, index, value): self.NumberedThoroughfareAddress[index] = value
    def get_IntersectionAddress(self): return self.IntersectionAddress
    def set_IntersectionAddress(self, IntersectionAddress): self.IntersectionAddress = IntersectionAddress
    def add_IntersectionAddress(self, value): self.IntersectionAddress.append(value)
    def insert_IntersectionAddress_at(self, index, value): self.IntersectionAddress.insert(index, value)
    def replace_IntersectionAddress_at(self, index, value): self.IntersectionAddress[index] = value
    def get_TwoNumberAddressRange(self): return self.TwoNumberAddressRange
    def set_TwoNumberAddressRange(self, TwoNumberAddressRange): self.TwoNumberAddressRange = TwoNumberAddressRange
    def add_TwoNumberAddressRange(self, value): self.TwoNumberAddressRange.append(value)
    def insert_TwoNumberAddressRange_at(self, index, value): self.TwoNumberAddressRange.insert(index, value)
    def replace_TwoNumberAddressRange_at(self, index, value): self.TwoNumberAddressRange[index] = value
    def get_FourNumberAddressRange(self): return self.FourNumberAddressRange
    def set_FourNumberAddressRange(self, FourNumberAddressRange): self.FourNumberAddressRange = FourNumberAddressRange
    def add_FourNumberAddressRange(self, value): self.FourNumberAddressRange.append(value)
    def insert_FourNumberAddressRange_at(self, index, value): self.FourNumberAddressRange.insert(index, value)
    def replace_FourNumberAddressRange_at(self, index, value): self.FourNumberAddressRange[index] = value
    def get_UnnumberedThoroughfareAddress(self): return self.UnnumberedThoroughfareAddress
    def set_UnnumberedThoroughfareAddress(self, UnnumberedThoroughfareAddress): self.UnnumberedThoroughfareAddress = UnnumberedThoroughfareAddress
    def add_UnnumberedThoroughfareAddress(self, value): self.UnnumberedThoroughfareAddress.append(value)
    def insert_UnnumberedThoroughfareAddress_at(self, index, value): self.UnnumberedThoroughfareAddress.insert(index, value)
    def replace_UnnumberedThoroughfareAddress_at(self, index, value): self.UnnumberedThoroughfareAddress[index] = value
    def get_LandmarkAddress(self): return self.LandmarkAddress
    def set_LandmarkAddress(self, LandmarkAddress): self.LandmarkAddress = LandmarkAddress
    def add_LandmarkAddress(self, value): self.LandmarkAddress.append(value)
    def insert_LandmarkAddress_at(self, index, value): self.LandmarkAddress.insert(index, value)
    def replace_LandmarkAddress_at(self, index, value): self.LandmarkAddress[index] = value
    def get_CommunityAddress(self): return self.CommunityAddress
    def set_CommunityAddress(self, CommunityAddress): self.CommunityAddress = CommunityAddress
    def add_CommunityAddress(self, value): self.CommunityAddress.append(value)
    def insert_CommunityAddress_at(self, index, value): self.CommunityAddress.insert(index, value)
    def replace_CommunityAddress_at(self, index, value): self.CommunityAddress[index] = value
    def get_USPSPostalDeliveryBox(self): return self.USPSPostalDeliveryBox
    def set_USPSPostalDeliveryBox(self, USPSPostalDeliveryBox): self.USPSPostalDeliveryBox = USPSPostalDeliveryBox
    def add_USPSPostalDeliveryBox(self, value): self.USPSPostalDeliveryBox.append(value)
    def insert_USPSPostalDeliveryBox_at(self, index, value): self.USPSPostalDeliveryBox.insert(index, value)
    def replace_USPSPostalDeliveryBox_at(self, index, value): self.USPSPostalDeliveryBox[index] = value
    def get_USPSPostalDeliveryRoute(self): return self.USPSPostalDeliveryRoute
    def set_USPSPostalDeliveryRoute(self, USPSPostalDeliveryRoute): self.USPSPostalDeliveryRoute = USPSPostalDeliveryRoute
    def add_USPSPostalDeliveryRoute(self, value): self.USPSPostalDeliveryRoute.append(value)
    def insert_USPSPostalDeliveryRoute_at(self, index, value): self.USPSPostalDeliveryRoute.insert(index, value)
    def replace_USPSPostalDeliveryRoute_at(self, index, value): self.USPSPostalDeliveryRoute[index] = value
    def get_USPSGeneralDeliveryOffice(self): return self.USPSGeneralDeliveryOffice
    def set_USPSGeneralDeliveryOffice(self, USPSGeneralDeliveryOffice): self.USPSGeneralDeliveryOffice = USPSGeneralDeliveryOffice
    def add_USPSGeneralDeliveryOffice(self, value): self.USPSGeneralDeliveryOffice.append(value)
    def insert_USPSGeneralDeliveryOffice_at(self, index, value): self.USPSGeneralDeliveryOffice.insert(index, value)
    def replace_USPSGeneralDeliveryOffice_at(self, index, value): self.USPSGeneralDeliveryOffice[index] = value
    def get_GeneralAddressClass(self): return self.GeneralAddressClass
    def set_GeneralAddressClass(self, GeneralAddressClass): self.GeneralAddressClass = GeneralAddressClass
    def add_GeneralAddressClass(self, value): self.GeneralAddressClass.append(value)
    def insert_GeneralAddressClass_at(self, index, value): self.GeneralAddressClass.insert(index, value)
    def replace_GeneralAddressClass_at(self, index, value): self.GeneralAddressClass[index] = value
    def get_AddressReferenceSystem(self): return self.AddressReferenceSystem
    def set_AddressReferenceSystem(self, AddressReferenceSystem): self.AddressReferenceSystem = AddressReferenceSystem
    def add_AddressReferenceSystem(self, value): self.AddressReferenceSystem.append(value)
    def insert_AddressReferenceSystem_at(self, index, value): self.AddressReferenceSystem.insert(index, value)
    def replace_AddressReferenceSystem_at(self, index, value): self.AddressReferenceSystem[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.NumberedThoroughfareAddress or
            self.IntersectionAddress or
            self.TwoNumberAddressRange or
            self.FourNumberAddressRange or
            self.UnnumberedThoroughfareAddress or
            self.LandmarkAddress or
            self.CommunityAddress or
            self.USPSPostalDeliveryBox or
            self.USPSPostalDeliveryRoute or
            self.USPSGeneralDeliveryOffice or
            self.GeneralAddressClass or
            self.AddressReferenceSystem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressCollection', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressCollection'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NumberedThoroughfareAddress_ in self.NumberedThoroughfareAddress:
            NumberedThoroughfareAddress_.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress', pretty_print=pretty_print)
        for IntersectionAddress_ in self.IntersectionAddress:
            IntersectionAddress_.export(outfile, level, namespaceprefix_, name_='IntersectionAddress', pretty_print=pretty_print)
        for TwoNumberAddressRange_ in self.TwoNumberAddressRange:
            TwoNumberAddressRange_.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange', pretty_print=pretty_print)
        for FourNumberAddressRange_ in self.FourNumberAddressRange:
            FourNumberAddressRange_.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange', pretty_print=pretty_print)
        for UnnumberedThoroughfareAddress_ in self.UnnumberedThoroughfareAddress:
            UnnumberedThoroughfareAddress_.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress', pretty_print=pretty_print)
        for LandmarkAddress_ in self.LandmarkAddress:
            LandmarkAddress_.export(outfile, level, namespaceprefix_, name_='LandmarkAddress', pretty_print=pretty_print)
        for CommunityAddress_ in self.CommunityAddress:
            CommunityAddress_.export(outfile, level, namespaceprefix_, name_='CommunityAddress', pretty_print=pretty_print)
        for USPSPostalDeliveryBox_ in self.USPSPostalDeliveryBox:
            USPSPostalDeliveryBox_.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox', pretty_print=pretty_print)
        for USPSPostalDeliveryRoute_ in self.USPSPostalDeliveryRoute:
            USPSPostalDeliveryRoute_.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute', pretty_print=pretty_print)
        for USPSGeneralDeliveryOffice_ in self.USPSGeneralDeliveryOffice:
            USPSGeneralDeliveryOffice_.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice', pretty_print=pretty_print)
        for GeneralAddressClass_ in self.GeneralAddressClass:
            GeneralAddressClass_.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass', pretty_print=pretty_print)
        for AddressReferenceSystem_ in self.AddressReferenceSystem:
            AddressReferenceSystem_.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberedThoroughfareAddress':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress.append(obj_)
            obj_.original_tagname_ = 'NumberedThoroughfareAddress'
        elif nodeName_ == 'IntersectionAddress':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress.append(obj_)
            obj_.original_tagname_ = 'IntersectionAddress'
        elif nodeName_ == 'TwoNumberAddressRange':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange.append(obj_)
            obj_.original_tagname_ = 'TwoNumberAddressRange'
        elif nodeName_ == 'FourNumberAddressRange':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange.append(obj_)
            obj_.original_tagname_ = 'FourNumberAddressRange'
        elif nodeName_ == 'UnnumberedThoroughfareAddress':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress.append(obj_)
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress'
        elif nodeName_ == 'LandmarkAddress':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress.append(obj_)
            obj_.original_tagname_ = 'LandmarkAddress'
        elif nodeName_ == 'CommunityAddress':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress.append(obj_)
            obj_.original_tagname_ = 'CommunityAddress'
        elif nodeName_ == 'USPSPostalDeliveryBox':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox.append(obj_)
            obj_.original_tagname_ = 'USPSPostalDeliveryBox'
        elif nodeName_ == 'USPSPostalDeliveryRoute':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute.append(obj_)
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute'
        elif nodeName_ == 'USPSGeneralDeliveryOffice':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice.append(obj_)
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice'
        elif nodeName_ == 'GeneralAddressClass':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass.append(obj_)
            obj_.original_tagname_ = 'GeneralAddressClass'
        elif nodeName_ == 'AddressReferenceSystem':
            obj_ = AddressReferenceSystem_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystem.append(obj_)
            obj_.original_tagname_ = 'AddressReferenceSystem'
# end class AddressCollection


class AddressNumberPrefix_type(GeneratedsSuper):
    """The portion of the Complete Address Number which precedes the
    Address Number itself."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressNumberPrefix_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressNumberPrefix_type.subclass:
            return AddressNumberPrefix_type.subclass(*args_, **kwargs_)
        else:
            return AddressNumberPrefix_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressNumberPrefix_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressNumberPrefix_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressNumberPrefix_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressNumberPrefix_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressNumberPrefix_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressNumberPrefix_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressNumberPrefix_type


class AddressNumberSuffix_type(GeneratedsSuper):
    """The portion of the Complete Address Number which follows the Address
    Number itself. 1. This element is not found in most Complete
    Address Numbers. When found, it should be separated from the
    Address Number so that the Address Number can be maintained as
    an integer for sorting and quality control tests. 2. Informally
    an Address Number and Address Number Suffix may be written with
    or without a space between them. Within this standard, the
    default assumption is that an empty space separates elements
    unless stated otherwise. The Attached Element can be used to
    indicate where the assumed space between the Address Number and
    Address Number Suffix has been omitted within an address file
    (see Attached Element for additional notes). 3. If a hyphen
    appears between the Address Number and the Address Number
    Suffix, the hyphen is included in the Address Number Suffix. 4.
    When milepost Complete Address Numbers include decimal
    fractions, the integer portion of the milepost number is treated
    as the Address Number, and the fraction (including the decimal
    point) is treated as an Address Number Suffix. (See Complete
    Address Number for additional notes on milepost address
    numbers.)"""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressNumberSuffix_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressNumberSuffix_type.subclass:
            return AddressNumberSuffix_type.subclass(*args_, **kwargs_)
        else:
            return AddressNumberSuffix_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressNumberSuffix_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressNumberSuffix_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressNumberSuffix_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressNumberSuffix_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressNumberSuffix_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressNumberSuffix_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressNumberSuffix_type


class StreetNamePreModifier_type(GeneratedsSuper):
    """A word or phrase in a Complete Street Name that 1. Precedes and
    modifies the Street Name, but is separated from it by a Street
    Name Pre Type or a Street Name Pre Directional or both, or 2. Is
    placed outside the Street Name so that the Street Name can be
    used in creating a sorted (alphabetical or alphanumeric) list of
    street names."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNamePreModifier_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNamePreModifier_type.subclass:
            return StreetNamePreModifier_type.subclass(*args_, **kwargs_)
        else:
            return StreetNamePreModifier_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePreModifier_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNamePreModifier_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNamePreModifier_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNamePreModifier_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNamePreModifier_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePreModifier_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNamePreModifier_type


class StreetNamePreDirectional_type(GeneratedsSuper):
    """A word preceding the Street Name that indicates the direction or
    position of the thoroughfare relative to an arbitrary starting
    point or line, or the sector where it is located."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNamePreDirectional_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNamePreDirectional_type.subclass:
            return StreetNamePreDirectional_type.subclass(*args_, **kwargs_)
        else:
            return StreetNamePreDirectional_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePreDirectional_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNamePreDirectional_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNamePreDirectional_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNamePreDirectional_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNamePreDirectional_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePreDirectional_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNamePreDirectional_type


class StreetNamePreType_type(GeneratedsSuper):
    """A word or phrase that precedes the Street Name and identifies a type
    of thoroughfare in a Complete Street Name."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNamePreType_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNamePreType_type.subclass:
            return StreetNamePreType_type.subclass(*args_, **kwargs_)
        else:
            return StreetNamePreType_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePreType_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNamePreType_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNamePreType_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNamePreType_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNamePreType_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePreType_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNamePreType_type


class StreetNamePostModifier_type(GeneratedsSuper):
    """A word or phrase in a Complete Street Name that follows and modifies
    the Street Name, but is separated from it by a Street Name Post
    Type or a Street Name Post Directional or both."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNamePostModifier_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNamePostModifier_type.subclass:
            return StreetNamePostModifier_type.subclass(*args_, **kwargs_)
        else:
            return StreetNamePostModifier_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePostModifier_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNamePostModifier_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNamePostModifier_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNamePostModifier_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNamePostModifier_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePostModifier_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNamePostModifier_type


class StreetNamePostDirectional_type(GeneratedsSuper):
    """A word preceding the Street Name that indicates the direction or
    position of the thoroughfare relative to an arbitrary starting
    point or line, or the sector where it is located."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNamePostDirectional_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNamePostDirectional_type.subclass:
            return StreetNamePostDirectional_type.subclass(*args_, **kwargs_)
        else:
            return StreetNamePostDirectional_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePostDirectional_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNamePostDirectional_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNamePostDirectional_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNamePostDirectional_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNamePostDirectional_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePostDirectional_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNamePostDirectional_type


class StreetNamePostType_type(GeneratedsSuper):
    """A word or phrase that follows the Street Name and identifies a type
    of thoroughfare in a Complete Street Name."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, NewAttribute=None, valueOf_=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.NewAttribute = _cast(None, NewAttribute)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNamePostType_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNamePostType_type.subclass:
            return StreetNamePostType_type.subclass(*args_, **kwargs_)
        else:
            return StreetNamePostType_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_NewAttribute(self): return self.NewAttribute
    def set_NewAttribute(self, NewAttribute): self.NewAttribute = NewAttribute
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePostType_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNamePostType_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNamePostType_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNamePostType_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNamePostType_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
        if self.NewAttribute is not None and 'NewAttribute' not in already_processed:
            already_processed.add('NewAttribute')
            outfile.write(' NewAttribute=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NewAttribute), input_name='NewAttribute')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNamePostType_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
        value = find_attr_value_('NewAttribute', node)
        if value is not None and 'NewAttribute' not in already_processed:
            already_processed.add('NewAttribute')
            self.NewAttribute = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNamePostType_type


class SubaddressElement_type(GeneratedsSuper):
    """ A single combination of SubaddressType and SubaddressIdentifier (or,
    in some cases, a SubaddressIdentifier alone), which, alone or in
    combination with other SubaddressElements, distinguishes one
    subaddress within or between structures from another when
    several occur within the same feature. See CompleteSubaddress
    for a definition of "subaddress." """
    subclass = None
    superclass = None
    def __init__(self, ElementSequenceNumber=None, SubaddressComponentOrder=None, Separator=None, GNISFeatureID=None, SubaddressType=None, SubaddressIdentifier=None):
        self.original_tagname_ = None
        self.ElementSequenceNumber = _cast(None, ElementSequenceNumber)
        self.SubaddressComponentOrder = _cast(None, SubaddressComponentOrder)
        self.Separator = _cast(None, Separator)
        self.GNISFeatureID = _cast(None, GNISFeatureID)
        self.SubaddressType = SubaddressType
        self.validate_SubaddressType_type(self.SubaddressType)
        self.SubaddressIdentifier = SubaddressIdentifier
        self.validate_SubaddressIdentifier_type(self.SubaddressIdentifier)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubaddressElement_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubaddressElement_type.subclass:
            return SubaddressElement_type.subclass(*args_, **kwargs_)
        else:
            return SubaddressElement_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubaddressType(self): return self.SubaddressType
    def set_SubaddressType(self, SubaddressType): self.SubaddressType = SubaddressType
    def get_SubaddressIdentifier(self): return self.SubaddressIdentifier
    def set_SubaddressIdentifier(self, SubaddressIdentifier): self.SubaddressIdentifier = SubaddressIdentifier
    def get_ElementSequenceNumber(self): return self.ElementSequenceNumber
    def set_ElementSequenceNumber(self, ElementSequenceNumber): self.ElementSequenceNumber = ElementSequenceNumber
    def get_SubaddressComponentOrder(self): return self.SubaddressComponentOrder
    def set_SubaddressComponentOrder(self, SubaddressComponentOrder): self.SubaddressComponentOrder = SubaddressComponentOrder
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_GNISFeatureID(self): return self.GNISFeatureID
    def set_GNISFeatureID(self, GNISFeatureID): self.GNISFeatureID = GNISFeatureID
    def validate_SubaddressType_type(self, value):
        # Validate type SubaddressType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_SubaddressIdentifier_type(self, value):
        # Validate type SubaddressIdentifier_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.SubaddressType is not None or
            self.SubaddressIdentifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='SubaddressElement_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubaddressElement_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubaddressElement_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='SubaddressElement_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='SubaddressElement_type'):
        if self.ElementSequenceNumber is not None and 'ElementSequenceNumber' not in already_processed:
            already_processed.add('ElementSequenceNumber')
            outfile.write(' ElementSequenceNumber=%s' % (quote_attrib(self.ElementSequenceNumber), ))
        if self.SubaddressComponentOrder is not None and 'SubaddressComponentOrder' not in already_processed:
            already_processed.add('SubaddressComponentOrder')
            outfile.write(' SubaddressComponentOrder=%s' % (quote_attrib(self.SubaddressComponentOrder), ))
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
        if self.GNISFeatureID is not None and 'GNISFeatureID' not in already_processed:
            already_processed.add('GNISFeatureID')
            outfile.write(' GNISFeatureID=%s' % (quote_attrib(self.GNISFeatureID), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='SubaddressElement_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubaddressType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:SubaddressType>%s</addr:SubaddressType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SubaddressType), input_name='SubaddressType')), eol_))
        if self.SubaddressIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:SubaddressIdentifier>%s</addr:SubaddressIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.SubaddressIdentifier), input_name='SubaddressIdentifier')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ElementSequenceNumber', node)
        if value is not None and 'ElementSequenceNumber' not in already_processed:
            already_processed.add('ElementSequenceNumber')
            self.ElementSequenceNumber = value
        value = find_attr_value_('SubaddressComponentOrder', node)
        if value is not None and 'SubaddressComponentOrder' not in already_processed:
            already_processed.add('SubaddressComponentOrder')
            self.SubaddressComponentOrder = value
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
        value = find_attr_value_('GNISFeatureID', node)
        if value is not None and 'GNISFeatureID' not in already_processed:
            already_processed.add('GNISFeatureID')
            self.GNISFeatureID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubaddressType':
            SubaddressType_ = child_.text
            SubaddressType_ = self.gds_validate_string(SubaddressType_, node, 'SubaddressType')
            self.SubaddressType = SubaddressType_
            # validate type SubaddressType_type
            self.validate_SubaddressType_type(self.SubaddressType)
        elif nodeName_ == 'SubaddressIdentifier':
            SubaddressIdentifier_ = child_.text
            SubaddressIdentifier_ = self.gds_validate_string(SubaddressIdentifier_, node, 'SubaddressIdentifier')
            self.SubaddressIdentifier = SubaddressIdentifier_
            # validate type SubaddressIdentifier_type
            self.validate_SubaddressIdentifier_type(self.SubaddressIdentifier)
# end class SubaddressElement_type


class LandmarkName_type(GeneratedsSuper):
    """The name by which a prominent feature is publicly known. Landmarks
    usually have a street address. A landmark name does not imply
    official historic landmark status, but simply a commonly used
    name that substitutes for an address number and street name in
    identifying the location of a specific building or feature.
    Generally the use of a landmark's street address is preferable
    because it is unambiguous. All landmark names should be cross-
    referenced to a street address or other coordinate location."""
    subclass = None
    superclass = None
    def __init__(self, ElementSequenceNumber=None, GNISFeatureID=None, valueOf_=None):
        self.original_tagname_ = None
        self.ElementSequenceNumber = _cast(None, ElementSequenceNumber)
        self.GNISFeatureID = _cast(None, GNISFeatureID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LandmarkName_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LandmarkName_type.subclass:
            return LandmarkName_type.subclass(*args_, **kwargs_)
        else:
            return LandmarkName_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ElementSequenceNumber(self): return self.ElementSequenceNumber
    def set_ElementSequenceNumber(self, ElementSequenceNumber): self.ElementSequenceNumber = ElementSequenceNumber
    def get_GNISFeatureID(self): return self.GNISFeatureID
    def set_GNISFeatureID(self, GNISFeatureID): self.GNISFeatureID = GNISFeatureID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='LandmarkName_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LandmarkName_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LandmarkName_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='LandmarkName_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='LandmarkName_type'):
        if self.ElementSequenceNumber is not None and 'ElementSequenceNumber' not in already_processed:
            already_processed.add('ElementSequenceNumber')
            outfile.write(' ElementSequenceNumber=%s' % (quote_attrib(self.ElementSequenceNumber), ))
        if self.GNISFeatureID is not None and 'GNISFeatureID' not in already_processed:
            already_processed.add('GNISFeatureID')
            outfile.write(' GNISFeatureID=%s' % (quote_attrib(self.GNISFeatureID), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='LandmarkName_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ElementSequenceNumber', node)
        if value is not None and 'ElementSequenceNumber' not in already_processed:
            already_processed.add('ElementSequenceNumber')
            self.ElementSequenceNumber = value
        value = find_attr_value_('GNISFeatureID', node)
        if value is not None and 'GNISFeatureID' not in already_processed:
            already_processed.add('GNISFeatureID')
            self.GNISFeatureID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LandmarkName_type


class USPSBox_type(GeneratedsSuper):
    """A container for the receipt of USPS mail uniquely identified by the
    combination of a USPS Box Type and a USPS Box ID."""
    subclass = None
    superclass = None
    def __init__(self, USPSBoxType=None, USPSBoxId=None):
        self.original_tagname_ = None
        self.USPSBoxType = USPSBoxType
        self.validate_USPSBoxType_type(self.USPSBoxType)
        self.USPSBoxId = USPSBoxId
        self.validate_USPSBoxId_type(self.USPSBoxId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSBox_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSBox_type.subclass:
            return USPSBox_type.subclass(*args_, **kwargs_)
        else:
            return USPSBox_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSBoxType(self): return self.USPSBoxType
    def set_USPSBoxType(self, USPSBoxType): self.USPSBoxType = USPSBoxType
    def get_USPSBoxId(self): return self.USPSBoxId
    def set_USPSBoxId(self, USPSBoxId): self.USPSBoxId = USPSBoxId
    def validate_USPSBoxType_type(self, value):
        # Validate type USPSBoxType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_USPSBoxType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_USPSBoxType_type_patterns_, ))
    validate_USPSBoxType_type_patterns_ = [['^.*$']]
    def validate_USPSBoxId_type(self, value):
        # Validate type USPSBoxId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_USPSBoxId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_USPSBoxId_type_patterns_, ))
    validate_USPSBoxId_type_patterns_ = [['^.*$']]
    def hasContent_(self):
        if (
            self.USPSBoxType is not None or
            self.USPSBoxId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='USPSBox_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSBox_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSBox_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='USPSBox_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='USPSBox_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='USPSBox_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSBoxType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USPSBoxType>%s</addr:USPSBoxType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSBoxType), input_name='USPSBoxType')), eol_))
        if self.USPSBoxId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USPSBoxId>%s</addr:USPSBoxId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSBoxId), input_name='USPSBoxId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSBoxType':
            USPSBoxType_ = child_.text
            USPSBoxType_ = self.gds_validate_string(USPSBoxType_, node, 'USPSBoxType')
            self.USPSBoxType = USPSBoxType_
            # validate type USPSBoxType_type
            self.validate_USPSBoxType_type(self.USPSBoxType)
        elif nodeName_ == 'USPSBoxId':
            USPSBoxId_ = child_.text
            USPSBoxId_ = self.gds_validate_string(USPSBoxId_, node, 'USPSBoxId')
            self.USPSBoxId = USPSBoxId_
            # validate type USPSBoxId_type
            self.validate_USPSBoxId_type(self.USPSBoxId)
# end class USPSBox_type


class USPSRoute_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, USPSBoxGroupType=None, USPSBoxGroupId=None):
        self.original_tagname_ = None
        self.USPSBoxGroupType = USPSBoxGroupType
        self.validate_USPSBoxGroupType_type(self.USPSBoxGroupType)
        self.USPSBoxGroupId = USPSBoxGroupId
        self.validate_USPSBoxGroupId_type(self.USPSBoxGroupId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSRoute_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSRoute_type.subclass:
            return USPSRoute_type.subclass(*args_, **kwargs_)
        else:
            return USPSRoute_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSBoxGroupType(self): return self.USPSBoxGroupType
    def set_USPSBoxGroupType(self, USPSBoxGroupType): self.USPSBoxGroupType = USPSBoxGroupType
    def get_USPSBoxGroupId(self): return self.USPSBoxGroupId
    def set_USPSBoxGroupId(self, USPSBoxGroupId): self.USPSBoxGroupId = USPSBoxGroupId
    def validate_USPSBoxGroupType_type(self, value):
        # Validate type USPSBoxGroupType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_USPSBoxGroupType_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_USPSBoxGroupType_type_patterns_, ))
    validate_USPSBoxGroupType_type_patterns_ = [['^.*$']]
    def validate_USPSBoxGroupId_type(self, value):
        # Validate type USPSBoxGroupId_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_USPSBoxGroupId_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_USPSBoxGroupId_type_patterns_, ))
    validate_USPSBoxGroupId_type_patterns_ = [['^.*$']]
    def hasContent_(self):
        if (
            self.USPSBoxGroupType is not None or
            self.USPSBoxGroupId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='USPSRoute_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSRoute_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSRoute_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='USPSRoute_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='USPSRoute_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='USPSRoute_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSBoxGroupType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USPSBoxGroupType>%s</addr:USPSBoxGroupType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSBoxGroupType), input_name='USPSBoxGroupType')), eol_))
        if self.USPSBoxGroupId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USPSBoxGroupId>%s</addr:USPSBoxGroupId>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USPSBoxGroupId), input_name='USPSBoxGroupId')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSBoxGroupType':
            USPSBoxGroupType_ = child_.text
            USPSBoxGroupType_ = self.gds_validate_string(USPSBoxGroupType_, node, 'USPSBoxGroupType')
            self.USPSBoxGroupType = USPSBoxGroupType_
            # validate type USPSBoxGroupType_type
            self.validate_USPSBoxGroupType_type(self.USPSBoxGroupType)
        elif nodeName_ == 'USPSBoxGroupId':
            USPSBoxGroupId_ = child_.text
            USPSBoxGroupId_ = self.gds_validate_string(USPSBoxGroupId_, node, 'USPSBoxGroupId')
            self.USPSBoxGroupId = USPSBoxGroupId_
            # validate type USPSBoxGroupId_type
            self.validate_USPSBoxGroupId_type(self.USPSBoxGroupId)
# end class USPSRoute_type


class USPSAddress_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, USPSRoute=None, USPSBox=None):
        self.original_tagname_ = None
        self.USPSRoute = USPSRoute
        self.USPSBox = USPSBox
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, USPSAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if USPSAddress_type.subclass:
            return USPSAddress_type.subclass(*args_, **kwargs_)
        else:
            return USPSAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USPSRoute(self): return self.USPSRoute
    def set_USPSRoute(self, USPSRoute): self.USPSRoute = USPSRoute
    def get_USPSBox(self): return self.USPSBox
    def set_USPSBox(self, USPSBox): self.USPSBox = USPSBox
    def hasContent_(self):
        if (
            self.USPSRoute is not None or
            self.USPSBox is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='USPSAddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('USPSAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='USPSAddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='USPSAddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='USPSAddress_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='USPSAddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USPSRoute is not None:
            self.USPSRoute.export(outfile, level, namespaceprefix_, name_='USPSRoute', pretty_print=pretty_print)
        if self.USPSBox is not None:
            self.USPSBox.export(outfile, level, namespaceprefix_, name_='USPSBox', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USPSRoute':
            obj_ = USPSRoute_type.factory()
            obj_.build(child_)
            self.USPSRoute = obj_
            obj_.original_tagname_ = 'USPSRoute'
        elif nodeName_ == 'USPSBox':
            obj_ = USPSBox_type.factory()
            obj_.build(child_)
            self.USPSBox = obj_
            obj_.original_tagname_ = 'USPSBox'
# end class USPSAddress_type


class AddressCoordinateReferenceSystem_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressCoordinateReferenceSystemAuthority=None, AddressCoordinateReferenceSystemID=None):
        self.original_tagname_ = None
        self.AddressCoordinateReferenceSystemAuthority = AddressCoordinateReferenceSystemAuthority
        self.validate_AddressCoordinateReferenceSystemAuthority_type(self.AddressCoordinateReferenceSystemAuthority)
        self.AddressCoordinateReferenceSystemID = AddressCoordinateReferenceSystemID
        self.validate_AddressCoordinateReferenceSystemID_type(self.AddressCoordinateReferenceSystemID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressCoordinateReferenceSystem_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressCoordinateReferenceSystem_type.subclass:
            return AddressCoordinateReferenceSystem_type.subclass(*args_, **kwargs_)
        else:
            return AddressCoordinateReferenceSystem_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressCoordinateReferenceSystemAuthority(self): return self.AddressCoordinateReferenceSystemAuthority
    def set_AddressCoordinateReferenceSystemAuthority(self, AddressCoordinateReferenceSystemAuthority): self.AddressCoordinateReferenceSystemAuthority = AddressCoordinateReferenceSystemAuthority
    def get_AddressCoordinateReferenceSystemID(self): return self.AddressCoordinateReferenceSystemID
    def set_AddressCoordinateReferenceSystemID(self, AddressCoordinateReferenceSystemID): self.AddressCoordinateReferenceSystemID = AddressCoordinateReferenceSystemID
    def validate_AddressCoordinateReferenceSystemAuthority_type(self, value):
        # Validate type AddressCoordinateReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressCoordinateReferenceSystemID_type(self, value):
        # Validate type AddressCoordinateReferenceSystemID_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.AddressCoordinateReferenceSystemAuthority is not None or
            self.AddressCoordinateReferenceSystemID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressCoordinateReferenceSystem_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressCoordinateReferenceSystem_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressCoordinateReferenceSystem_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressCoordinateReferenceSystem_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressCoordinateReferenceSystem_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressCoordinateReferenceSystem_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressCoordinateReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressCoordinateReferenceSystemAuthority>%s</addr:AddressCoordinateReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressCoordinateReferenceSystemAuthority), input_name='AddressCoordinateReferenceSystemAuthority')), eol_))
        if self.AddressCoordinateReferenceSystemID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressCoordinateReferenceSystemID>%s</addr:AddressCoordinateReferenceSystemID>%s' % (self.gds_format_integer(self.AddressCoordinateReferenceSystemID, input_name='AddressCoordinateReferenceSystemID'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressCoordinateReferenceSystemAuthority':
            AddressCoordinateReferenceSystemAuthority_ = child_.text
            AddressCoordinateReferenceSystemAuthority_ = self.gds_validate_string(AddressCoordinateReferenceSystemAuthority_, node, 'AddressCoordinateReferenceSystemAuthority')
            self.AddressCoordinateReferenceSystemAuthority = AddressCoordinateReferenceSystemAuthority_
            # validate type AddressCoordinateReferenceSystemAuthority_type
            self.validate_AddressCoordinateReferenceSystemAuthority_type(self.AddressCoordinateReferenceSystemAuthority)
        elif nodeName_ == 'AddressCoordinateReferenceSystemID' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressCoordinateReferenceSystemID')
            self.AddressCoordinateReferenceSystemID = ival_
            # validate type AddressCoordinateReferenceSystemID_type
            self.validate_AddressCoordinateReferenceSystemID_type(self.AddressCoordinateReferenceSystemID)
# end class AddressCoordinateReferenceSystem_type


class AddressReferenceSystemExtent_type(GeneratedsSuper):
    """Boundary of the area(s) within which an Address Reference System is
    used."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemExtent_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemExtent_type.subclass:
            return AddressReferenceSystemExtent_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemExtent_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemExtent_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemExtent_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemExtent_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemExtent_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemExtent_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemExtent_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemExtent_type


class AddressReferenceSystemRules_type(GeneratedsSuper):
    """The rules by which address numbers, street names and other
    components of a thoroughfare address are determined."""
    subclass = None
    superclass = None
    def __init__(self, AddressReferenceSystemBlockRules=None, AddressReferenceSystemNumberingRules=None, AddressReferenceSystemStreetNamingRules=None, AddressReferenceSystemStreetTypeDirectionalAndModfierRules=None, AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules=None, AddressReferenceSystemSubaddressRules=None):
        self.original_tagname_ = None
        if AddressReferenceSystemBlockRules is None:
            self.AddressReferenceSystemBlockRules = []
        else:
            self.AddressReferenceSystemBlockRules = AddressReferenceSystemBlockRules
        if AddressReferenceSystemNumberingRules is None:
            self.AddressReferenceSystemNumberingRules = []
        else:
            self.AddressReferenceSystemNumberingRules = AddressReferenceSystemNumberingRules
        if AddressReferenceSystemStreetNamingRules is None:
            self.AddressReferenceSystemStreetNamingRules = []
        else:
            self.AddressReferenceSystemStreetNamingRules = AddressReferenceSystemStreetNamingRules
        if AddressReferenceSystemStreetTypeDirectionalAndModfierRules is None:
            self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules = []
        else:
            self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules = AddressReferenceSystemStreetTypeDirectionalAndModfierRules
        if AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules is None:
            self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules = []
        else:
            self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules = AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules
        if AddressReferenceSystemSubaddressRules is None:
            self.AddressReferenceSystemSubaddressRules = []
        else:
            self.AddressReferenceSystemSubaddressRules = AddressReferenceSystemSubaddressRules
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemRules_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemRules_type.subclass:
            return AddressReferenceSystemRules_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemRules_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressReferenceSystemBlockRules(self): return self.AddressReferenceSystemBlockRules
    def set_AddressReferenceSystemBlockRules(self, AddressReferenceSystemBlockRules): self.AddressReferenceSystemBlockRules = AddressReferenceSystemBlockRules
    def add_AddressReferenceSystemBlockRules(self, value): self.AddressReferenceSystemBlockRules.append(value)
    def insert_AddressReferenceSystemBlockRules_at(self, index, value): self.AddressReferenceSystemBlockRules.insert(index, value)
    def replace_AddressReferenceSystemBlockRules_at(self, index, value): self.AddressReferenceSystemBlockRules[index] = value
    def get_AddressReferenceSystemNumberingRules(self): return self.AddressReferenceSystemNumberingRules
    def set_AddressReferenceSystemNumberingRules(self, AddressReferenceSystemNumberingRules): self.AddressReferenceSystemNumberingRules = AddressReferenceSystemNumberingRules
    def add_AddressReferenceSystemNumberingRules(self, value): self.AddressReferenceSystemNumberingRules.append(value)
    def insert_AddressReferenceSystemNumberingRules_at(self, index, value): self.AddressReferenceSystemNumberingRules.insert(index, value)
    def replace_AddressReferenceSystemNumberingRules_at(self, index, value): self.AddressReferenceSystemNumberingRules[index] = value
    def get_AddressReferenceSystemStreetNamingRules(self): return self.AddressReferenceSystemStreetNamingRules
    def set_AddressReferenceSystemStreetNamingRules(self, AddressReferenceSystemStreetNamingRules): self.AddressReferenceSystemStreetNamingRules = AddressReferenceSystemStreetNamingRules
    def add_AddressReferenceSystemStreetNamingRules(self, value): self.AddressReferenceSystemStreetNamingRules.append(value)
    def insert_AddressReferenceSystemStreetNamingRules_at(self, index, value): self.AddressReferenceSystemStreetNamingRules.insert(index, value)
    def replace_AddressReferenceSystemStreetNamingRules_at(self, index, value): self.AddressReferenceSystemStreetNamingRules[index] = value
    def get_AddressReferenceSystemStreetTypeDirectionalAndModfierRules(self): return self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules
    def set_AddressReferenceSystemStreetTypeDirectionalAndModfierRules(self, AddressReferenceSystemStreetTypeDirectionalAndModfierRules): self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules = AddressReferenceSystemStreetTypeDirectionalAndModfierRules
    def add_AddressReferenceSystemStreetTypeDirectionalAndModfierRules(self, value): self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules.append(value)
    def insert_AddressReferenceSystemStreetTypeDirectionalAndModfierRules_at(self, index, value): self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules.insert(index, value)
    def replace_AddressReferenceSystemStreetTypeDirectionalAndModfierRules_at(self, index, value): self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules[index] = value
    def get_AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules(self): return self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules
    def set_AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules(self, AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules): self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules = AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules
    def add_AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules(self, value): self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules.append(value)
    def insert_AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_at(self, index, value): self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules.insert(index, value)
    def replace_AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_at(self, index, value): self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules[index] = value
    def get_AddressReferenceSystemSubaddressRules(self): return self.AddressReferenceSystemSubaddressRules
    def set_AddressReferenceSystemSubaddressRules(self, AddressReferenceSystemSubaddressRules): self.AddressReferenceSystemSubaddressRules = AddressReferenceSystemSubaddressRules
    def add_AddressReferenceSystemSubaddressRules(self, value): self.AddressReferenceSystemSubaddressRules.append(value)
    def insert_AddressReferenceSystemSubaddressRules_at(self, index, value): self.AddressReferenceSystemSubaddressRules.insert(index, value)
    def replace_AddressReferenceSystemSubaddressRules_at(self, index, value): self.AddressReferenceSystemSubaddressRules[index] = value
    def validate_AddressReferenceSystemBlockRules_type(self, value):
        # Validate type AddressReferenceSystemBlockRules_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemNumberingRules_type(self, value):
        # Validate type AddressReferenceSystemNumberingRules_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemStreetNamingRules_type(self, value):
        # Validate type AddressReferenceSystemStreetNamingRules_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemStreetTypeDirectionalAndModifierRules_type(self, value):
        # Validate type AddressReferenceSystemStreetTypeDirectionalAndModifierRules_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemPlaceNameStateCountryAndZipCodeRules_type(self, value):
        # Validate type AddressReferenceSystemPlaceNameStateCountryAndZipCodeRules_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemSubaddressRules_type(self, value):
        # Validate type AddressReferenceSystemSubaddressRules_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.AddressReferenceSystemBlockRules or
            self.AddressReferenceSystemNumberingRules or
            self.AddressReferenceSystemStreetNamingRules or
            self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules or
            self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules or
            self.AddressReferenceSystemSubaddressRules
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRules_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemRules_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemRules_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemRules_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemRules_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRules_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddressReferenceSystemBlockRules_ in self.AddressReferenceSystemBlockRules:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemBlockRules>%s</addr:AddressReferenceSystemBlockRules>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemBlockRules_), input_name='AddressReferenceSystemBlockRules')), eol_))
        for AddressReferenceSystemNumberingRules_ in self.AddressReferenceSystemNumberingRules:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemNumberingRules>%s</addr:AddressReferenceSystemNumberingRules>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemNumberingRules_), input_name='AddressReferenceSystemNumberingRules')), eol_))
        for AddressReferenceSystemStreetNamingRules_ in self.AddressReferenceSystemStreetNamingRules:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemStreetNamingRules>%s</addr:AddressReferenceSystemStreetNamingRules>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemStreetNamingRules_), input_name='AddressReferenceSystemStreetNamingRules')), eol_))
        for AddressReferenceSystemStreetTypeDirectionalAndModfierRules_ in self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemStreetTypeDirectionalAndModfierRules>%s</addr:AddressReferenceSystemStreetTypeDirectionalAndModfierRules>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemStreetTypeDirectionalAndModfierRules_), input_name='AddressReferenceSystemStreetTypeDirectionalAndModfierRules')), eol_))
        for AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_ in self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules>%s</addr:AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_), input_name='AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules')), eol_))
        for AddressReferenceSystemSubaddressRules_ in self.AddressReferenceSystemSubaddressRules:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemSubaddressRules>%s</addr:AddressReferenceSystemSubaddressRules>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemSubaddressRules_), input_name='AddressReferenceSystemSubaddressRules')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressReferenceSystemBlockRules':
            AddressReferenceSystemBlockRules_ = child_.text
            AddressReferenceSystemBlockRules_ = self.gds_validate_string(AddressReferenceSystemBlockRules_, node, 'AddressReferenceSystemBlockRules')
            self.AddressReferenceSystemBlockRules.append(AddressReferenceSystemBlockRules_)
            # validate type AddressReferenceSystemBlockRules_type
            self.validate_AddressReferenceSystemBlockRules_type(self.AddressReferenceSystemBlockRules[-1])
        elif nodeName_ == 'AddressReferenceSystemNumberingRules':
            AddressReferenceSystemNumberingRules_ = child_.text
            AddressReferenceSystemNumberingRules_ = self.gds_validate_string(AddressReferenceSystemNumberingRules_, node, 'AddressReferenceSystemNumberingRules')
            self.AddressReferenceSystemNumberingRules.append(AddressReferenceSystemNumberingRules_)
            # validate type AddressReferenceSystemNumberingRules_type
            self.validate_AddressReferenceSystemNumberingRules_type(self.AddressReferenceSystemNumberingRules[-1])
        elif nodeName_ == 'AddressReferenceSystemStreetNamingRules':
            AddressReferenceSystemStreetNamingRules_ = child_.text
            AddressReferenceSystemStreetNamingRules_ = self.gds_validate_string(AddressReferenceSystemStreetNamingRules_, node, 'AddressReferenceSystemStreetNamingRules')
            self.AddressReferenceSystemStreetNamingRules.append(AddressReferenceSystemStreetNamingRules_)
            # validate type AddressReferenceSystemStreetNamingRules_type
            self.validate_AddressReferenceSystemStreetNamingRules_type(self.AddressReferenceSystemStreetNamingRules[-1])
        elif nodeName_ == 'AddressReferenceSystemStreetTypeDirectionalAndModfierRules':
            AddressReferenceSystemStreetTypeDirectionalAndModfierRules_ = child_.text
            AddressReferenceSystemStreetTypeDirectionalAndModfierRules_ = self.gds_validate_string(AddressReferenceSystemStreetTypeDirectionalAndModfierRules_, node, 'AddressReferenceSystemStreetTypeDirectionalAndModfierRules')
            self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules.append(AddressReferenceSystemStreetTypeDirectionalAndModfierRules_)
            # validate type AddressReferenceSystemStreetTypeDirectionalAndModifierRules_type
            self.validate_AddressReferenceSystemStreetTypeDirectionalAndModifierRules_type(self.AddressReferenceSystemStreetTypeDirectionalAndModfierRules[-1])
        elif nodeName_ == 'AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules':
            AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_ = child_.text
            AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_ = self.gds_validate_string(AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_, node, 'AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules')
            self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules.append(AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules_)
            # validate type AddressReferenceSystemPlaceNameStateCountryAndZipCodeRules_type
            self.validate_AddressReferenceSystemPlaceNameStateCountryAndZipCodeRules_type(self.AddressReferenceSystemPlaceNameStateCountyAndZipCodeRules[-1])
        elif nodeName_ == 'AddressReferenceSystemSubaddressRules':
            AddressReferenceSystemSubaddressRules_ = child_.text
            AddressReferenceSystemSubaddressRules_ = self.gds_validate_string(AddressReferenceSystemSubaddressRules_, node, 'AddressReferenceSystemSubaddressRules')
            self.AddressReferenceSystemSubaddressRules.append(AddressReferenceSystemSubaddressRules_)
            # validate type AddressReferenceSystemSubaddressRules_type
            self.validate_AddressReferenceSystemSubaddressRules_type(self.AddressReferenceSystemSubaddressRules[-1])
# end class AddressReferenceSystemRules_type


class AddressReferenceSystemAxis_type(GeneratedsSuper):
    """The line that defines the points of origin for address numbering
    along thoroughfares that intersect it, or which are numbered in
    parallel to streets that intersect it. It may be a road, another
    geographic feature, or an imaginary line."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemAxis_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemAxis_type.subclass:
            return AddressReferenceSystemAxis_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemAxis_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemAxis_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemAxis_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemAxis_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemAxis_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemAxis_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemAxis_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemAxis_type


class AddressReferenceSystemAxisPointOfBeginning_type(GeneratedsSuper):
    """Coordinate location of the beginning point of address numbering
    along an Address Reference System Axis."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemAxisPointOfBeginning_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemAxisPointOfBeginning_type.subclass:
            return AddressReferenceSystemAxisPointOfBeginning_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemAxisPointOfBeginning_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemAxisPointOfBeginning_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemAxisPointOfBeginning_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemAxisPointOfBeginning_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemAxisPointOfBeginning_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemAxisPointOfBeginning_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemAxisPointOfBeginning_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemAxisPointOfBeginning_type


class AddressReferenceSystemGridAngle_type(GeneratedsSuper):
    """The degree to which a specific, named address grid is tilted off a
    north/south or east/west orientation."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemGridAngle_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemGridAngle_type.subclass:
            return AddressReferenceSystemGridAngle_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemGridAngle_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemGridAngle_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemGridAngle_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemGridAngle_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemGridAngle_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemGridAngle_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemGridAngle_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemGridAngle_type


class AddressReferenceSystemReferencePolyline_type(GeneratedsSuper):
    """A street, geometric line, or other line used to measure address
    number assignment intervals and ranges within an Address
    Reference System. The Address Reference System Reference
    Polyline may consist of a beginning point, one or more segments
    of a street centerline, geographically identified line, such as
    a line of latitude or longitude, a land-division based line,
    such as a township, range, or section line, or an imaginary line
    constructed for the purpose of allocating address ranges and
    address numbers."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemReferencePolyline_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemReferencePolyline_type.subclass:
            return AddressReferenceSystemReferencePolyline_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemReferencePolyline_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemReferencePolyline_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemReferencePolyline_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemReferencePolyline_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemReferencePolyline_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemReferencePolyline_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemReferencePolyline_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemReferencePolyline_type


class AddressReferenceSystemRangeBreakpoint_type(GeneratedsSuper):
    """A point along a street or other thoroughfare within an Address
    Reference System where an address range beginning and/or
    endpoint is located."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemRangeBreakpoint_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemRangeBreakpoint_type.subclass:
            return AddressReferenceSystemRangeBreakpoint_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemRangeBreakpoint_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakpoint_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemRangeBreakpoint_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemRangeBreakpoint_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakpoint_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakpoint_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakpoint_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemRangeBreakpoint_type


class AddressReferenceSystemRangeBreakline_type(GeneratedsSuper):
    """A line connecting the Address Reference System Range Breakpoints
    with the same value within an Address Reference System"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemRangeBreakline_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemRangeBreakline_type.subclass:
            return AddressReferenceSystemRangeBreakline_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemRangeBreakline_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakline_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemRangeBreakline_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemRangeBreakline_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakline_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakline_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRangeBreakline_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemRangeBreakline_type


class AddressReferenceSystemRangePolygon_type(GeneratedsSuper):
    """A line connecting the Address Reference System Range Breakpoints
    with the same value within an Address Reference System"""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystemRangePolygon_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystemRangePolygon_type.subclass:
            return AddressReferenceSystemRangePolygon_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystemRangePolygon_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRangePolygon_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystemRangePolygon_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystemRangePolygon_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystemRangePolygon_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystemRangePolygon_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystemRangePolygon_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressReferenceSystemRangePolygon_type


class AddressReferenceSystem_type(GeneratedsSuper):
    """An Address Reference System is a set of rules and geometries that
    define how addresses are assigned along thoroughfares and/or
    within a given area (Address Reference System Extent). At
    minimum, an Address Reference System must specify where Complete
    Address Number sequences begin and how Complete Address Numbers
    are assigned along the length of thoroughfares governed by the
    Address Reference System within the Address Reference System
    Extent. Address Reference Systems typically provide rules
    governing left-right parity of Complete Address Numbers,
    assignment of Street Names and street types, use of directionals
    and quadrants, and other aspects of address assignment.An
    Address Reference System that is based on axis lines, an Address
    Reference System Axis defined for each axis used to define
    address assignment. Each Address Reference System Axis must have
    an identified Address Reference System Axis Point Of Beginning.
    An Address Reference System is known by its Address Reference
    System Name (required). Additional business rules for an Address
    Reference System are described in the Address Reference System
    Rules."""
    subclass = None
    superclass = None
    def __init__(self, AddressReferenceSystemId=None, AddressReferenceSystemName=None, AddressReferenceSystemAuthority=None, AddressReferenceSystemExtent=None, AddressReferenceSystemType=None, AddressReferenceSystemRules=None, AddressReferenceSystemAxis=None, AddressReferenceSystemAxisPointOfBeginning=None, AddressReferenceSystemReferencePolyline=None, AddressReferenceSystemRangeBreakpoint=None, AddressReferenceSystemRangeBreakline=None, AddressReferenceSystemReferenceDocumentCitation=None):
        self.original_tagname_ = None
        self.AddressReferenceSystemId = AddressReferenceSystemId
        self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        self.AddressReferenceSystemName = AddressReferenceSystemName
        self.validate_AddressReferenceSystemName_type(self.AddressReferenceSystemName)
        self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
        self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
        self.AddressReferenceSystemExtent = AddressReferenceSystemExtent
        self.AddressReferenceSystemType = AddressReferenceSystemType
        self.validate_AddressReferenceSystemType_type(self.AddressReferenceSystemType)
        self.AddressReferenceSystemRules = AddressReferenceSystemRules
        self.AddressReferenceSystemAxis = AddressReferenceSystemAxis
        self.AddressReferenceSystemAxisPointOfBeginning = AddressReferenceSystemAxisPointOfBeginning
        if AddressReferenceSystemReferencePolyline is None:
            self.AddressReferenceSystemReferencePolyline = []
        else:
            self.AddressReferenceSystemReferencePolyline = AddressReferenceSystemReferencePolyline
        self.AddressReferenceSystemRangeBreakpoint = AddressReferenceSystemRangeBreakpoint
        if AddressReferenceSystemRangeBreakline is None:
            self.AddressReferenceSystemRangeBreakline = []
        else:
            self.AddressReferenceSystemRangeBreakline = AddressReferenceSystemRangeBreakline
        if AddressReferenceSystemReferenceDocumentCitation is None:
            self.AddressReferenceSystemReferenceDocumentCitation = []
        else:
            self.AddressReferenceSystemReferenceDocumentCitation = AddressReferenceSystemReferenceDocumentCitation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressReferenceSystem_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressReferenceSystem_type.subclass:
            return AddressReferenceSystem_type.subclass(*args_, **kwargs_)
        else:
            return AddressReferenceSystem_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressReferenceSystemId(self): return self.AddressReferenceSystemId
    def set_AddressReferenceSystemId(self, AddressReferenceSystemId): self.AddressReferenceSystemId = AddressReferenceSystemId
    def get_AddressReferenceSystemName(self): return self.AddressReferenceSystemName
    def set_AddressReferenceSystemName(self, AddressReferenceSystemName): self.AddressReferenceSystemName = AddressReferenceSystemName
    def get_AddressReferenceSystemAuthority(self): return self.AddressReferenceSystemAuthority
    def set_AddressReferenceSystemAuthority(self, AddressReferenceSystemAuthority): self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority
    def get_AddressReferenceSystemExtent(self): return self.AddressReferenceSystemExtent
    def set_AddressReferenceSystemExtent(self, AddressReferenceSystemExtent): self.AddressReferenceSystemExtent = AddressReferenceSystemExtent
    def get_AddressReferenceSystemType(self): return self.AddressReferenceSystemType
    def set_AddressReferenceSystemType(self, AddressReferenceSystemType): self.AddressReferenceSystemType = AddressReferenceSystemType
    def get_AddressReferenceSystemRules(self): return self.AddressReferenceSystemRules
    def set_AddressReferenceSystemRules(self, AddressReferenceSystemRules): self.AddressReferenceSystemRules = AddressReferenceSystemRules
    def get_AddressReferenceSystemAxis(self): return self.AddressReferenceSystemAxis
    def set_AddressReferenceSystemAxis(self, AddressReferenceSystemAxis): self.AddressReferenceSystemAxis = AddressReferenceSystemAxis
    def get_AddressReferenceSystemAxisPointOfBeginning(self): return self.AddressReferenceSystemAxisPointOfBeginning
    def set_AddressReferenceSystemAxisPointOfBeginning(self, AddressReferenceSystemAxisPointOfBeginning): self.AddressReferenceSystemAxisPointOfBeginning = AddressReferenceSystemAxisPointOfBeginning
    def get_AddressReferenceSystemReferencePolyline(self): return self.AddressReferenceSystemReferencePolyline
    def set_AddressReferenceSystemReferencePolyline(self, AddressReferenceSystemReferencePolyline): self.AddressReferenceSystemReferencePolyline = AddressReferenceSystemReferencePolyline
    def add_AddressReferenceSystemReferencePolyline(self, value): self.AddressReferenceSystemReferencePolyline.append(value)
    def insert_AddressReferenceSystemReferencePolyline_at(self, index, value): self.AddressReferenceSystemReferencePolyline.insert(index, value)
    def replace_AddressReferenceSystemReferencePolyline_at(self, index, value): self.AddressReferenceSystemReferencePolyline[index] = value
    def get_AddressReferenceSystemRangeBreakpoint(self): return self.AddressReferenceSystemRangeBreakpoint
    def set_AddressReferenceSystemRangeBreakpoint(self, AddressReferenceSystemRangeBreakpoint): self.AddressReferenceSystemRangeBreakpoint = AddressReferenceSystemRangeBreakpoint
    def get_AddressReferenceSystemRangeBreakline(self): return self.AddressReferenceSystemRangeBreakline
    def set_AddressReferenceSystemRangeBreakline(self, AddressReferenceSystemRangeBreakline): self.AddressReferenceSystemRangeBreakline = AddressReferenceSystemRangeBreakline
    def add_AddressReferenceSystemRangeBreakline(self, value): self.AddressReferenceSystemRangeBreakline.append(value)
    def insert_AddressReferenceSystemRangeBreakline_at(self, index, value): self.AddressReferenceSystemRangeBreakline.insert(index, value)
    def replace_AddressReferenceSystemRangeBreakline_at(self, index, value): self.AddressReferenceSystemRangeBreakline[index] = value
    def get_AddressReferenceSystemReferenceDocumentCitation(self): return self.AddressReferenceSystemReferenceDocumentCitation
    def set_AddressReferenceSystemReferenceDocumentCitation(self, AddressReferenceSystemReferenceDocumentCitation): self.AddressReferenceSystemReferenceDocumentCitation = AddressReferenceSystemReferenceDocumentCitation
    def add_AddressReferenceSystemReferenceDocumentCitation(self, value): self.AddressReferenceSystemReferenceDocumentCitation.append(value)
    def insert_AddressReferenceSystemReferenceDocumentCitation_at(self, index, value): self.AddressReferenceSystemReferenceDocumentCitation.insert(index, value)
    def replace_AddressReferenceSystemReferenceDocumentCitation_at(self, index, value): self.AddressReferenceSystemReferenceDocumentCitation[index] = value
    def validate_AddressReferenceSystemId_type(self, value):
        # Validate type AddressReferenceSystemId_type, a restriction on xsd:integer.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemName_type(self, value):
        # Validate type AddressReferenceSystemName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemAuthority_type(self, value):
        # Validate type AddressReferenceSystemAuthority_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressReferenceSystemType_type(self, value):
        # Validate type AddressReferenceSystemType_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Axial', 'Grid', 'Radial', 'Linear Non-Axial', 'Distance', 'Area Based']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressReferenceSystemType_type' % {"value" : value.encode("utf-8")} )
    def validate_AddressReferenceSystemReferenceDocumentCitation_type(self, value):
        # Validate type AddressReferenceSystemReferenceDocumentCitation_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.AddressReferenceSystemId is not None or
            self.AddressReferenceSystemName is not None or
            self.AddressReferenceSystemAuthority is not None or
            self.AddressReferenceSystemExtent is not None or
            self.AddressReferenceSystemType is not None or
            self.AddressReferenceSystemRules is not None or
            self.AddressReferenceSystemAxis is not None or
            self.AddressReferenceSystemAxisPointOfBeginning is not None or
            self.AddressReferenceSystemReferencePolyline or
            self.AddressReferenceSystemRangeBreakpoint is not None or
            self.AddressReferenceSystemRangeBreakline or
            self.AddressReferenceSystemReferenceDocumentCitation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystem_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressReferenceSystem_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressReferenceSystem_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressReferenceSystem_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressReferenceSystem_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressReferenceSystem_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressReferenceSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemId>%s</addr:AddressReferenceSystemId>%s' % (self.gds_format_integer(self.AddressReferenceSystemId, input_name='AddressReferenceSystemId'), eol_))
        if self.AddressReferenceSystemName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemName>%s</addr:AddressReferenceSystemName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemName), input_name='AddressReferenceSystemName')), eol_))
        if self.AddressReferenceSystemAuthority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemAuthority>%s</addr:AddressReferenceSystemAuthority>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemAuthority), input_name='AddressReferenceSystemAuthority')), eol_))
        if self.AddressReferenceSystemExtent is not None:
            self.AddressReferenceSystemExtent.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemExtent', pretty_print=pretty_print)
        if self.AddressReferenceSystemType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemType>%s</addr:AddressReferenceSystemType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressReferenceSystemType), input_name='AddressReferenceSystemType')), eol_))
        if self.AddressReferenceSystemRules is not None:
            self.AddressReferenceSystemRules.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemRules', pretty_print=pretty_print)
        if self.AddressReferenceSystemAxis is not None:
            self.AddressReferenceSystemAxis.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemAxis', pretty_print=pretty_print)
        if self.AddressReferenceSystemAxisPointOfBeginning is not None:
            self.AddressReferenceSystemAxisPointOfBeginning.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemAxisPointOfBeginning', pretty_print=pretty_print)
        for AddressReferenceSystemReferencePolyline_ in self.AddressReferenceSystemReferencePolyline:
            AddressReferenceSystemReferencePolyline_.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemReferencePolyline', pretty_print=pretty_print)
        if self.AddressReferenceSystemRangeBreakpoint is not None:
            self.AddressReferenceSystemRangeBreakpoint.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemRangeBreakpoint', pretty_print=pretty_print)
        for AddressReferenceSystemRangeBreakline_ in self.AddressReferenceSystemRangeBreakline:
            AddressReferenceSystemRangeBreakline_.export(outfile, level, namespaceprefix_, name_='AddressReferenceSystemRangeBreakline', pretty_print=pretty_print)
        for AddressReferenceSystemReferenceDocumentCitation_ in self.AddressReferenceSystemReferenceDocumentCitation:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressReferenceSystemReferenceDocumentCitation>%s</addr:AddressReferenceSystemReferenceDocumentCitation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AddressReferenceSystemReferenceDocumentCitation_), input_name='AddressReferenceSystemReferenceDocumentCitation')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressReferenceSystemId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AddressReferenceSystemId')
            self.AddressReferenceSystemId = ival_
            # validate type AddressReferenceSystemId_type
            self.validate_AddressReferenceSystemId_type(self.AddressReferenceSystemId)
        elif nodeName_ == 'AddressReferenceSystemName':
            AddressReferenceSystemName_ = child_.text
            AddressReferenceSystemName_ = self.gds_validate_string(AddressReferenceSystemName_, node, 'AddressReferenceSystemName')
            self.AddressReferenceSystemName = AddressReferenceSystemName_
            # validate type AddressReferenceSystemName_type
            self.validate_AddressReferenceSystemName_type(self.AddressReferenceSystemName)
        elif nodeName_ == 'AddressReferenceSystemAuthority':
            AddressReferenceSystemAuthority_ = child_.text
            AddressReferenceSystemAuthority_ = self.gds_validate_string(AddressReferenceSystemAuthority_, node, 'AddressReferenceSystemAuthority')
            self.AddressReferenceSystemAuthority = AddressReferenceSystemAuthority_
            # validate type AddressReferenceSystemAuthority_type
            self.validate_AddressReferenceSystemAuthority_type(self.AddressReferenceSystemAuthority)
        elif nodeName_ == 'AddressReferenceSystemExtent':
            obj_ = AddressReferenceSystemExtent_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemExtent = obj_
            obj_.original_tagname_ = 'AddressReferenceSystemExtent'
        elif nodeName_ == 'AddressReferenceSystemType':
            AddressReferenceSystemType_ = child_.text
            AddressReferenceSystemType_ = self.gds_validate_string(AddressReferenceSystemType_, node, 'AddressReferenceSystemType')
            self.AddressReferenceSystemType = AddressReferenceSystemType_
            # validate type AddressReferenceSystemType_type
            self.validate_AddressReferenceSystemType_type(self.AddressReferenceSystemType)
        elif nodeName_ == 'AddressReferenceSystemRules':
            obj_ = AddressReferenceSystemRules_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemRules = obj_
            obj_.original_tagname_ = 'AddressReferenceSystemRules'
        elif nodeName_ == 'AddressReferenceSystemAxis':
            obj_ = AddressReferenceSystemAxis_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemAxis = obj_
            obj_.original_tagname_ = 'AddressReferenceSystemAxis'
        elif nodeName_ == 'AddressReferenceSystemAxisPointOfBeginning':
            obj_ = AddressReferenceSystemAxisPointOfBeginning_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemAxisPointOfBeginning = obj_
            obj_.original_tagname_ = 'AddressReferenceSystemAxisPointOfBeginning'
        elif nodeName_ == 'AddressReferenceSystemReferencePolyline':
            obj_ = AddressReferenceSystemReferencePolyline_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemReferencePolyline.append(obj_)
            obj_.original_tagname_ = 'AddressReferenceSystemReferencePolyline'
        elif nodeName_ == 'AddressReferenceSystemRangeBreakpoint':
            obj_ = AddressReferenceSystemRangeBreakpoint_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemRangeBreakpoint = obj_
            obj_.original_tagname_ = 'AddressReferenceSystemRangeBreakpoint'
        elif nodeName_ == 'AddressReferenceSystemRangeBreakline':
            obj_ = AddressReferenceSystemRangeBreakline_type.factory()
            obj_.build(child_)
            self.AddressReferenceSystemRangeBreakline.append(obj_)
            obj_.original_tagname_ = 'AddressReferenceSystemRangeBreakline'
        elif nodeName_ == 'AddressReferenceSystemReferenceDocumentCitation':
            AddressReferenceSystemReferenceDocumentCitation_ = child_.text
            AddressReferenceSystemReferenceDocumentCitation_ = self.gds_validate_string(AddressReferenceSystemReferenceDocumentCitation_, node, 'AddressReferenceSystemReferenceDocumentCitation')
            self.AddressReferenceSystemReferenceDocumentCitation.append(AddressReferenceSystemReferenceDocumentCitation_)
            # validate type AddressReferenceSystemReferenceDocumentCitation_type
            self.validate_AddressReferenceSystemReferenceDocumentCitation_type(self.AddressReferenceSystemReferenceDocumentCitation[-1])
# end class AddressReferenceSystem_type


class RelatedAddressID_type(GeneratedsSuper):
    """The identifier of an address that is related to the identifier of
    another address."""
    subclass = None
    superclass = None
    def __init__(self, AddressRelationType=None, valueOf_=None):
        self.original_tagname_ = None
        self.AddressRelationType = _cast(None, AddressRelationType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RelatedAddressID_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RelatedAddressID_type.subclass:
            return RelatedAddressID_type.subclass(*args_, **kwargs_)
        else:
            return RelatedAddressID_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressRelationType(self): return self.AddressRelationType
    def set_AddressRelationType(self, AddressRelationType): self.AddressRelationType = AddressRelationType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='RelatedAddressID_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RelatedAddressID_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RelatedAddressID_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='RelatedAddressID_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='RelatedAddressID_type'):
        if self.AddressRelationType is not None and 'AddressRelationType' not in already_processed:
            already_processed.add('AddressRelationType')
            outfile.write(' AddressRelationType=%s' % (quote_attrib(self.AddressRelationType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='RelatedAddressID_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AddressRelationType', node)
        if value is not None and 'AddressRelationType' not in already_processed:
            already_processed.add('AddressRelationType')
            self.AddressRelationType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RelatedAddressID_type


class StreetNameGroup(GeneratedsSuper):
    """A geographic area where the street names conform to a theme. For
    example, some neighborhoods feature streets named for birds, US
    presidents or trees. A subset of the complete street name domain
    applies to this area."""
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StreetNameGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StreetNameGroup.subclass:
            return StreetNameGroup.subclass(*args_, **kwargs_)
        else:
            return StreetNameGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='StreetNameGroup', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StreetNameGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StreetNameGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='StreetNameGroup', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='StreetNameGroup'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='StreetNameGroup', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StreetNameGroup


class AddressSchemeOrigin_type(GeneratedsSuper):
    """Location where the address axes meet."""
    subclass = None
    superclass = None
    def __init__(self, OriginValue=None, AxisId=None):
        self.original_tagname_ = None
        self.OriginValue = _cast(int, OriginValue)
        self.AxisId = _cast(None, AxisId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressSchemeOrigin_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressSchemeOrigin_type.subclass:
            return AddressSchemeOrigin_type.subclass(*args_, **kwargs_)
        else:
            return AddressSchemeOrigin_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OriginValue(self): return self.OriginValue
    def set_OriginValue(self, OriginValue): self.OriginValue = OriginValue
    def get_AxisId(self): return self.AxisId
    def set_AxisId(self, AxisId): self.AxisId = AxisId
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressSchemeOrigin_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressSchemeOrigin_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressSchemeOrigin_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressSchemeOrigin_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressSchemeOrigin_type'):
        if self.OriginValue is not None and 'OriginValue' not in already_processed:
            already_processed.add('OriginValue')
            outfile.write(' OriginValue="%s"' % self.gds_format_integer(self.OriginValue, input_name='OriginValue'))
        if self.AxisId is not None and 'AxisId' not in already_processed:
            already_processed.add('AxisId')
            outfile.write(' AxisId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.AxisId), input_name='AxisId')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressSchemeOrigin_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OriginValue', node)
        if value is not None and 'OriginValue' not in already_processed:
            already_processed.add('OriginValue')
            try:
                self.OriginValue = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('AxisId', node)
        if value is not None and 'AxisId' not in already_processed:
            already_processed.add('AxisId')
            self.AxisId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressSchemeOrigin_type


class AddressSchemeAxes_type(GeneratedsSuper):
    """Address axes define the boundaries between adjoining zones in
    address schema. Those zones may be quadrants (northwest,
    northeast, southeast, southwest) or other geographic divisions.
    Lowest address numbers occur nearest an axis."""
    subclass = None
    superclass = None
    def __init__(self, AxisId=None):
        self.original_tagname_ = None
        self.AxisId = _cast(None, AxisId)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressSchemeAxes_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressSchemeAxes_type.subclass:
            return AddressSchemeAxes_type.subclass(*args_, **kwargs_)
        else:
            return AddressSchemeAxes_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AxisId(self): return self.AxisId
    def set_AxisId(self, AxisId): self.AxisId = AxisId
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressSchemeAxes_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressSchemeAxes_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressSchemeAxes_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressSchemeAxes_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressSchemeAxes_type'):
        if self.AxisId is not None and 'AxisId' not in already_processed:
            already_processed.add('AxisId')
            outfile.write(' AxisId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.AxisId), input_name='AxisId')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressSchemeAxes_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AxisId', node)
        if value is not None and 'AxisId' not in already_processed:
            already_processed.add('AxisId')
            self.AxisId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressSchemeAxes_type


class AddressSchemeExtent_type(GeneratedsSuper):
    """Boundary of the area over which an address schema is used when
    assiging addresses."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressSchemeExtent_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressSchemeExtent_type.subclass:
            return AddressSchemeExtent_type.subclass(*args_, **kwargs_)
        else:
            return AddressSchemeExtent_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressSchemeExtent_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressSchemeExtent_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressSchemeExtent_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressSchemeExtent_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressSchemeExtent_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressSchemeExtent_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressSchemeExtent_type


class DeliveryAddress_type(GeneratedsSuper):
    """The entire address, unparsed, except for the Place Name, State Name,
    Zip Code, Zip Plus 4, Country Name, and, optionally, Complete
    Subaddress elements."""
    subclass = None
    superclass = None
    def __init__(self, DeliveryAddressType=None, valueOf_=None):
        self.original_tagname_ = None
        self.DeliveryAddressType = _cast(None, DeliveryAddressType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeliveryAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeliveryAddress_type.subclass:
            return DeliveryAddress_type.subclass(*args_, **kwargs_)
        else:
            return DeliveryAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DeliveryAddressType(self): return self.DeliveryAddressType
    def set_DeliveryAddressType(self, DeliveryAddressType): self.DeliveryAddressType = DeliveryAddressType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='DeliveryAddress_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeliveryAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeliveryAddress_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='DeliveryAddress_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='DeliveryAddress_type'):
        if self.DeliveryAddressType is not None and 'DeliveryAddressType' not in already_processed:
            already_processed.add('DeliveryAddressType')
            outfile.write(' DeliveryAddressType=%s' % (quote_attrib(self.DeliveryAddressType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='DeliveryAddress_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DeliveryAddressType', node)
        if value is not None and 'DeliveryAddressType' not in already_processed:
            already_processed.add('DeliveryAddressType')
            self.DeliveryAddressType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeliveryAddress_type


class FeatureOccupancy_type(GeneratedsSuper):
    """This element is defined solely for use with the General Address
    class, which is constructed to accommodate and mix addresses of
    all types (e.g., a general postal mailing list or contact list).
    Place Name, State Name, Zip Code, and Zip Plus 4, which appear
    in all address classes, are kept separate from the rest of the
    address. No longer a parsed datatype. Content still represents
    it as such."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FeatureOccupancy_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FeatureOccupancy_type.subclass:
            return FeatureOccupancy_type.subclass(*args_, **kwargs_)
        else:
            return FeatureOccupancy_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='FeatureOccupancy_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FeatureOccupancy_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FeatureOccupancy_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='FeatureOccupancy_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='FeatureOccupancy_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='FeatureOccupancy_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FeatureOccupancy_type


class GeneralAddress_type(GeneratedsSuper):
    """This element is defined solely for use with the General Address
    class, which is constructed to accommodate and mix addresses of
    all types (e.g., a general postal mailing list or contact list).
    Place Name, State Name, Zip Code, and Zip Plus 4, which appear
    in all address classes, are kept separate from the rest of the
    address. No longer a parsed datatype. Content still represents
    it as such."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralAddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralAddress_type.subclass:
            return GeneralAddress_type.subclass(*args_, **kwargs_)
        else:
            return GeneralAddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='GeneralAddress_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeneralAddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeneralAddress_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='GeneralAddress_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='GeneralAddress_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='GeneralAddress_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GeneralAddress_type


class LocationXY_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X=None, Y=None):
        self.original_tagname_ = None
        self.X = X
        self.validate_AddressXCoordinate_type(self.X)
        self.Y = Y
        self.validate_AddressYCoordinate_type(self.Y)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationXY_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationXY_type.subclass:
            return LocationXY_type.subclass(*args_, **kwargs_)
        else:
            return LocationXY_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def validate_AddressXCoordinate_type(self, value):
        # Validate type AddressXCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressYCoordinate_type(self, value):
        # Validate type AddressYCoordinate_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.X is not None or
            self.Y is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='LocationXY_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationXY_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocationXY_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='LocationXY_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='LocationXY_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='LocationXY_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:X>%s</addr:X>%s' % (self.gds_format_double(self.X, input_name='X'), eol_))
        if self.Y is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:Y>%s</addr:Y>%s' % (self.gds_format_double(self.Y, input_name='Y'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'X')
            self.X = fval_
            # validate type AddressXCoordinate_type
            self.validate_AddressXCoordinate_type(self.X)
        elif nodeName_ == 'Y' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Y')
            self.Y = fval_
            # validate type AddressYCoordinate_type
            self.validate_AddressYCoordinate_type(self.Y)
# end class LocationXY_type


class LocationLongLat_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Longitude=None, Latitude=None):
        self.original_tagname_ = None
        self.Longitude = Longitude
        self.validate_AddressLongitude_type(self.Longitude)
        self.Latitude = Latitude
        self.validate_AddressLatitude_type(self.Latitude)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocationLongLat_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocationLongLat_type.subclass:
            return LocationLongLat_type.subclass(*args_, **kwargs_)
        else:
            return LocationLongLat_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def validate_AddressLongitude_type(self, value):
        # Validate type AddressLongitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_AddressLatitude_type(self, value):
        # Validate type AddressLatitude_type, a restriction on xsd:double.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Longitude is not None or
            self.Latitude is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='LocationLongLat_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocationLongLat_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocationLongLat_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='LocationLongLat_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='LocationLongLat_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='LocationLongLat_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Longitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:Longitude>%s</addr:Longitude>%s' % (self.gds_format_double(self.Longitude, input_name='Longitude'), eol_))
        if self.Latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:Latitude>%s</addr:Latitude>%s' % (self.gds_format_double(self.Latitude, input_name='Latitude'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Longitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Longitude')
            self.Longitude = fval_
            # validate type AddressLongitude_type
            self.validate_AddressLongitude_type(self.Longitude)
        elif nodeName_ == 'Latitude' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Latitude')
            self.Latitude = fval_
            # validate type AddressLatitude_type
            self.validate_AddressLatitude_type(self.Latitude)
# end class LocationLongLat_type


class Location_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, USNGCoordinate=None, LongLat=None, XYCoordinate=None, AdressZLevel=None):
        self.original_tagname_ = None
        self.USNGCoordinate = USNGCoordinate
        self.validate_LocationUSNG_type(self.USNGCoordinate)
        self.LongLat = LongLat
        self.XYCoordinate = XYCoordinate
        self.AdressZLevel = AdressZLevel
        self.validate_AddressZLevel_type(self.AdressZLevel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Location_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Location_type.subclass:
            return Location_type.subclass(*args_, **kwargs_)
        else:
            return Location_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_USNGCoordinate(self): return self.USNGCoordinate
    def set_USNGCoordinate(self, USNGCoordinate): self.USNGCoordinate = USNGCoordinate
    def get_LongLat(self): return self.LongLat
    def set_LongLat(self, LongLat): self.LongLat = LongLat
    def get_XYCoordinate(self): return self.XYCoordinate
    def set_XYCoordinate(self, XYCoordinate): self.XYCoordinate = XYCoordinate
    def get_AdressZLevel(self): return self.AdressZLevel
    def set_AdressZLevel(self, AdressZLevel): self.AdressZLevel = AdressZLevel
    def validate_LocationUSNG_type(self, value):
        # Validate type LocationUSNG_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_LocationUSNG_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_LocationUSNG_type_patterns_, ))
    validate_LocationUSNG_type_patterns_ = [['^.*$']]
    def validate_AddressZLevel_type(self, value):
        # Validate type AddressZLevel_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressZLevel_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressZLevel_type_patterns_, ))
    validate_AddressZLevel_type_patterns_ = [['^.*$']]
    def hasContent_(self):
        if (
            self.USNGCoordinate is not None or
            self.LongLat is not None or
            self.XYCoordinate is not None or
            self.AdressZLevel is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='Location_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Location_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Location_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='Location_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='Location_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='Location_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.USNGCoordinate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:USNGCoordinate>%s</addr:USNGCoordinate>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.USNGCoordinate), input_name='USNGCoordinate')), eol_))
        if self.LongLat is not None:
            self.LongLat.export(outfile, level, namespaceprefix_, name_='LongLat', pretty_print=pretty_print)
        if self.XYCoordinate is not None:
            self.XYCoordinate.export(outfile, level, namespaceprefix_, name_='XYCoordinate', pretty_print=pretty_print)
        if self.AdressZLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AdressZLevel>%s</addr:AdressZLevel>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AdressZLevel), input_name='AdressZLevel')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'USNGCoordinate':
            USNGCoordinate_ = child_.text
            USNGCoordinate_ = self.gds_validate_string(USNGCoordinate_, node, 'USNGCoordinate')
            self.USNGCoordinate = USNGCoordinate_
            # validate type LocationUSNG_type
            self.validate_LocationUSNG_type(self.USNGCoordinate)
        elif nodeName_ == 'LongLat':
            obj_ = LocationLongLat_type.factory()
            obj_.build(child_)
            self.LongLat = obj_
            obj_.original_tagname_ = 'LongLat'
        elif nodeName_ == 'XYCoordinate':
            obj_ = LocationXY_type.factory()
            obj_.build(child_)
            self.XYCoordinate = obj_
            obj_.original_tagname_ = 'XYCoordinate'
        elif nodeName_ == 'AdressZLevel':
            AdressZLevel_ = child_.text
            AdressZLevel_ = self.gds_validate_string(AdressZLevel_, node, 'AdressZLevel')
            self.AdressZLevel = AdressZLevel_
            # validate type AddressZLevel_type
            self.validate_AddressZLevel_type(self.AdressZLevel)
# end class Location_type


class CompleteStreetName_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AttachedElement=None, StreetNamePreModifier=None, StreetNamePreDirectional=None, StreetNamePreType=None, StreetName=None, StreetNamePostType=None, StreetNamePostDirectional=None, StreetNamePostModifier=None):
        self.original_tagname_ = None
        self.AttachedElement = _cast(None, AttachedElement)
        self.StreetNamePreModifier = StreetNamePreModifier
        self.StreetNamePreDirectional = StreetNamePreDirectional
        self.StreetNamePreType = StreetNamePreType
        self.StreetName = StreetName
        self.validate_StreetName_type(self.StreetName)
        self.StreetNamePostType = StreetNamePostType
        self.StreetNamePostDirectional = StreetNamePostDirectional
        self.StreetNamePostModifier = StreetNamePostModifier
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompleteStreetName_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompleteStreetName_type.subclass:
            return CompleteStreetName_type.subclass(*args_, **kwargs_)
        else:
            return CompleteStreetName_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StreetNamePreModifier(self): return self.StreetNamePreModifier
    def set_StreetNamePreModifier(self, StreetNamePreModifier): self.StreetNamePreModifier = StreetNamePreModifier
    def get_StreetNamePreDirectional(self): return self.StreetNamePreDirectional
    def set_StreetNamePreDirectional(self, StreetNamePreDirectional): self.StreetNamePreDirectional = StreetNamePreDirectional
    def get_StreetNamePreType(self): return self.StreetNamePreType
    def set_StreetNamePreType(self, StreetNamePreType): self.StreetNamePreType = StreetNamePreType
    def get_StreetName(self): return self.StreetName
    def set_StreetName(self, StreetName): self.StreetName = StreetName
    def get_StreetNamePostType(self): return self.StreetNamePostType
    def set_StreetNamePostType(self, StreetNamePostType): self.StreetNamePostType = StreetNamePostType
    def get_StreetNamePostDirectional(self): return self.StreetNamePostDirectional
    def set_StreetNamePostDirectional(self, StreetNamePostDirectional): self.StreetNamePostDirectional = StreetNamePostDirectional
    def get_StreetNamePostModifier(self): return self.StreetNamePostModifier
    def set_StreetNamePostModifier(self, StreetNamePostModifier): self.StreetNamePostModifier = StreetNamePostModifier
    def get_AttachedElement(self): return self.AttachedElement
    def set_AttachedElement(self, AttachedElement): self.AttachedElement = AttachedElement
    def validate_StreetName_type(self, value):
        # Validate type StreetName_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_StreetName_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_StreetName_type_patterns_, ))
    validate_StreetName_type_patterns_ = [['^.*$']]
    def hasContent_(self):
        if (
            self.StreetNamePreModifier is not None or
            self.StreetNamePreDirectional is not None or
            self.StreetNamePreType is not None or
            self.StreetName is not None or
            self.StreetNamePostType is not None or
            self.StreetNamePostDirectional is not None or
            self.StreetNamePostModifier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='CompleteStreetName_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompleteStreetName_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompleteStreetName_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='CompleteStreetName_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='CompleteStreetName_type'):
        if self.AttachedElement is not None and 'AttachedElement' not in already_processed:
            already_processed.add('AttachedElement')
            outfile.write(' AttachedElement=%s' % (quote_attrib(self.AttachedElement), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='CompleteStreetName_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StreetNamePreModifier is not None:
            self.StreetNamePreModifier.export(outfile, level, namespaceprefix_, name_='StreetNamePreModifier', pretty_print=pretty_print)
        if self.StreetNamePreDirectional is not None:
            self.StreetNamePreDirectional.export(outfile, level, namespaceprefix_, name_='StreetNamePreDirectional', pretty_print=pretty_print)
        if self.StreetNamePreType is not None:
            self.StreetNamePreType.export(outfile, level, namespaceprefix_, name_='StreetNamePreType', pretty_print=pretty_print)
        if self.StreetName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:StreetName>%s</addr:StreetName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.StreetName), input_name='StreetName')), eol_))
        if self.StreetNamePostType is not None:
            self.StreetNamePostType.export(outfile, level, namespaceprefix_, name_='StreetNamePostType', pretty_print=pretty_print)
        if self.StreetNamePostDirectional is not None:
            self.StreetNamePostDirectional.export(outfile, level, namespaceprefix_, name_='StreetNamePostDirectional', pretty_print=pretty_print)
        if self.StreetNamePostModifier is not None:
            self.StreetNamePostModifier.export(outfile, level, namespaceprefix_, name_='StreetNamePostModifier', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AttachedElement', node)
        if value is not None and 'AttachedElement' not in already_processed:
            already_processed.add('AttachedElement')
            self.AttachedElement = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StreetNamePreModifier':
            obj_ = StreetNamePreModifier_type.factory()
            obj_.build(child_)
            self.StreetNamePreModifier = obj_
            obj_.original_tagname_ = 'StreetNamePreModifier'
        elif nodeName_ == 'StreetNamePreDirectional':
            obj_ = StreetNamePreDirectional_type.factory()
            obj_.build(child_)
            self.StreetNamePreDirectional = obj_
            obj_.original_tagname_ = 'StreetNamePreDirectional'
        elif nodeName_ == 'StreetNamePreType':
            obj_ = StreetNamePreType_type.factory()
            obj_.build(child_)
            self.StreetNamePreType = obj_
            obj_.original_tagname_ = 'StreetNamePreType'
        elif nodeName_ == 'StreetName':
            StreetName_ = child_.text
            StreetName_ = self.gds_validate_string(StreetName_, node, 'StreetName')
            self.StreetName = StreetName_
            # validate type StreetName_type
            self.validate_StreetName_type(self.StreetName)
        elif nodeName_ == 'StreetNamePostType':
            obj_ = StreetNamePreType_type.factory()
            obj_.build(child_)
            self.StreetNamePostType = obj_
            obj_.original_tagname_ = 'StreetNamePostType'
        elif nodeName_ == 'StreetNamePostDirectional':
            obj_ = StreetNamePreDirectional_type.factory()
            obj_.build(child_)
            self.StreetNamePostDirectional = obj_
            obj_.original_tagname_ = 'StreetNamePostDirectional'
        elif nodeName_ == 'StreetNamePostModifier':
            obj_ = StreetNamePreModifier_type.factory()
            obj_.build(child_)
            self.StreetNamePostModifier = obj_
            obj_.original_tagname_ = 'StreetNamePostModifier'
# end class CompleteStreetName_type


class CompleteAddressNumber_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AddressNumberParity=None, AttachedElement=None, AddressNumberPrefix=None, AddressNumber=None, AddressNumberSuffix=None):
        self.original_tagname_ = None
        self.AddressNumberParity = _cast(None, AddressNumberParity)
        self.AttachedElement = _cast(None, AttachedElement)
        self.AddressNumberPrefix = AddressNumberPrefix
        self.AddressNumber = AddressNumber
        self.validate_AddressNumber_type(self.AddressNumber)
        self.AddressNumberSuffix = AddressNumberSuffix
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompleteAddressNumber_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompleteAddressNumber_type.subclass:
            return CompleteAddressNumber_type.subclass(*args_, **kwargs_)
        else:
            return CompleteAddressNumber_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressNumberPrefix(self): return self.AddressNumberPrefix
    def set_AddressNumberPrefix(self, AddressNumberPrefix): self.AddressNumberPrefix = AddressNumberPrefix
    def get_AddressNumber(self): return self.AddressNumber
    def set_AddressNumber(self, AddressNumber): self.AddressNumber = AddressNumber
    def get_AddressNumberSuffix(self): return self.AddressNumberSuffix
    def set_AddressNumberSuffix(self, AddressNumberSuffix): self.AddressNumberSuffix = AddressNumberSuffix
    def get_AddressNumberParity(self): return self.AddressNumberParity
    def set_AddressNumberParity(self, AddressNumberParity): self.AddressNumberParity = AddressNumberParity
    def get_AttachedElement(self): return self.AttachedElement
    def set_AttachedElement(self, AttachedElement): self.AttachedElement = AttachedElement
    def validate_AddressNumber_type(self, value):
        # Validate type AddressNumber_type, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AddressNumber_type_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AddressNumber_type_patterns_, ))
    validate_AddressNumber_type_patterns_ = [['^[0-9]+$']]
    def hasContent_(self):
        if (
            self.AddressNumberPrefix is not None or
            self.AddressNumber is not None or
            self.AddressNumberSuffix is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='CompleteAddressNumber_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompleteAddressNumber_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompleteAddressNumber_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='CompleteAddressNumber_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='CompleteAddressNumber_type'):
        if self.AddressNumberParity is not None and 'AddressNumberParity' not in already_processed:
            already_processed.add('AddressNumberParity')
            outfile.write(' AddressNumberParity=%s' % (quote_attrib(self.AddressNumberParity), ))
        if self.AttachedElement is not None and 'AttachedElement' not in already_processed:
            already_processed.add('AttachedElement')
            outfile.write(' AttachedElement=%s' % (quote_attrib(self.AttachedElement), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='CompleteAddressNumber_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AddressNumberPrefix is not None:
            self.AddressNumberPrefix.export(outfile, level, namespaceprefix_, name_='AddressNumberPrefix', pretty_print=pretty_print)
        if self.AddressNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<addr:AddressNumber>%s</addr:AddressNumber>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.AddressNumber), input_name='AddressNumber')), eol_))
        if self.AddressNumberSuffix is not None:
            self.AddressNumberSuffix.export(outfile, level, namespaceprefix_, name_='AddressNumberSuffix', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('AddressNumberParity', node)
        if value is not None and 'AddressNumberParity' not in already_processed:
            already_processed.add('AddressNumberParity')
            self.AddressNumberParity = value
        value = find_attr_value_('AttachedElement', node)
        if value is not None and 'AttachedElement' not in already_processed:
            already_processed.add('AttachedElement')
            self.AttachedElement = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressNumberPrefix':
            obj_ = AddressNumberPrefix_type.factory()
            obj_.build(child_)
            self.AddressNumberPrefix = obj_
            obj_.original_tagname_ = 'AddressNumberPrefix'
        elif nodeName_ == 'AddressNumber':
            AddressNumber_ = child_.text
            AddressNumber_ = self.gds_validate_string(AddressNumber_, node, 'AddressNumber')
            self.AddressNumber = AddressNumber_
            # validate type AddressNumber_type
            self.validate_AddressNumber_type(self.AddressNumber)
        elif nodeName_ == 'AddressNumberSuffix':
            obj_ = AddressNumberSuffix_type.factory()
            obj_.build(child_)
            self.AddressNumberSuffix = obj_
            obj_.original_tagname_ = 'AddressNumberSuffix'
# end class CompleteAddressNumber_type


class AddressNumberRange_type(GeneratedsSuper):
    """{ Complete Address Number (low)*} + { Separator Element *} + {
    Complete Address Number (high)*} A set of two address numbers,
    separated by a "Separator", representing the low and high
    numbers of an address range. An address number range element
    should be accompanied by an Address Range Type Attribute that
    describes the type of range presented in this element."""
    subclass = None
    superclass = None
    def __init__(self, Separator=None, Parity=None, Side=None, CompleteAddressNumber=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        self.Parity = _cast(None, Parity)
        self.Side = _cast(None, Side)
        if CompleteAddressNumber is None:
            self.CompleteAddressNumber = []
        else:
            self.CompleteAddressNumber = CompleteAddressNumber
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressNumberRange_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressNumberRange_type.subclass:
            return AddressNumberRange_type.subclass(*args_, **kwargs_)
        else:
            return AddressNumberRange_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CompleteAddressNumber(self): return self.CompleteAddressNumber
    def set_CompleteAddressNumber(self, CompleteAddressNumber): self.CompleteAddressNumber = CompleteAddressNumber
    def add_CompleteAddressNumber(self, value): self.CompleteAddressNumber.append(value)
    def insert_CompleteAddressNumber_at(self, index, value): self.CompleteAddressNumber.insert(index, value)
    def replace_CompleteAddressNumber_at(self, index, value): self.CompleteAddressNumber[index] = value
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def get_Parity(self): return self.Parity
    def set_Parity(self, Parity): self.Parity = Parity
    def get_Side(self): return self.Side
    def set_Side(self, Side): self.Side = Side
    def hasContent_(self):
        if (
            self.CompleteAddressNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='AddressNumberRange_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressNumberRange_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressNumberRange_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='AddressNumberRange_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='AddressNumberRange_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
        if self.Parity is not None and 'Parity' not in already_processed:
            already_processed.add('Parity')
            outfile.write(' Parity=%s' % (quote_attrib(self.Parity), ))
        if self.Side is not None and 'Side' not in already_processed:
            already_processed.add('Side')
            outfile.write(' Side=%s' % (quote_attrib(self.Side), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='AddressNumberRange_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CompleteAddressNumber_ in self.CompleteAddressNumber:
            CompleteAddressNumber_.export(outfile, level, namespaceprefix_, name_='CompleteAddressNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
        value = find_attr_value_('Parity', node)
        if value is not None and 'Parity' not in already_processed:
            already_processed.add('Parity')
            self.Parity = value
        value = find_attr_value_('Side', node)
        if value is not None and 'Side' not in already_processed:
            already_processed.add('Side')
            self.Side = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CompleteAddressNumber':
            obj_ = CompleteAddressNumber_type.factory()
            obj_.build(child_)
            self.CompleteAddressNumber.append(obj_)
            obj_.original_tagname_ = 'CompleteAddressNumber'
# end class AddressNumberRange_type


class PlaceName_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PlaceNameType=None, ElementSequenceNumber=None, GNISFeatureID=None, valueOf_=None):
        self.original_tagname_ = None
        self.PlaceNameType = _cast(None, PlaceNameType)
        self.ElementSequenceNumber = _cast(None, ElementSequenceNumber)
        self.GNISFeatureID = _cast(None, GNISFeatureID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PlaceName_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PlaceName_type.subclass:
            return PlaceName_type.subclass(*args_, **kwargs_)
        else:
            return PlaceName_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PlaceNameType(self): return self.PlaceNameType
    def set_PlaceNameType(self, PlaceNameType): self.PlaceNameType = PlaceNameType
    def get_ElementSequenceNumber(self): return self.ElementSequenceNumber
    def set_ElementSequenceNumber(self, ElementSequenceNumber): self.ElementSequenceNumber = ElementSequenceNumber
    def get_GNISFeatureID(self): return self.GNISFeatureID
    def set_GNISFeatureID(self, GNISFeatureID): self.GNISFeatureID = GNISFeatureID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='PlaceName_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PlaceName_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PlaceName_type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='PlaceName_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='PlaceName_type'):
        if self.PlaceNameType is not None and 'PlaceNameType' not in already_processed:
            already_processed.add('PlaceNameType')
            outfile.write(' PlaceNameType=%s' % (quote_attrib(self.PlaceNameType), ))
        if self.ElementSequenceNumber is not None and 'ElementSequenceNumber' not in already_processed:
            already_processed.add('ElementSequenceNumber')
            outfile.write(' ElementSequenceNumber=%s' % (quote_attrib(self.ElementSequenceNumber), ))
        if self.GNISFeatureID is not None and 'GNISFeatureID' not in already_processed:
            already_processed.add('GNISFeatureID')
            outfile.write(' GNISFeatureID=%s' % (quote_attrib(self.GNISFeatureID), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='PlaceName_type', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('PlaceNameType', node)
        if value is not None and 'PlaceNameType' not in already_processed:
            already_processed.add('PlaceNameType')
            self.PlaceNameType = value
        value = find_attr_value_('ElementSequenceNumber', node)
        if value is not None and 'ElementSequenceNumber' not in already_processed:
            already_processed.add('ElementSequenceNumber')
            self.ElementSequenceNumber = value
        value = find_attr_value_('GNISFeatureID', node)
        if value is not None and 'GNISFeatureID' not in already_processed:
            already_processed.add('GNISFeatureID')
            self.GNISFeatureID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PlaceName_type


class CompleteSubaddress_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SubaddressElement=None):
        self.original_tagname_ = None
        if SubaddressElement is None:
            self.SubaddressElement = []
        else:
            self.SubaddressElement = SubaddressElement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompleteSubaddress_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompleteSubaddress_type.subclass:
            return CompleteSubaddress_type.subclass(*args_, **kwargs_)
        else:
            return CompleteSubaddress_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubaddressElement(self): return self.SubaddressElement
    def set_SubaddressElement(self, SubaddressElement): self.SubaddressElement = SubaddressElement
    def add_SubaddressElement(self, value): self.SubaddressElement.append(value)
    def insert_SubaddressElement_at(self, index, value): self.SubaddressElement.insert(index, value)
    def replace_SubaddressElement_at(self, index, value): self.SubaddressElement[index] = value
    def hasContent_(self):
        if (
            self.SubaddressElement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='CompleteSubaddress_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompleteSubaddress_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompleteSubaddress_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='CompleteSubaddress_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='CompleteSubaddress_type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='CompleteSubaddress_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubaddressElement_ in self.SubaddressElement:
            SubaddressElement_.export(outfile, level, namespaceprefix_, name_='SubaddressElement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubaddressElement':
            obj_ = SubaddressElement_type.factory()
            obj_.build(child_)
            self.SubaddressElement.append(obj_)
            obj_.original_tagname_ = 'SubaddressElement'
# end class CompleteSubaddress_type


class CompleteLandmarkName_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Separator=None, LandmarkName=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        if LandmarkName is None:
            self.LandmarkName = []
        else:
            self.LandmarkName = LandmarkName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompleteLandmarkName_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompleteLandmarkName_type.subclass:
            return CompleteLandmarkName_type.subclass(*args_, **kwargs_)
        else:
            return CompleteLandmarkName_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LandmarkName(self): return self.LandmarkName
    def set_LandmarkName(self, LandmarkName): self.LandmarkName = LandmarkName
    def add_LandmarkName(self, value): self.LandmarkName.append(value)
    def insert_LandmarkName_at(self, index, value): self.LandmarkName.insert(index, value)
    def replace_LandmarkName_at(self, index, value): self.LandmarkName[index] = value
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def hasContent_(self):
        if (
            self.LandmarkName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='CompleteLandmarkName_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompleteLandmarkName_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompleteLandmarkName_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='CompleteLandmarkName_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='CompleteLandmarkName_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='CompleteLandmarkName_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LandmarkName_ in self.LandmarkName:
            LandmarkName_.export(outfile, level, namespaceprefix_, name_='LandmarkName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LandmarkName':
            obj_ = LandmarkName_type.factory()
            obj_.build(child_)
            self.LandmarkName.append(obj_)
            obj_.original_tagname_ = 'LandmarkName'
# end class CompleteLandmarkName_type


class CompletePlaceName_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Separator=None, PlaceName=None):
        self.original_tagname_ = None
        self.Separator = _cast(None, Separator)
        if PlaceName is None:
            self.PlaceName = []
        else:
            self.PlaceName = PlaceName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompletePlaceName_type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompletePlaceName_type.subclass:
            return CompletePlaceName_type.subclass(*args_, **kwargs_)
        else:
            return CompletePlaceName_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PlaceName(self): return self.PlaceName
    def set_PlaceName(self, PlaceName): self.PlaceName = PlaceName
    def add_PlaceName(self, value): self.PlaceName.append(value)
    def insert_PlaceName_at(self, index, value): self.PlaceName.insert(index, value)
    def replace_PlaceName_at(self, index, value): self.PlaceName[index] = value
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def hasContent_(self):
        if (
            self.PlaceName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='addr:', name_='CompletePlaceName_type', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CompletePlaceName_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CompletePlaceName_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='addr:', name_='CompletePlaceName_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='addr:', name_='CompletePlaceName_type'):
        if self.Separator is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            outfile.write(' Separator=%s' % (quote_attrib(self.Separator), ))
    def exportChildren(self, outfile, level, namespaceprefix_='addr:', name_='CompletePlaceName_type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PlaceName_ in self.PlaceName:
            PlaceName_.export(outfile, level, namespaceprefix_, name_='PlaceName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Separator', node)
        if value is not None and 'Separator' not in already_processed:
            already_processed.add('Separator')
            self.Separator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PlaceName':
            obj_ = PlaceName_type.factory()
            obj_.build(child_)
            self.PlaceName.append(obj_)
            obj_.original_tagname_ = 'PlaceName'
# end class CompletePlaceName_type


class MailForwardingAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MailForwardingAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MailForwardingAddressType.subclass:
            return MailForwardingAddressType.subclass(*args_, **kwargs_)
        else:
            return MailForwardingAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='MailForwardingAddressType', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MailForwardingAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MailForwardingAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MailForwardingAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MailForwardingAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MailForwardingAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class MailForwardingAddressType


class AddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AddressType', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class AddressType


class AddressType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType1.subclass:
            return AddressType1.subclass(*args_, **kwargs_)
        else:
            return AddressType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AddressType1', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AddressType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType1'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AddressType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class AddressType1


class AddressType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddressType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddressType2.subclass:
            return AddressType2.subclass(*args_, **kwargs_)
        else:
            return AddressType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='AddressType2', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AddressType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AddressType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AddressType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AddressType2'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AddressType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class AddressType2


class MailingAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MailingAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MailingAddressType.subclass:
            return MailingAddressType.subclass(*args_, **kwargs_)
        else:
            return MailingAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='MailingAddressType', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MailingAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MailingAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MailingAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MailingAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MailingAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class MailingAddressType


class PreviousResidenceAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviousResidenceAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviousResidenceAddressType.subclass:
            return PreviousResidenceAddressType.subclass(*args_, **kwargs_)
        else:
            return PreviousResidenceAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='PreviousResidenceAddressType', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PreviousResidenceAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PreviousResidenceAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PreviousResidenceAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PreviousResidenceAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PreviousResidenceAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class PreviousResidenceAddressType


class ResidenceAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CommunityAddress_type=None, FourNumberAddressRange_type=None, GeneralAddressClass_type=None, IntersectionAddress_type=None, LandmarkAddress_type=None, NumberedThoroughfareAddress_type=None, TwoNumberAddressRange_type=None, USPSGeneralDeliveryOffice_type=None, USPSPostalDeliveryBox_type=None, USPSPostalDeliveryRoute_type=None, UnnumberedThoroughfareAddress_type=None):
        self.original_tagname_ = None
        self.CommunityAddress_type = CommunityAddress_type
        self.FourNumberAddressRange_type = FourNumberAddressRange_type
        self.GeneralAddressClass_type = GeneralAddressClass_type
        self.IntersectionAddress_type = IntersectionAddress_type
        self.LandmarkAddress_type = LandmarkAddress_type
        self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
        self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
        self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
        self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
        self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
        self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResidenceAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResidenceAddressType.subclass:
            return ResidenceAddressType.subclass(*args_, **kwargs_)
        else:
            return ResidenceAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CommunityAddress_type(self): return self.CommunityAddress_type
    def set_CommunityAddress_type(self, CommunityAddress_type): self.CommunityAddress_type = CommunityAddress_type
    def get_FourNumberAddressRange_type(self): return self.FourNumberAddressRange_type
    def set_FourNumberAddressRange_type(self, FourNumberAddressRange_type): self.FourNumberAddressRange_type = FourNumberAddressRange_type
    def get_GeneralAddressClass_type(self): return self.GeneralAddressClass_type
    def set_GeneralAddressClass_type(self, GeneralAddressClass_type): self.GeneralAddressClass_type = GeneralAddressClass_type
    def get_IntersectionAddress_type(self): return self.IntersectionAddress_type
    def set_IntersectionAddress_type(self, IntersectionAddress_type): self.IntersectionAddress_type = IntersectionAddress_type
    def get_LandmarkAddress_type(self): return self.LandmarkAddress_type
    def set_LandmarkAddress_type(self, LandmarkAddress_type): self.LandmarkAddress_type = LandmarkAddress_type
    def get_NumberedThoroughfareAddress_type(self): return self.NumberedThoroughfareAddress_type
    def set_NumberedThoroughfareAddress_type(self, NumberedThoroughfareAddress_type): self.NumberedThoroughfareAddress_type = NumberedThoroughfareAddress_type
    def get_TwoNumberAddressRange_type(self): return self.TwoNumberAddressRange_type
    def set_TwoNumberAddressRange_type(self, TwoNumberAddressRange_type): self.TwoNumberAddressRange_type = TwoNumberAddressRange_type
    def get_USPSGeneralDeliveryOffice_type(self): return self.USPSGeneralDeliveryOffice_type
    def set_USPSGeneralDeliveryOffice_type(self, USPSGeneralDeliveryOffice_type): self.USPSGeneralDeliveryOffice_type = USPSGeneralDeliveryOffice_type
    def get_USPSPostalDeliveryBox_type(self): return self.USPSPostalDeliveryBox_type
    def set_USPSPostalDeliveryBox_type(self, USPSPostalDeliveryBox_type): self.USPSPostalDeliveryBox_type = USPSPostalDeliveryBox_type
    def get_USPSPostalDeliveryRoute_type(self): return self.USPSPostalDeliveryRoute_type
    def set_USPSPostalDeliveryRoute_type(self, USPSPostalDeliveryRoute_type): self.USPSPostalDeliveryRoute_type = USPSPostalDeliveryRoute_type
    def get_UnnumberedThoroughfareAddress_type(self): return self.UnnumberedThoroughfareAddress_type
    def set_UnnumberedThoroughfareAddress_type(self, UnnumberedThoroughfareAddress_type): self.UnnumberedThoroughfareAddress_type = UnnumberedThoroughfareAddress_type
    def hasContent_(self):
        if (
            self.CommunityAddress_type is not None or
            self.FourNumberAddressRange_type is not None or
            self.GeneralAddressClass_type is not None or
            self.IntersectionAddress_type is not None or
            self.LandmarkAddress_type is not None or
            self.NumberedThoroughfareAddress_type is not None or
            self.TwoNumberAddressRange_type is not None or
            self.USPSGeneralDeliveryOffice_type is not None or
            self.USPSPostalDeliveryBox_type is not None or
            self.USPSPostalDeliveryRoute_type is not None or
            self.UnnumberedThoroughfareAddress_type is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ResidenceAddressType', namespacedef_=' xmlns:addr="http://www.fgdc.gov/schemas/address/addr" ', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResidenceAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResidenceAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ResidenceAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResidenceAddressType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ResidenceAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CommunityAddress_type is not None:
            self.CommunityAddress_type.export(outfile, level, namespaceprefix_, name_='CommunityAddress_type', pretty_print=pretty_print)
        if self.FourNumberAddressRange_type is not None:
            self.FourNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='FourNumberAddressRange_type', pretty_print=pretty_print)
        if self.GeneralAddressClass_type is not None:
            self.GeneralAddressClass_type.export(outfile, level, namespaceprefix_, name_='GeneralAddressClass_type', pretty_print=pretty_print)
        if self.IntersectionAddress_type is not None:
            self.IntersectionAddress_type.export(outfile, level, namespaceprefix_, name_='IntersectionAddress_type', pretty_print=pretty_print)
        if self.LandmarkAddress_type is not None:
            self.LandmarkAddress_type.export(outfile, level, namespaceprefix_, name_='LandmarkAddress_type', pretty_print=pretty_print)
        if self.NumberedThoroughfareAddress_type is not None:
            self.NumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='NumberedThoroughfareAddress_type', pretty_print=pretty_print)
        if self.TwoNumberAddressRange_type is not None:
            self.TwoNumberAddressRange_type.export(outfile, level, namespaceprefix_, name_='TwoNumberAddressRange_type', pretty_print=pretty_print)
        if self.USPSGeneralDeliveryOffice_type is not None:
            self.USPSGeneralDeliveryOffice_type.export(outfile, level, namespaceprefix_, name_='USPSGeneralDeliveryOffice_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryBox_type is not None:
            self.USPSPostalDeliveryBox_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryBox_type', pretty_print=pretty_print)
        if self.USPSPostalDeliveryRoute_type is not None:
            self.USPSPostalDeliveryRoute_type.export(outfile, level, namespaceprefix_, name_='USPSPostalDeliveryRoute_type', pretty_print=pretty_print)
        if self.UnnumberedThoroughfareAddress_type is not None:
            self.UnnumberedThoroughfareAddress_type.export(outfile, level, namespaceprefix_, name_='UnnumberedThoroughfareAddress_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CommunityAddress_type':
            obj_ = CommunityAddress_type.factory()
            obj_.build(child_)
            self.CommunityAddress_type = obj_
            obj_.original_tagname_ = 'CommunityAddress_type'
        elif nodeName_ == 'FourNumberAddressRange_type':
            obj_ = FourNumberAddressRange_type.factory()
            obj_.build(child_)
            self.FourNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'FourNumberAddressRange_type'
        elif nodeName_ == 'GeneralAddressClass_type':
            obj_ = GeneralAddressClass_type.factory()
            obj_.build(child_)
            self.GeneralAddressClass_type = obj_
            obj_.original_tagname_ = 'GeneralAddressClass_type'
        elif nodeName_ == 'IntersectionAddress_type':
            obj_ = IntersectionAddress_type.factory()
            obj_.build(child_)
            self.IntersectionAddress_type = obj_
            obj_.original_tagname_ = 'IntersectionAddress_type'
        elif nodeName_ == 'LandmarkAddress_type':
            obj_ = LandmarkAddress_type.factory()
            obj_.build(child_)
            self.LandmarkAddress_type = obj_
            obj_.original_tagname_ = 'LandmarkAddress_type'
        elif nodeName_ == 'NumberedThoroughfareAddress_type':
            obj_ = NumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.NumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'NumberedThoroughfareAddress_type'
        elif nodeName_ == 'TwoNumberAddressRange_type':
            obj_ = TwoNumberAddressRange_type.factory()
            obj_.build(child_)
            self.TwoNumberAddressRange_type = obj_
            obj_.original_tagname_ = 'TwoNumberAddressRange_type'
        elif nodeName_ == 'USPSGeneralDeliveryOffice_type':
            obj_ = USPSGeneralDeliveryOffice_type.factory()
            obj_.build(child_)
            self.USPSGeneralDeliveryOffice_type = obj_
            obj_.original_tagname_ = 'USPSGeneralDeliveryOffice_type'
        elif nodeName_ == 'USPSPostalDeliveryBox_type':
            obj_ = USPSPostalDeliveryBox_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryBox_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryBox_type'
        elif nodeName_ == 'USPSPostalDeliveryRoute_type':
            obj_ = USPSPostalDeliveryRoute_type.factory()
            obj_.build(child_)
            self.USPSPostalDeliveryRoute_type = obj_
            obj_.original_tagname_ = 'USPSPostalDeliveryRoute_type'
        elif nodeName_ == 'UnnumberedThoroughfareAddress_type':
            obj_ = UnnumberedThoroughfareAddress_type.factory()
            obj_.build(child_)
            self.UnnumberedThoroughfareAddress_type = obj_
            obj_.original_tagname_ = 'UnnumberedThoroughfareAddress_type'
# end class ResidenceAddressType


class VoterRecordResults(VoterRecordsResponse):
    """Used in responses. For indicating a successful response to a lookup
    request. A lookup for a single voter may result in multiple
    VoterRecords being returned. This can occur if the voter has
    duplicate records in the VRDB, or if the criteria specified in
    the lookup request was broad."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None, VoterRecord=None):
        self.original_tagname_ = None
        super(VoterRecordResults, self).__init__(TransactionId, )
        if VoterRecord is None:
            self.VoterRecord = []
        else:
            self.VoterRecord = VoterRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoterRecordResults)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoterRecordResults.subclass:
            return VoterRecordResults.subclass(*args_, **kwargs_)
        else:
            return VoterRecordResults(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VoterRecord(self): return self.VoterRecord
    def set_VoterRecord(self, VoterRecord): self.VoterRecord = VoterRecord
    def add_VoterRecord(self, value): self.VoterRecord.append(value)
    def insert_VoterRecord_at(self, index, value): self.VoterRecord.insert(index, value)
    def replace_VoterRecord_at(self, index, value): self.VoterRecord[index] = value
    def hasContent_(self):
        if (
            self.VoterRecord or
            super(VoterRecordResults, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VoterRecordResults', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoterRecordResults')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecordResults')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='VoterRecordResults', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoterRecordResults'):
        super(VoterRecordResults, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoterRecordResults')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VoterRecordResults', fromsubclass_=False, pretty_print=True):
        super(VoterRecordResults, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VoterRecord_ in self.VoterRecord:
            VoterRecord_.export(outfile, level, namespaceprefix_, name_='VoterRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VoterRecordResults, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VoterRecord':
            obj_ = VoterRecord.factory()
            obj_.build(child_)
            self.VoterRecord.append(obj_)
            obj_.original_tagname_ = 'VoterRecord'
        super(VoterRecordResults, self).buildChildren(child_, node, nodeName_, True)
# end class VoterRecordResults


class RequestSuccess(VoterRecordsResponse):
    """Used in responses. For indicating a successful response to a
    request. The Action attribute is used to indicate the action
    that occurred, which may differ from what was requested. For
    example, a request for a new voter registration may succeed, but
    if the voter was already registered, the response may indicate a
    registration update as opposed to a registration create. The
    response also includes, optionally, other information useful to
    the voter, including a description of the voters polling place,
    districts (i.e., contests) associated with the polling place, or
    other geopolitical geographies such as the voters precinct."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None, Action=None, District=None, EffectiveDate=None, ElectionAdministration=None, Locality=None, PollingPlace=None):
        self.original_tagname_ = None
        super(RequestSuccess, self).__init__(TransactionId, )
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        if District is None:
            self.District = []
        else:
            self.District = District
        if isinstance(EffectiveDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(EffectiveDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EffectiveDate
        self.EffectiveDate = initvalue_
        self.ElectionAdministration = ElectionAdministration
        if Locality is None:
            self.Locality = []
        else:
            self.Locality = Locality
        self.PollingPlace = PollingPlace
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestSuccess)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestSuccess.subclass:
            return RequestSuccess.subclass(*args_, **kwargs_)
        else:
            return RequestSuccess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action_at(self, index, value): self.Action.insert(index, value)
    def replace_Action_at(self, index, value): self.Action[index] = value
    def get_District(self): return self.District
    def set_District(self, District): self.District = District
    def add_District(self, value): self.District.append(value)
    def insert_District_at(self, index, value): self.District.insert(index, value)
    def replace_District_at(self, index, value): self.District[index] = value
    def get_EffectiveDate(self): return self.EffectiveDate
    def set_EffectiveDate(self, EffectiveDate): self.EffectiveDate = EffectiveDate
    def get_ElectionAdministration(self): return self.ElectionAdministration
    def set_ElectionAdministration(self, ElectionAdministration): self.ElectionAdministration = ElectionAdministration
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def add_Locality(self, value): self.Locality.append(value)
    def insert_Locality_at(self, index, value): self.Locality.insert(index, value)
    def replace_Locality_at(self, index, value): self.Locality[index] = value
    def get_PollingPlace(self): return self.PollingPlace
    def set_PollingPlace(self, PollingPlace): self.PollingPlace = PollingPlace
    def validate_SuccessAction(self, value):
        # Validate type SuccessAction, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['address-updated', 'name-updated', 'registration-cancelled', 'registration-created', 'registration-updated', 'status-updated', 'other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SuccessAction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Action or
            self.District or
            self.EffectiveDate is not None or
            self.ElectionAdministration is not None or
            self.Locality or
            self.PollingPlace is not None or
            super(RequestSuccess, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestSuccess', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestSuccess')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestSuccess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestSuccess', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestSuccess'):
        super(RequestSuccess, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestSuccess')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestSuccess', fromsubclass_=False, pretty_print=True):
        super(RequestSuccess, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Action_ in self.Action:
            showIndent(outfile, level, pretty_print)
            outfile.write('<Action>%s</Action>%s' % (self.gds_encode(self.gds_format_string(quote_xml(Action_), input_name='Action')), eol_))
        for District_ in self.District:
            District_.export(outfile, level, namespaceprefix_, name_='District', pretty_print=pretty_print)
        if self.EffectiveDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<EffectiveDate>%s</EffectiveDate>%s' % (self.gds_format_date(self.EffectiveDate, input_name='EffectiveDate'), eol_))
        if self.ElectionAdministration is not None:
            self.ElectionAdministration.export(outfile, level, namespaceprefix_, name_='ElectionAdministration', pretty_print=pretty_print)
        for Locality_ in self.Locality:
            Locality_.export(outfile, level, namespaceprefix_, name_='Locality', pretty_print=pretty_print)
        if self.PollingPlace is not None:
            self.PollingPlace.export(outfile, level, namespaceprefix_, name_='PollingPlace', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestSuccess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            Action_ = child_.text
            Action_ = self.gds_validate_string(Action_, node, 'Action')
            self.Action.append(Action_)
            # validate type SuccessAction
            self.validate_SuccessAction(self.Action[-1])
        elif nodeName_ == 'District':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.District.append(obj_)
            obj_.original_tagname_ = 'District'
        elif nodeName_ == 'EffectiveDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EffectiveDate = dval_
        elif nodeName_ == 'ElectionAdministration':
            obj_ = ElectionAdministration.factory()
            obj_.build(child_)
            self.ElectionAdministration = obj_
            obj_.original_tagname_ = 'ElectionAdministration'
        elif nodeName_ == 'Locality':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.Locality.append(obj_)
            obj_.original_tagname_ = 'Locality'
        elif nodeName_ == 'PollingPlace':
            obj_ = ReportingUnit.factory()
            obj_.build(child_)
            self.PollingPlace = obj_
            obj_.original_tagname_ = 'PollingPlace'
        super(RequestSuccess, self).buildChildren(child_, node, nodeName_, True)
# end class RequestSuccess


class RequestRejection(VoterRecordsResponse):
    """Used in responses. For indicating that the request failed. The Error
    attribute is used to indicate the type of error that occurred.
    The AdditionalDetails attribute can be used to provide more
    information as to the rejection."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None, AdditionalDetails=None, Error=None):
        self.original_tagname_ = None
        super(RequestRejection, self).__init__(TransactionId, )
        if AdditionalDetails is None:
            self.AdditionalDetails = []
        else:
            self.AdditionalDetails = AdditionalDetails
        if Error is None:
            self.Error = []
        else:
            self.Error = Error
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestRejection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestRejection.subclass:
            return RequestRejection.subclass(*args_, **kwargs_)
        else:
            return RequestRejection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AdditionalDetails(self): return self.AdditionalDetails
    def set_AdditionalDetails(self, AdditionalDetails): self.AdditionalDetails = AdditionalDetails
    def add_AdditionalDetails(self, value): self.AdditionalDetails.append(value)
    def insert_AdditionalDetails_at(self, index, value): self.AdditionalDetails.insert(index, value)
    def replace_AdditionalDetails_at(self, index, value): self.AdditionalDetails[index] = value
    def get_Error(self): return self.Error
    def set_Error(self, Error): self.Error = Error
    def add_Error(self, value): self.Error.append(value)
    def insert_Error_at(self, index, value): self.Error.insert(index, value)
    def replace_Error_at(self, index, value): self.Error[index] = value
    def hasContent_(self):
        if (
            self.AdditionalDetails or
            self.Error or
            super(RequestRejection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestRejection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestRejection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestRejection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestRejection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestRejection'):
        super(RequestRejection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestRejection')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestRejection', fromsubclass_=False, pretty_print=True):
        super(RequestRejection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AdditionalDetails_ in self.AdditionalDetails:
            showIndent(outfile, level, pretty_print)
            outfile.write('<AdditionalDetails>%s</AdditionalDetails>%s' % (self.gds_encode(self.gds_format_string(quote_xml(AdditionalDetails_), input_name='AdditionalDetails')), eol_))
        for Error_ in self.Error:
            Error_.export(outfile, level, namespaceprefix_, name_='Error', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestRejection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AdditionalDetails':
            AdditionalDetails_ = child_.text
            AdditionalDetails_ = self.gds_validate_string(AdditionalDetails_, node, 'AdditionalDetails')
            self.AdditionalDetails.append(AdditionalDetails_)
        elif nodeName_ == 'Error':
            obj_ = Error.factory()
            obj_.build(child_)
            self.Error.append(obj_)
            obj_.original_tagname_ = 'Error'
        super(RequestRejection, self).buildChildren(child_, node, nodeName_, True)
# end class RequestRejection


class RequestAcknowledgement(VoterRecordsResponse):
    """Used in response messages. For indicating that the request was
    received but action on the request is pending."""
    subclass = None
    superclass = VoterRecordsResponse
    def __init__(self, TransactionId=None):
        self.original_tagname_ = None
        super(RequestAcknowledgement, self).__init__(TransactionId, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestAcknowledgement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestAcknowledgement.subclass:
            return RequestAcknowledgement.subclass(*args_, **kwargs_)
        else:
            return RequestAcknowledgement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RequestAcknowledgement, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='RequestAcknowledgement', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestAcknowledgement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestAcknowledgement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RequestAcknowledgement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestAcknowledgement'):
        super(RequestAcknowledgement, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestAcknowledgement')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RequestAcknowledgement', fromsubclass_=False, pretty_print=True):
        super(RequestAcknowledgement, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RequestAcknowledgement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RequestAcknowledgement, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RequestAcknowledgement


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'VoterRecordsRequest'
        rootClass = VoterRecordsRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from VRICore import *\n\n')
        sys.stdout.write('import VRICore as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AdditionalInfo",
    "AddressCollection",
    "AddressCoordinateReferenceSystem_type",
    "AddressNumberPrefix_type",
    "AddressNumberRange_type",
    "AddressNumberSuffix_type",
    "AddressReferenceSystemAxisPointOfBeginning_type",
    "AddressReferenceSystemAxis_type",
    "AddressReferenceSystemExtent_type",
    "AddressReferenceSystemGridAngle_type",
    "AddressReferenceSystemRangeBreakline_type",
    "AddressReferenceSystemRangeBreakpoint_type",
    "AddressReferenceSystemRangePolygon_type",
    "AddressReferenceSystemReferencePolyline_type",
    "AddressReferenceSystemRules_type",
    "AddressReferenceSystem_type",
    "AddressSchemeAxes_type",
    "AddressSchemeExtent_type",
    "AddressSchemeOrigin_type",
    "AddressType",
    "AddressType1",
    "AddressType2",
    "BallotRequest",
    "BallotStyle",
    "CommunityAddress_type",
    "CompleteAddressNumber_type",
    "CompleteLandmarkName_type",
    "CompletePlaceName_type",
    "CompleteStreetName_type",
    "CompleteSubaddress_type",
    "ContactMethod",
    "DeliveryAddress_type",
    "Election",
    "ElectionAdministration",
    "ElectionBasedBallotRequest",
    "Error",
    "ExternalIdentifier",
    "FeatureOccupancy_type",
    "File",
    "FourNumberAddressRange_type",
    "GeneralAddressClass_type",
    "GeneralAddress_type",
    "Image",
    "IntersectionAddress_type",
    "LandmarkAddress_type",
    "LandmarkName_type",
    "LatLng",
    "Location",
    "LocationLongLat_type",
    "LocationXY_type",
    "Location_type",
    "MailForwardingAddressType",
    "MailingAddressType",
    "Name",
    "NumberedThoroughfareAddress_type",
    "Party",
    "PermanentBallotRequest",
    "PhoneContactMethod",
    "PlaceName_type",
    "PreviousResidenceAddressType",
    "RelatedAddressID_type",
    "ReportingUnit",
    "RequestAcknowledgement",
    "RequestHelper",
    "RequestProxy",
    "RequestRejection",
    "RequestSuccess",
    "ResidenceAddressType",
    "Signature",
    "StreetNameGroup",
    "StreetNamePostDirectional_type",
    "StreetNamePostModifier_type",
    "StreetNamePostType_type",
    "StreetNamePreDirectional_type",
    "StreetNamePreModifier_type",
    "StreetNamePreType_type",
    "SubaddressElement_type",
    "TemporalBallotRequest",
    "TwoNumberAddressRange_type",
    "USPSAddress_type",
    "USPSBox_type",
    "USPSGeneralDeliveryOffice_type",
    "USPSPostalDeliveryBox_type",
    "USPSPostalDeliveryRoute_type",
    "USPSRoute_type",
    "UnnumberedThoroughfareAddress_type",
    "Voter",
    "VoterClassification",
    "VoterId",
    "VoterParticipation",
    "VoterRecord",
    "VoterRecordResults",
    "VoterRecordsRequest",
    "VoterRecordsResponse"
]
